{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Aktuelle Trends der IKT \u00b6 Herzlich willkommen zur Veranstaltung Aktuelle Trends der IKT ! Grober Inhalt \u00b6 Wir besch\u00e4ftigen uns dieses Semester mit Progressive Web Apps (PWA) . Dieser Begriff ist 2015 bei Google entstanden. Progressive Web Apps bieten installierbare nativen Apps \u00e4hnliche Nutzererfahrungen sowohl auf dem Desktop als auch auf dem Smartphone, sind aber Webanwendungen, die im Browser laufen, also zum World Wide Web geh\u00f6ren. Typische Eigenschaften von Progressive Web Apps sind die Einbindung von Kamera und Mikrofon, dem eigenen Standort sowie die F\u00e4higkeit, (zumindest teilweise) offline ausf\u00fchrbar zu sein. Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Die Vorlesungsvideos finden Sie darunter f\u00fcr die einzelnen Wochen (unter Inhalte ). Woche Themen (Vorlesung) \u00dcbung Aufgabe (Stand) Abgabe \u00dcbung bis 1. 04.-08.04.2022 Einf\u00fchrung und Organisatorisches - - - 2. 11.-15.04.2022 Grundger\u00fcst und Application Manifest \u00dcbung 1 - 30.04.2022 3. 18.-22.04.2022 Service workers \u00dcbung 2 - 07.05.2022 4. 25.-29.04.2022 Promises und Fetch API \u00dcbung 3 - 14.05.2022 5. 02.-06.05.2022 Service workers und Caching - - 21.05.2022 6. 09.-13.05.2022 Entwicklungsinfrastruktur \u00dcbung 4 - 28.05.2022 7. 16.-20.05.2022 Datenbank und Backend \u00dcbung 5 - 04.06.2022 8. 23.-27.05.2022 Frontend mit Backend-Anbindung \u00dcbung 6 - 11.06.2022 9. 30.-03.06.2022 Caching dynamische Daten mit IndexDB \u00dcbung 7 - 18.06.2022 10. 06.-10.06.2022 Hintergrundsynchronisation - Datenbank - 11. 13.-17.06.2022 Push-Notifikationen - Backend - 12. 20.-24.06.2022 Kamera und Geolocation - Backend - 13. 27.-01.07.2022 Wiederholung - Frontend - 14. 04.-08.07.2022 Wiederholung - Frontend - Abgabe 1.PZ 18.07.2022 - Abgabe 2.PZ 01.10.2022 - Organisatorisches \u00b6 Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie am Ende des Semesters die L\u00f6sung Ihrer Semesteraufgabe abgeben. Diese Aufgabe zusammen mit einem Gespr\u00e4ch, das wir \u00fcber Ihre L\u00f6sung f\u00fchren, wird bewertet. Die Bewertung entspricht dann der Modulnote. Die \u00dcbungen sind daf\u00fcr vorgesehen, dass Sie im Semester sukzessive Ihre L\u00f6sung erstellen k\u00f6nnen. Wir beantworten in den \u00dcbungen Ihre Fragen und l\u00f6sen gemeinsam Probleme. Jede Woche gibt es ein Thema, das Sie selbst\u00e4ndig durcharbeiten und dann angepasst in Ihre L\u00f6sung integrieren k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt! Inhalte \u00b6 Hier sind die Videos aus 2021 verlinkt!!! (auf Wunsch) Der aktuelle Stoff ist aber teilweise abge\u00e4ndert und angepasst! Insbesondere werden wir 2022 MongoDB als Datenbank verwenden und nicht PostgresQL. Au\u00dferdem haben sich wieder einige APIs seit 2021 ge\u00e4ndert. Woche 1 (Grundger\u00fcst) \u00b6 Woche 1 - Grundger\u00fcst Woche 2 (Manifest) \u00b6 Woche 2 - Manifest Diese Woche wird unsere App mithilfe des Application Manifest installierbar . Dazu gibt es folgendes Video: Woche 3 (Promises und Fetch API) \u00b6 Woche 3 - Promises und Fetch API Diese Woche betrachten wir den Lebenszyklus eines Service Workers, schauen uns Promises und die Fetch API an. Dazu dieses Video: Sourcecode zur Vorlesung am 05.05.2021 (also alt!!!) hier zum Herunterladen Semesteraufgabe \u00b6 Die als Semesteraufgabe zu entwickelnde Webanwendung sollte ein Frontend besitzen (muss nicht mit einem JavaScript-Framework erstellt werden), das Frontend soll responsive sein (wenn nicht, dann mobile first !), ein Backend (damit Daten auf dem Server verwaltet werden k\u00f6nnen), eine Datenbank zur persistenten Speicherung von Daten (wir verwenden MongoDB, kann aber auch MariaDB, MySQL, PostgresQL oder auch SQLite oder \u00e4hnlich In-Apps-Datenbanken sein), installierbar sein, offline nutzbar sein, die IndexedDB verwenden, Hintergrundsynchronisation verwenden, Push-Nachrichten verwenden, die Gelocation API verwenden, die Kamera oder eine andere technische Schnittstelle (z.B. Sensoren, Mikrofon) verwenden. Von den Punkten 5.-11. sollten 5 f\u00fcr eine 2,0 implementiert sein, 6 f\u00fcr eine 1,7 und 7 f\u00fcr eine 1,3. Ist die Anwendung besonders toll und/oder deployed, kann es auch eine 1,0 werden. Bitte erstellen Sie eine aussagekr\u00e4ftige README.md -Datei. Die erstellte Anwendung soll pr\u00e4sentiert werden und in einem kurzen Gespr\u00e4ch (15-20min) wird die Implementierung besprochen. Hier eine Idee einer Anwendung, eine Ausgabenverwaltung : installierbare Webanwendung, Formular f\u00fcr die Buchung einer Ausgabe Datum, Titel f\u00fcr die Ausgabe, Betrag, Foto des Kassenzettels, evtl. Geolocation des Ausgabeortes \u00dcbersicht \u00fcber Ausgaben, offline verwendbar, d.h. Ausgabe wird in der IndexedDB gespeichert und erst, wenn wieder online, dann in der Datenbank, Push-Benachrichtigung, wenn Ausgabe in der Datenbank gespeichert (Hintergrundsynchronisation), Backend ist zwingend erforderlich (f\u00fcr Speichern und Abrufen der Daten in die und aus der Datenbank), MongoDB zur persitenten Datenspeicherung, evtl. Nutzerverwaltung zur Verwaltung der eigenen Ausgaben. Sie k\u00f6nnen nat\u00fcrlich auch eine eigene Anwendungsidee umsetzen! Viel Spa\u00df und Erfolg!","title":"Home"},{"location":"#aktuelle-trends-der-ikt","text":"Herzlich willkommen zur Veranstaltung Aktuelle Trends der IKT !","title":"Aktuelle Trends der IKT"},{"location":"#grober-inhalt","text":"Wir besch\u00e4ftigen uns dieses Semester mit Progressive Web Apps (PWA) . Dieser Begriff ist 2015 bei Google entstanden. Progressive Web Apps bieten installierbare nativen Apps \u00e4hnliche Nutzererfahrungen sowohl auf dem Desktop als auch auf dem Smartphone, sind aber Webanwendungen, die im Browser laufen, also zum World Wide Web geh\u00f6ren. Typische Eigenschaften von Progressive Web Apps sind die Einbindung von Kamera und Mikrofon, dem eigenen Standort sowie die F\u00e4higkeit, (zumindest teilweise) offline ausf\u00fchrbar zu sein. Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Die Vorlesungsvideos finden Sie darunter f\u00fcr die einzelnen Wochen (unter Inhalte ). Woche Themen (Vorlesung) \u00dcbung Aufgabe (Stand) Abgabe \u00dcbung bis 1. 04.-08.04.2022 Einf\u00fchrung und Organisatorisches - - - 2. 11.-15.04.2022 Grundger\u00fcst und Application Manifest \u00dcbung 1 - 30.04.2022 3. 18.-22.04.2022 Service workers \u00dcbung 2 - 07.05.2022 4. 25.-29.04.2022 Promises und Fetch API \u00dcbung 3 - 14.05.2022 5. 02.-06.05.2022 Service workers und Caching - - 21.05.2022 6. 09.-13.05.2022 Entwicklungsinfrastruktur \u00dcbung 4 - 28.05.2022 7. 16.-20.05.2022 Datenbank und Backend \u00dcbung 5 - 04.06.2022 8. 23.-27.05.2022 Frontend mit Backend-Anbindung \u00dcbung 6 - 11.06.2022 9. 30.-03.06.2022 Caching dynamische Daten mit IndexDB \u00dcbung 7 - 18.06.2022 10. 06.-10.06.2022 Hintergrundsynchronisation - Datenbank - 11. 13.-17.06.2022 Push-Notifikationen - Backend - 12. 20.-24.06.2022 Kamera und Geolocation - Backend - 13. 27.-01.07.2022 Wiederholung - Frontend - 14. 04.-08.07.2022 Wiederholung - Frontend - Abgabe 1.PZ 18.07.2022 - Abgabe 2.PZ 01.10.2022 -","title":"Grober Inhalt"},{"location":"#organisatorisches","text":"Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie am Ende des Semesters die L\u00f6sung Ihrer Semesteraufgabe abgeben. Diese Aufgabe zusammen mit einem Gespr\u00e4ch, das wir \u00fcber Ihre L\u00f6sung f\u00fchren, wird bewertet. Die Bewertung entspricht dann der Modulnote. Die \u00dcbungen sind daf\u00fcr vorgesehen, dass Sie im Semester sukzessive Ihre L\u00f6sung erstellen k\u00f6nnen. Wir beantworten in den \u00dcbungen Ihre Fragen und l\u00f6sen gemeinsam Probleme. Jede Woche gibt es ein Thema, das Sie selbst\u00e4ndig durcharbeiten und dann angepasst in Ihre L\u00f6sung integrieren k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt!","title":"Organisatorisches"},{"location":"#inhalte","text":"Hier sind die Videos aus 2021 verlinkt!!! (auf Wunsch) Der aktuelle Stoff ist aber teilweise abge\u00e4ndert und angepasst! Insbesondere werden wir 2022 MongoDB als Datenbank verwenden und nicht PostgresQL. Au\u00dferdem haben sich wieder einige APIs seit 2021 ge\u00e4ndert.","title":"Inhalte"},{"location":"#woche-1-grundgerust","text":"Woche 1 - Grundger\u00fcst","title":"Woche 1 (Grundger\u00fcst)"},{"location":"#woche-2-manifest","text":"Woche 2 - Manifest Diese Woche wird unsere App mithilfe des Application Manifest installierbar . Dazu gibt es folgendes Video:","title":"Woche 2 (Manifest)"},{"location":"#woche-3-promises-und-fetch-api","text":"Woche 3 - Promises und Fetch API Diese Woche betrachten wir den Lebenszyklus eines Service Workers, schauen uns Promises und die Fetch API an. Dazu dieses Video: Sourcecode zur Vorlesung am 05.05.2021 (also alt!!!) hier zum Herunterladen","title":"Woche 3 (Promises und Fetch API)"},{"location":"#semesteraufgabe","text":"Die als Semesteraufgabe zu entwickelnde Webanwendung sollte ein Frontend besitzen (muss nicht mit einem JavaScript-Framework erstellt werden), das Frontend soll responsive sein (wenn nicht, dann mobile first !), ein Backend (damit Daten auf dem Server verwaltet werden k\u00f6nnen), eine Datenbank zur persistenten Speicherung von Daten (wir verwenden MongoDB, kann aber auch MariaDB, MySQL, PostgresQL oder auch SQLite oder \u00e4hnlich In-Apps-Datenbanken sein), installierbar sein, offline nutzbar sein, die IndexedDB verwenden, Hintergrundsynchronisation verwenden, Push-Nachrichten verwenden, die Gelocation API verwenden, die Kamera oder eine andere technische Schnittstelle (z.B. Sensoren, Mikrofon) verwenden. Von den Punkten 5.-11. sollten 5 f\u00fcr eine 2,0 implementiert sein, 6 f\u00fcr eine 1,7 und 7 f\u00fcr eine 1,3. Ist die Anwendung besonders toll und/oder deployed, kann es auch eine 1,0 werden. Bitte erstellen Sie eine aussagekr\u00e4ftige README.md -Datei. Die erstellte Anwendung soll pr\u00e4sentiert werden und in einem kurzen Gespr\u00e4ch (15-20min) wird die Implementierung besprochen. Hier eine Idee einer Anwendung, eine Ausgabenverwaltung : installierbare Webanwendung, Formular f\u00fcr die Buchung einer Ausgabe Datum, Titel f\u00fcr die Ausgabe, Betrag, Foto des Kassenzettels, evtl. Geolocation des Ausgabeortes \u00dcbersicht \u00fcber Ausgaben, offline verwendbar, d.h. Ausgabe wird in der IndexedDB gespeichert und erst, wenn wieder online, dann in der Datenbank, Push-Benachrichtigung, wenn Ausgabe in der Datenbank gespeichert (Hintergrundsynchronisation), Backend ist zwingend erforderlich (f\u00fcr Speichern und Abrufen der Daten in die und aus der Datenbank), MongoDB zur persitenten Datenspeicherung, evtl. Nutzerverwaltung zur Verwaltung der eigenen Ausgaben. Sie k\u00f6nnen nat\u00fcrlich auch eine eigene Anwendungsidee umsetzen! Viel Spa\u00df und Erfolg!","title":"Semesteraufgabe"},{"location":"caching/","text":"Caching mit Service Workern \u00b6 Caching ist ein Konzept, um Ressourcen zu speichern, um sie nicht wieder vom Server laden zu m\u00fcssen. Browser verf\u00fcgen \u00fcber eigene Caches (\"Pufferspeicher\") und darin k\u00f6nnen Browser Bilder, CSS-Dateien, JavaScript-Dateien und andere Mediadateien (z.B. pdf) speichern, um diese nicht erneut vom Webserver laden zu m\u00fcssen. Das Caching beschleunigt das wiederholte Laden von Webseiten. Caching mit service workern verfolgt das gleiche Prinzip. Auch hier werden Ressourcen in einen Cache geladen. Der Vorteil hierbei ist jedoch nicht das schnellere Laden beim Wiederholen, sondern die M\u00f6glichkeit zu er\u00f6ffnen, die Webanwendung auch (teilweise) offline auszuf\u00fchren. Mit dem Service-Worker-Caching bieten wir somit die F\u00e4higkeit des Offline-Modus unserer Anwendung. Die Verwendung eines Caches durch einen service worker erfolgt mithilfe der Cache API . Die Cache API \u00b6 Die Cache API verfolgt ein ganz simples Konzept. Mithilfe der Cache API werden einfach (Schl\u00fcssel-/Werte-)Paare von Requests und Responses gespeichert. Auf den Cache (also auf die Menge aller gespeicherten Request-/Response-Paare) k\u00f6nnen sowohl service worker als auch das JavaScript der Webanwendung zugreifen. Allerdings kann es ja sein, dass das \"normale\" JavaScript der Webanwendung (noch) nicht geladen werden kann, weil z.B. die Internetverbindung zu schwach ist oder nicht vorhanden, ein service worker kann aber trotzdem bereits Daten aus dem Cache liefern, ohne \u00fcberhaupt einen Request \u00fcber das Internet zu senden. Wichtig ist noch zu betonen, dass die Cache API (noch) nicht von besonders vielen Browsern unterst\u00fctzt wird. Das sieht man hier , wenn Sie nach ganz unten scrollen. Im Prinzip funktioniert es nur (vollst\u00e4ndig) mit Chrome, Firefox und Opera. Bereinigen des HTW-Insta-Projektes \u00b6 Bevor wir unseren Service-Worker-Cache implementieren, bereinigen wir zun\u00e4chst noch unser HTW-Insta-Projekt. Aus der public/src/js/app.js entfernen wir den gesamten Code, der sich auf Promises und die Fetch API bezog. Die app.js sieht nun (wieder) so aus: public/src/js/app.js if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( '/sw.js' ) . then (() => { console . log ( 'service worker registriert' ) }) . catch ( err => { console . log ( err ); } ); } In der public/sw.js (also in unserem service worker ), l\u00f6schen wir die Ausgaben auf die Konsole f\u00fcr das fetch -Event. Stattdessen f\u00fcgen wir eine respondWith() -Funktion ein: public/sw.js self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) self . addEventListener ( 'fetch' , event => { event . respondWith ( fetch ( event . request )); }) Die respondWith() -Funktion ist eine Funktion des fetch -Events (also FetchEvent.respondWith() ). Sie sorgt einerseits daf\u00fcr, den Browser von seiner Standardbehandlung des FetchEvents abzuhalten und stattdessen eine eigene Promise f\u00fcr die Behandlung des FetchEvents zu definieren. Die Standardsyntax ist: fetchEvent . respondWith ( // Promise that resolves to a Response. ); Hier ist ein Beispiel f\u00fcr die respondWith() -Funktion aus : 1 2 3 4 5 6 7 8 9 10 11 addEventListener ( 'fetch' , event => { // Prevent the default, and handle the request ourselves. event . respondWith ( async function () { // Try to get the response from a cache. const cachedResponse = await caches . match ( event . request ); // Return it if we found one. if ( cachedResponse ) return cachedResponse ; // If we didn't find a match in the cache, use the network. return fetch ( event . request ); }()); }); Darin wird f\u00fcr ein fetch -Event zun\u00e4chst gepr\u00fcft, ob der request im Cache vorhanden ist (Zeile 5 ). Wenn ja, dann bekommt die Variable cachedResponse den Wert der response aus dem Cache ( match liefert die response zum zugeh\u00f6rigen request ). Wenn das der Fall ist, dann liefert responseWith() genau diese response aus dem Cache zur\u00fcck. Wenn der request nicht im Cache gespeichert ist, dann wird einfach der event.request weitergeleitet, also nichts aus dem Cache genommen. In unserer derzeitigen Implementierung (highlighted Zeile 11 oben), wird noch nicht auf den Cache zugegriffen, sondern der request direkt an den Webserver weitergeleitet. Sollten Sie daf\u00fcr einen Fehler bekommen, weil das Promise als nicht korrekt behandelt gilt, dann k\u00f6nnen Sie diese Zeile zun\u00e4chst auch einfach auskommentieren. Eine etwas gr\u00f6\u00dfere \u00c4nderung f\u00fchren wir in der public/src/js/feed.js durch. Wir f\u00fcgen statisch einen Blog-Eintrag hinzu. Die Anwendung sieht dann so aus: Schauen Sie in die index.html . In das folgende <div id=\"shared-moments\"></div> f\u00fcgen wir eine Card der Form <div class=\"shared-moment-card mdl-card mdl-shadow--2dp\"></div> hinzu, welche das Foto und den Text enth\u00e4lt. Das passiert in einer Funktion createCard() : public/src/js/feed.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 let shareImageButton = document . querySelector ( '#share-image-button' ); let createPostArea = document . querySelector ( '#create-post' ); let closeCreatePostModalButton = document . querySelector ( '#close-create-post-modal-btn' ); let sharedMomentsArea = document . querySelector ( '#shared-moments' ); function openCreatePostModal () { createPostArea . style . display = 'block' ; } function closeCreatePostModal () { createPostArea . style . display = 'none' ; } shareImageButton . addEventListener ( 'click' , openCreatePostModal ); closeCreatePostModalButton . addEventListener ( 'click' , closeCreatePostModal ); function createCard () { let cardWrapper = document . createElement ( 'div' ); cardWrapper . className = 'shared-moment-card mdl-card mdl-shadow--2dp' ; let cardTitle = document . createElement ( 'div' ); cardTitle . className = 'mdl-card__title' ; cardTitle . style . backgroundImage = 'url(\"/src/images/htw-gebaeude-h.jpg\")' ; cardTitle . style . backgroundSize = 'cover' ; cardTitle . style . height = '180px' ; cardWrapper . appendChild ( cardTitle ); let cardTitleTextElement = document . createElement ( 'h2' ); cardTitleTextElement . className = 'mdl-card__title-text' ; cardTitleTextElement . textContent = 'Vor der HTW-Mensa' ; cardTitle . appendChild ( cardTitleTextElement ); let cardSupportingText = document . createElement ( 'div' ); cardSupportingText . className = 'mdl-card__supporting-text' ; cardSupportingText . textContent = 'HTW Berlin' ; cardSupportingText . style . textAlign = 'center' ; cardWrapper . appendChild ( cardSupportingText ); componentHandler . upgradeElement ( cardWrapper ); sharedMomentsArea . appendChild ( cardWrapper ); } fetch ( 'https://httpbin.org/get' ) . then ( function ( res ) { return res . json (); }) . then ( function ( data ) { createCard (); }); Zun\u00e4chst wird in Zeile 4 auf das div mit der id=\"shared-moments\" zugegriffen. In dieses div wird die Card eingef\u00fcgt. Alles CSS-Klassen mit mdl- am Anfang sind Klassen von Material Design Ligt . F\u00fcr die CSS-Klasse shared-moment-card definieren wir in public/src/css/feed.css noch: . shared-moment-card . mdl-card { margin : 10 px auto ; } so, dass die Card einen Abstand vom Rand bekommt. Interessant ist vielleicht noch die Zeile 36 componentHandler.upgradeElement(cardWrapper); . Mit dieser Funktion m\u00fcssen dynamisch erzeugte DOM-Elemente registriert werden, damit sie von Material Design Lite automatisch verwaltet werden. Siehe dazu Uses MDL on dynamic websites . IKT-PWA-03 bei GitHub \u00b6 Das Bild htw-gebaeude-h.jpg muss auch noch dem public/src/images -Ordner hinzugef\u00fcgt werden. Die aktuelle Ausgangssituation unseres Projektes finden Sie hier . Achten Sie bitte darauf, dass Sie (zumindest so lange wir uns mit dem Service-Worker-Cache besch\u00e4ftigen) das H\u00e4kchen bei Disable Cache in den Developer Tools unter Network gesetzt haben: Was soll in den Cache? \u00b6 Zun\u00e4chst \u00fcberlegen wir uns, was \u00fcberhaupt in den Cache soll und was nicht. Prinzipiell verfolgen wir mit dem Service-Worker-Cache die Idee, dass die Anwendung auch offline verwendbar bleiben soll. Wenn wir unsere aktuelle Anwendung betrachten, dann k\u00f6nnen wir unterscheiden zwischen \"statischen\" und \"dynamischen\" Inhalten. Statisch ist im Prinzip der Rahmen unserer Anwendung, also im prinzip alles, was wir hatten vor unserem ersten Blog-Eintrag. Dieser Rahmen gibt uns das Gef\u00fchl, dass die Anwendung \"l\u00e4uft\" - es fehlen nur die dynamischen Inhalte, also die Blog-Eintr\u00e4ge. Stattdessen k\u00f6nnte man aber eine Meldung ausgeben, dass diese Inhalte derzeit nicht verf\u00fcgbar sind. Das w\u00e4re alles jedenfalls besser als eine 404-Seite oder ein unendliches Warten oder das hier: Der Rahmen einer Webanwendung wird auch App-Shell genannt. Wir wollen diese App-Shell zun\u00e4chst in unseren Service-Worker-Cache speichern. Static caching/Precaching \u00b6 Wir wollen zun\u00e4chst die statischen Inhalte unserer Anwendung sin den Cache speichern. Dies geschieht beim Installieren (registrieren) des service workers. Das ist auch insofern praktisch, als dass der service worker ja nur dann neu registriert wird, wenn er ge\u00e4ndert wurde. Ansonsten bleibt einfach der \"alte\" existent. Ziel ist es also, zun\u00e4chst alles das in den Cache zu speichern, was unsere Webanwendung ausmacht: die index.html , alle *.css -Dateien, die mittels <link href=\"...\"> in dieser index.html einegunden werden, alle *.js -Dateien, die mittels <script src=\"...\"> in dieser index.html einegunden werden und alle *.png -Dateien, die mittels <link href=\"...\"> in dieser index.html einegunden werden. Den Service-Worker-Cache erstellen \u00b6 Wir haben bereits eingangs festgelegt, dass wir den Cache in dem Moment anlegen wollen, in dem der service worker installiert wird. Das bedeutet, wir erstellen den Cache in der Ereignisbehandlung des Lebenszyklus-Event install des service workers, also hier ( sw.js ): self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); // hier soll der Cache \"entstehen\" }) Den Service-Worker-Cache erstellen wir mithilfe der Anweisung caches.open(); . Hierbei handelt es sich um eine Funktion von CacheStorage . Die Funktion caches.open() erzeugt ein Cache -Objekt, wenn es noch nicht existiert. Die R\u00fcckgabe ( response der Promise ) ist also ein Cache -Objekt. Man k\u00f6nnte nun annehmen, man schreibt einfach das hier: 1 2 3 4 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); caches . open (); // nicht gut! }) Diese Idee ist aber nicht so gut, da wir immer im Hinterkopf behalten m\u00fcssen, dass in einem service worker alles asynchron abgearbeitet wird. Das bedeutet, dass wir in diesem Fall bei der Baehandlung des install -Events zwei Anweisungen einfach \"antriggern\": die Ausgabe auf die Konsole (Zeile 2 ) und das Erzeugen eines Cache -Objektes (Zeile 3 ). Wie lange jedes einzelne braucht und wann etwas fertig ist, wissen wir nicht. Das bedeutet z.B. dass die Ereignisbehandlung des install -Events fertig ist, noch bevor die Ausgabe auf die Konsole und/oder das Erzeugen des Cache -Objektes abgeschlossen ist/sind. Das wiederum w\u00fcrde bedeuten, dass wir asynchron evtl. bereits fetch -Anfragen ausl\u00f6sen, noch bevor der Cache bereit ist. Um dieses Problem zu verhindern, betten wir die Erzeugung des Cache -Objektes in eine event.waitUntil() -Funktion ein. Erst wenn diese Funktion abgeschlossen ist, ist auch die Ereignisbehandlung des install -Events abgeschlossen (siehe auch hier ). Das richtige Vorgehen ist also dieses: 1 2 3 4 5 6 7 8 9 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); }) ); }) caches.open() erzeugt also ein Promise , dessen response der erzeugte Cache ist. Wir konsumieren diesen Cache und geben zun\u00e4chst nur eine Ausgabe auf der Konsole aus. Der Parameter 'static' in caches.open() ist ein Name f\u00fcr den Cache. Die Namen sind frei w\u00e4hlbar und man kann verschiedene Namen vergeben. Das sind dann jeweils eine Art \"Unter\"-Caches (oder sub caches ) im Service-Worker-Cache. Eine Ressource in den Cache speichern \u00b6 Nun kann der Cache entsprechend mit request - response -Schl\u00fcssel-Werte-Paaren bef\u00fcllt werden. Die auf den Cache anwenbaren Funktionen sind hier dokumentiert. Es sind match(request, options) , matchAll(request, options) , add(request) , , addAll(request) , , put(request, response) , delete(request, options) und , keys(request, options) . Alle liefern nat\u00fcrlich ein Promise zur\u00fcck. Um die statischen Inhalte unserer Webanwendung in den Cache zu laden, verwenden wir die add(request) -Funktion. Diese Funktion macht folgendes: sie f\u00fchrt den request aus ( fetch(request) ) und speichert die response (also die angefragte Ressource) \u2192 dieses Speichern entspricht einem put(request, response) im Cache. Wenn wir also folgendes implementieren: 1 2 3 4 5 6 7 8 9 10 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . add ( '/src/js/app.js' ); // relativ vom public-Ordner }) ); }) , dann wird beim Initialisieren des service workers die Ressource public/src/js/app.js beim Webserver angefragt und die response , also die app.js im Cache gespeichert. Wenn wir unsere Anwednung so ausf\u00fchren, dann sehen wir in den DeveloperTools im Reiter Application im Cache Storage den Cache static und darin die gespeicherte Ressource /src/js/app.js . Eine Ressource aus dem Cache lesen \u00b6 Jetzt haben wir einen Ressource in den Cache geladen, aber wir verwenden sie noch nicht, da wir in der bisherigen Behandlung des fetch -Events den Cache noch nicht nutzen. Zur Erinnerung: bei der Behandlung des fetch -Events wirkt der service worker wie ein Proxy. Er \"schaltet\" sich zwischen die Webanwendung und die Anfrage dieser an den Webserver. In unserer derzeitigen Implementierung des fetch -Events wird der request einfach an den Webserver durchgeschleust, ohne irgendetwas damit zu tun. Das wollen wir nun \u00e4ndern: 1 2 3 4 5 6 7 8 9 10 11 12 self . addEventListener ( 'fetch' , event => { event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ); } }) ); }) Wir reagieren auf das fetch -Ereignis zun\u00e4chst mit der respondWith() -Funktion, die wir bereits oben besprochen haben. Diese Funktion verhindert die Ausf\u00fchrung des Standardverhaltens beim fetch , n\u00e4mlich die Anfrage an den Webserver. Stattdessen fragen wir mithilfe der caches.match() -Funktion alle sub caches unseres Caches nach dem als Parameter \u00fcbergebenen request an. Im Cache sind die Eintr\u00e4ge als Schl\u00fcssel-Werte-Paare request - response abgespeichert. Findet sich der request im Cache, dann liefert die Promise ein response -Objekt zur\u00fcck. Wenn das so ist (Zeile 5 ), dann geben wir dieses response -Objekt an die Webanwendung zur\u00fcck (Zeile 6 ). Das ist dann also die aus dem Cache geladene Ressource. Wenn die match() -Funktion jedoch den Schl\u00fcssel request nicht im Cache gefunden hat (und somit auch keine response ), gibt sie zwar trotzdem ein Promise zur\u00fcck, aber dann ist die response null . Das bedeutet, dass die if -Abfrage in Zeile 5 ein false zur\u00fcckgibt und wir somit Zeile 8 ausf\u00fchren. Darin wird die Anfrage einfach an den Webserver weitergeleitet, die Ressource also vom Webserver geladen. Wir \u00fcberpr\u00fcfen die Funktionalit\u00e4t dieser fetch -Ereignisbehandlung: Unter dem Reiter Network in den DeveloperTools sehen wir, dass die app.js durch den Service Worker geladen wurde. Alle anderen Ressourcen wurden auch durch den Service Worker geladen, das liegt daran, dass wir im Service Worker die Anfrage an den Webserver durch den Service Worker durchschleusen. Wichtig ist aber, dass die app.js nicht vom Webserver geladen wurde. Das erkennen war daran, dass alle anderen Ressourcen mit ihren Gr\u00f6\u00dfenangaben in der Tabelle stehen und dass damit gesagt, wurde, wieviel Bytes vom Webserver geladen wurden. Die app.js taucht dabei aber nicht auf. Sie wurde durch den Service Worker aus dem Service-Worker-Cache ( Cache Storage ) geladen! Okay, das ist jetzt vielleicht noch nicht besonders eindrucksvoll, weil der Offline-Modus f\u00fcr unsere Webanwendung noch nicht funktioniert und wir bis jetzt nur die app.js in den Cache speichern und von dort bei einem fetch() laden. Dadurch sieht man noch nicht wirklich viel. Deshalb laden wir jetzt den statischen \"Rest\", insbesondere die index.html und die dazugeh\u00f6rigen *.css -Dateien. Zuvor jedoch noch eine kurze Anmerkung zu den Schl\u00fcssel-Werte-Paaren request und response im Cache: Schl\u00fcssel-Werte-Paare request und response \u00b6 Wir laden jetzt unsere index.html -Datei in den Cache: 1 2 3 4 5 6 7 8 9 10 11 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . add ( '/index.html' ); cache . add ( '/src/js/app.js' ); // relativ vom public-Ordner }) ); }) Wenn wir unsere Anwendung neu starten und den service worker erneut registrieren, dann sollte jetzt die index.html im Offline-Modus angezeigt werden (wenn auch ohne die CSS-Styles). Allerdings sieht die Anwendung nach dem Reload im Offline-Modus leider so aus wie auf der linken Seite der folgenden Abbildung gezeigt: Der Grund daf\u00fcr ist, dass wir die Anwendung mit localhost:8080 (oder 127.0.0.1:8080 ) aufrufen, der request also / ist. Im Cache gespeichert haben wir aber den request /index.html . Und tats\u00e4chlich, wenn wir localhost:8080/index.html (oder 127.0.0.1:8080/index.html ) aufrufen, dann wird der request /index.html im Cache gefunden und als response die index.html zur\u00fcckgegeben (rechte Seite in der Abbildung). Wichtig ist also, dass wir bedenken, dass alle requests , f\u00fcr die wir responses im Cache hinterlegen wollen, auch tats\u00e4chlich in den Cache hinzugef\u00fcgt werden. Unsere sw.js sollte also auch so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . add ( '/' ); cache . add ( '/index.html' ); cache . add ( '/src/js/app.js' ); // relativ vom public-Ordner }) ); }) Dann erhalten wir auch das rechte Bild der Abbildung beim Aufruf von localhost:8080 (oder 127.0.0.1:8080 ) im Offline-Modus. Wir sollten also beachten, dass alle requests , die wir cachen wollen, auch tats\u00e4chlich in den Cache gespeichert werden. Alle statischen Ressourcen in den Cache laden \u00b6 Wir laden jetzt alle statischen Ressourcen in den Cache, d.h. alles, was notwendig ist, um unsere Webanwendung auch im Offline-Modus so aussehen zu lassen, als w\u00fcrde sie \"laufen\". Dazu geh\u00f6rt nat\u00fcrlich die index.html und dann noch alle Ressourcen, die in der index.html eingebunden werden, also einige *.js -Dateien, einige *.css -Dateien und das Bild, das oben in der Webanwendung erscheint. Man k\u00f6nnte das alles mit einzelnen cache.add() -Funktionen erledigen, so wie oben. Daf\u00fcr gibt es aber auch die cache.addAll() -Funktion, der ein Array aus lauter requests \u00fcbergeben wird. Die Implementierung der install -Ereignisbehandlung in unserer sw.js sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . addAll ([ '/' , '/index.html' , '/src/js/app.js' , '/src/js/feed.js' , '/src/js/material.min.js' , '/src/css/app.css' , '/src/css/feed.css' , '/src/images/htw.jpg' , 'https://fonts.googleapis.com/css?family=Roboto:400,700' , 'https://fonts.googleapis.com/icon?family=Material+Icons' , 'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css' ]); }) ); }) Wenn wir nun unsere Anwendung neu starten und darauf achten, dass der neue Service Worker auch wirklich registriert wird und dann in den Offline-Modus schalten, dann sieht unsere Anwendung so aus: Wie auf der rechten Seite der Abbildung zu sehen ist, funktioniert auch das JavaScript, um zum Formular zu gelangen. Einige Sachen funktionieren im Offline-Modus nicht, weil wir sie nicht in den Cache geladen haben: die Hilfeseite ( /help/index.html und die dazugeh\u00f6rige help.css ) sowie den Blogeintrag, den wir bereits (statisch) vorgenommen haben (den binden wir gleich noch dynamisch ein). Eine andere Sache f\u00e4llt aber vielleicht auf: die Icons von Material Design Lite erscheinen nicht, d.h. das Men\u00fc links oben ist nur ein leeres Quadrat und auf dem roten runden Button fehlt das Plus, stattdessen steht dort add . Wenn wir diesem Problem nachgehen, dann sehen wir in den DeveloperTools unter dem Reiter Network , dass alle Ressourcen, die wir im Cache gespeichert haben, auch tats\u00e4chlich aus diesem Cache geladen werden: Zus\u00e4tzlich schlagen aber noch \"kryptische\" GET-Anfragen fehl (die roten ganz unten in der Abbildung). Hier werden offensichtlich noch Anfragen an den Webserver gestellt, von denen wir gar nichts wussten und die wir nicht im Cache vorhalten. Wo kommen diese Anfragen her? Wenn wir dort in den DeveloperTools bspw. auf die Ressource https://fonts.googleapis.com/icon?family=Material+Icons klicken, dann erscheint daneben der Inhalt der geladenen Ressource und wir finden darin einen weiteren request , den wir aber nicht in unserem Cache hinterlegt haben (weil wir es gar nicht wussten): Diese Anfragen schlagen im Offline-Modus (nat\u00fcrlich) fehl und deshalb fehlen uns die Material Design Icons. Gut w\u00e4re es, wenn solche dynamischen Anfragen ebenfalls im Cache landen w\u00fcrden. Mit diesem dynamischen Caching besch\u00e4ftigen wir uns deshalb jetzt: Dynamisches Caching \u00b6 Bis jetzt haben wir mit cache.add() bzw. cache.addAll() vorab festgelegt, was in den Cache geladen werden soll. Das wird statisches Caching oder pre-caching genannt. Jetzt k\u00fcmmern wir uns um sogenanntes dynamisches Caching . Manchmal m\u00f6chte man gar nicht schon gleich zu Beginn alles in den Cache laden, um die \"Installation\", das erstmalige Aufrufen der Seite nicht zu aufw\u00e4ndig und somit zu langsam zu gestalten. Manchmal kennt man aber auch gar nicht die Ressourcen, die man noch zum Cache hinzuf\u00fcgen m\u00f6chte, wie das obere Beispiel gezeigt hat, als wir die Material Icons nicht in den Cache geladen haben, weil wir diese Anfrage vorab gar nicht kannten. Die Behandlung des fetch-Events erweitern \u00b6 Wir schauen uns zun\u00e4chst nochmal die aktuelle Behandlung des fetch -Events im service worker an: 1 2 3 4 5 6 7 8 9 10 11 12 self . addEventListener ( 'fetch' , event => { event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ); } }) ); }) Zur Erinnerung: mit dieser behandlung schalten wir uns zwischen die Abfrage der Webseite an den Webserver. Diese Behandlung wirkt wie ein Proxy. Bei jeder Anfrage der Webseite an den Webserver wird diese Implementierung des fetch -Events aufgerufen. Wir erwidern den request mit einer response . Entweder kommt diese response aus dem Cache, n\u00e4mlich dann, wenn caches.match(event.request) eine response zur\u00fcckgibt. In diesem Fall wird die response zur\u00fcck an die Webseite geschickt und der Webserver wird gar nicht mehr weiter angefragt. Oder wir leiten die Anfrage tats\u00e4chlich an den Webserver weiter ( return fetch(event.request); ), n\u00e4mlich dann, wenn der event.request nicht als Schl\u00fcssel im Cache verf\u00fcgbar ist und dieser deshalb keine response zur\u00fcckgibt. An dieser Stelle f\u00fcgen wir nun unser dynamisches Caching ein. Der Webserver wird mit einer response antworten und wir werden diese response in unseren Cache laden. Dazu ben\u00f6tigen wir zwei Dinge: einen neuen, weiteren Cache, in dem wir den entsprechenden request und die response des Webservers speichern und die cache.put() -Anweisung. put() unterscheidet sich von add() dahingehend, dass add() nur einen Parameter ben\u00f6tigt, n\u00e4mlich den request und die response automatisch als ein Schl\u00fcssel-Werte-Paar ( request, response ) speichert, w\u00e4hrend put() beide Werte als Schl\u00fcssel-Werte-Paar speichert, d.h. zwei Parameter erwartet ( request , response ). Ein erster Implementierungsversuch sieht so aus: 7 8 9 10 11 12 13 14 15 } else { return fetch ( event . request ) . then ( res => { // nicht erneut response nehmen, haben wir schon caches . open ( 'dynamic' ) // neuer, weiterer Cache namens dynamic . then ( cache => { cache . put ( event . request . url , res ); // hier die put-Anweisung }) }); } Die Zeilen 9-14 sind hinzugekommen. Die fetch() -Anweisung ist ein Promise , deshalb f\u00fcgen wir ein .then() an. Die response m\u00fcssen wir jetzt anders nennen, da es die Variable response ja bereits gibt und es jetzt um die response des Webservers geht, also nennen wir sie res (kann nat\u00fcrlich auch anders hei\u00dfen). Dann \u00f6ffnen wir einen neuen Cache, den wir dynamic nennen - kann auch anders hei\u00dfen. Wenn der Cache noch nicht existiert, wird er durch open() erstellt. open() ist wiederum ein Promise, so dass wir .then() ankn\u00fcpfen k\u00f6nnen und f\u00fcgen in den Cache mithilfe von put() das Schl\u00fcssel-Werte-Paar ( event.request.url, res ) ein. Das w\u00e4re schon fast korrekt, aber es fehlt noch, dass wir die Response res nat\u00fcrlich an die Webseite zur\u00fcckgeben wollen. Dazu f\u00fcgen wir einerseits return res; ein, m\u00fcssen aber auch daf\u00fcr sorgen, dass die res auch an den fetch() -Aufruf zur\u00fcckgegeben wird. Dehalb ben\u00f6tigen wir auch vor caches.open() noch ein return . Au\u00dferdem m\u00fcssen wir noch einen weiteren Aspekt beachten. Wenn eine Response verwendet wird, wird sie konsumiert , d.h. verbraucht. Das ist so f\u00fcr Responses, auch wenn es nicht so wirklich nachvollziehbar und verst\u00e4ndlich ist. Wir verwenden in unserem Code zwei Mal res , einmal um es in den Cache zu speichern und ein anderes Mal, um es an die Webseite zur\u00fcckzugeben. In einer der beiden Verwendungen w\u00fcrde unsere res verbraucht/konsumiert werden und das andere Mal w\u00e4re sie leer. Kein Ahnung, warum das so ist ;-) . Aber wir ben\u00f6tigen an einer der beiden Stellen ein res.clone() , um den Clone der Response zu verwenden und die Response nicht zu \"verbrauchen\". Wir speichern den Clone der Response in den Cache (wir k\u00f6nnten auch die res in den Cache speichern und res.clone() zur\u00fcckgeben). Die gesamte Implementierung sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 self . addEventListener ( 'fetch' , event => { event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ) . then ( res => { // nicht erneut response nehmen, haben wir schon return caches . open ( 'dynamic' ) // neuer, weiterer Cache namens dynamic . then ( cache => { cache . put ( event . request . url , res . clone ()); return res ; }) }); } }) ); }) Wenn wir nun die Anwendung ausf\u00fchren ( npm start ), dann in den Offline -Modus gehen und ein Reload im Browser durchf\u00fchren, sehen wir, dass die Material-Icons nun auch im Offline-Modus vorhanden sind: Wenn wir uns in den DeveloperTools unter Application auf der linken Seite unter Cache den Cache Storage anschauen, dann sehen wir, dass dort nun 2 Caches sind, der static und der dynamic Cache. In dem dynmic Cache finden wir nun auch die Material Icons wieder und unter dem Network -Reiter gibt es auch keine \"Fehler\" mehr, sondern alle Ressourcen werden vom Service Worker aus dem Cache geladen: Als weiteres Zeichen, dass nun alle Inhalte dynamisch geladen werden, erkennen wir auch die \"Mensa-Card\" in unserer Anwendung im Offline-Modus. Diese hatten wir ja statisch nicht hinzugef\u00fcgt. Probieren Sie auch einmal die \"Hilfe-Seite\" der Anwendung aus. Im Offline-Modus ist sie noch nicht verf\u00fcgbar. Wenn wir aber wieder online gehen, die \"Hilfe-Seite\" aufrufen und dann wieder offline gehen, ist die Hilfe-Seite im Cache und wird angezeigt. chrome.webRequest-API \u00b6 Der Chromium-Browser hat eine eigene API f\u00fcr Requests und schaltet sich bei Anfragen selbst dazwischen, um den Traffic zu analysieren und eventuelle Anfragen zu blockieren. Auch diese Anfragen l\u00f6sen ein fetch -Event aus. Allerdings gibt es bei von Chromium ausgel\u00f6sten Requests in dem request keine url -Eigenschaft. Vielleicht haben Sie einen solchen Fehler auch in Ihren DeveloperTools entdeckt. Eine Chromium-Anfrage unterscheidet sich von einer \"normalen\" Anfrage der Webseite an den Webserver dadurch, dass in einer \"normalen\" Anfrage die angefragte Ressource unter \" htttp://... \", also unter einer URL verf\u00fcgbar ist. Um nun den fehlerhaften Zugriff auf die url -Eigenschaft von request bei einer Anfrage durch Chrome zu vermeiden, f\u00fcgen wir ganz am Anfang der Ereignisbehandlung des fetch -Events noch die Abfrage ein, ob der request das Wort \" http \" enth\u00e4lt. Wenn nicht, verlassen wir die Behandlung des Events einfach: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 self . addEventListener ( 'fetch' , event => { // check if request is made by chrome extensions or web page // if request is made for web page url must contains http. if ( ! ( event . request . url . indexOf ( 'http' ) === 0 )) return ; // skip the request if request is not made with http protocol event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ) . then ( res => { // nicht erneut response nehmen, haben wir schon return caches . open ( 'dynamic' ) // neuer, weiterer Cache namens dynamic . then ( cache => { cache . put ( event . request . url , res . clone ()); return res ; }) }); } }) ); }) Versionierung von Caches \u00b6 Wir haben nun sowohl statisch als auch dynamisch Ressourcen unserer Webanwendung geladen. Wenn wir eine Weile auf unserer Anwendung navigieren, laden wir nach und nach alle Ressourcen in den Cache, die unsere Anwendung ausmachen. Irgendwann k\u00f6nnen wir sie komplett offline betreiben. Alle Ressourcen sind im Cache und keine Ressourcen werden mehr vom Webserver geladen. Was passiert aber, wenn wir etwas \u00e4ndern? Wenn wir den Service worker sw.js \u00e4ndern, dann k\u00f6nnen wir daf\u00fcr sorgen, dass er neu geladen wird. Der Service worker darf auch niemals in den Cache geladen werden, denn dann h\u00e4tten wir eine unendliche Schleife, die immer wieder Ressourcen in den Cache l\u00e4dt! Wenn wir irgendeine andere Datei, eine *.html -, *.css - oder *.js -Datei \u00e4ndern, dann wird diese nie mehr in ihrer aktuellen Version vom Webserver geladen, da sie ja bereits im Cache ist und deshalb immer (in ihrer alten Version) aus dem Cache geladen wird. Um dieses problem zu beheben, versionieren wir unsere Caches. Neue Cache-Versionen erstellen \u00b6 Eine neue \"Version\" eines Caches erstellen wir dadurch, dass wir einen neuen Cache mit anderem Namen erstellen. Unsere beiden Caches (der statische und der dynamische) werden jeweils im Service Worker ( sw.js ) benannt: aktueller Stand sw.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . addAll ([ '/' , '/index.html' , '/src/js/app.js' , '/src/js/feed.js' , '/src/js/material.min.js' , '/src/css/app.css' , '/src/css/feed.css' , '/src/images/htw.jpg' , 'https://fonts.googleapis.com/css?family=Roboto:400,700' , 'https://fonts.googleapis.com/icon?family=Material+Icons' , 'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css' ]); }) ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) self . addEventListener ( 'fetch' , event => { // check if request is made by chrome extensions or web page // if request is made for web page url must contains http. if ( ! ( event . request . url . indexOf ( 'http' ) === 0 )) return ; // skip the request. if request is not made with http protocol event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ) . then ( res => { // nicht erneut response nehmen, haben wir schon return caches . open ( 'dynamic' ) // neuer, weiterer Cache namens dynamic . then ( cache => { cache . put ( event . request . url , res . clone ()); return res ; }) }); } }) ); }) Mit wechselndem Namen wechseln wir auch die \"Version\" des Caches. Wenn wir die Implementierung des statischen Service Workers (mit dem dynamischen ist es gleich, wir zeigen es hier zun\u00e4chst nur f\u00fcr den statischen) in der Zeile 4 bespielsweise auf caches . open ( 'static-v1' ) \u00e4ndern, ensteht ein neuer zus\u00e4tzlicher Caches static-v1 . Mit solchen \"Versionierungen\" erreichen wir, dass der Service Worker neu ausgef\u00fchrt und somit wirksam wird. Ge\u00e4nderte Dateien gelangen so neu in diesen neuen Caches. Leider bleiben aber auch die alten Caches noch bestehen und die Funktion caches.match() sucht in allen Caches nach dem passenden Request. Die \u00c4nderungen w\u00e4ren dann also trotzdem noch nicht sichtbar. Wir m\u00fcssen jetzt noch daf\u00fcr sorgen, dass die \"alten\" Caches gel\u00f6scht werden. Um uns zu \u00fcberlegen, an welcher Stelle ein geeigneter Platz w\u00e4re, die alten Caches zu l\u00f6schen, hier nochmal eine kurze Wiederholung des Service-Worker-Lifecycles : install : Das install -Ereignis ist das erste Ereignis, das ein Service Worker ausl\u00f6st. Es wird genau einmal ausgel\u00f6st. Die Promise in installEvent.waitUntil() gibt Auskunft dar\u00fcber, ob das Installieren des Service Workers erfolgreich war oder nicht. So lange der Service Worker installiert wird, kann er keine fetch -Ereignisse empfangen und behandeln. activate : Sobald die Installation erfolgreich abgeschlossen ist, wird das activate -Ereignis ausgel\u00f6st. waiting : Wenn ein Service Worker activated ist, d.h. das activate -Event f\u00fcr diesen Service Worker ausgel\u00f6st wurde, kontrolliert er die Anfragen der Webseite (insb. wenn clients.claim() ausgef\u00fchrt wurde, was dazu f\u00fchrt, dass auch alle Unterseiten der Seite \"kontrolliert\" werden). Wird der Service Worker ge\u00e4ndert (aktualisiert) und erneut installiert, kann der ge\u00e4nderte Service Worker nicht sofort in den activated Zustand \u00fcbergehen, so lange ein anderer Service Worker active ist. Der aktualisierte Service Worker ist dann waiting . Das Bild zeigt einen aktualisierten Service Worker ( #877 ) waiting solange der Service Worker #875 noch activated ist. Erst, wenn skipWaiting geklickt wird ( self.skipWaiting() ), wird der aktualisierte Service Worker activated . Ein guter Punkt, existierende Caches zu l\u00f6schen, die man nicht mehr verwenden m\u00f6chte, ist, wenn ein (neuer/aktualisierter) Service Worker activated ist. Wir erweitern also die behandlung des activate -Ereignisses: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); event . waitUntil ( caches . keys () . then ( keyList => { return Promise . all ( keyList . map ( key => { if ( key !== 'static-v1' && key !== 'dynamic' ) { console . log ( 'service worker --> old cache removed :' , key ); return caches . delete ( key ); } })) }) ); return self . clients . claim (); }) Die ersten beiden und die letzten beiden Zeilen hatten wir bereits. Zeilen 3-13 sind neu. Betrachten wir den Code genauer: Die Funktion waitUntil() (Zeile 4 ) gibt es sowohl f\u00fcr das install -Event als auch f\u00fcr das activate -Ereignis. Dieser Funktion wird ein Promise \u00fcbergeben. Wir \u00fcbergeben als Promise die Funktion caches.keys() (Zeile 5 ). caches.keys gibt alle Namen der Service-Worker-Caches als Schl\u00fcssel zur\u00fcck. In unserem Fall also static , static-v1 und dynamic . die Funktion Promise.all() wird, verwendet, wenn auf ein Array von Promises \"gewartet\" werden soll. Die Funktion ist also dann beendet, wenn alle Promises des Arrays beendet sind. Promise.all() wartet auf ein Array von Promises. Wir haben aber mit keyList \"nur\" ein Array von Strings (die Namen der Caches). Mithilfe der map() -Funktion wandeln wir dieses Array von Strings in ein Array von Promises um. die map -Funktion nimmt nun jeden einzelnen String aus dem Array keyList und \"macht\" damit etwas (Zeilen 7-10 ) es wird gepr\u00fcft, ob der key entweder dem dynamischen Cache entspricht ( 'dynamic' ) oder dem neuen statischen Cache ( 'static-v1' ). Wenn das nicht der Fall ist, dann wird der Cache mit dem Namen key gel\u00f6scht (Zeile 9 ). return caches.delete(key) gibt somit ein Promise zur\u00fcck (an die map -Funktion). Somit wird jeder Schl\u00fcssel aus der keyList in ein Promise umgewandelt (f\u00fcr static-v1 und dynamic wird null zur\u00fcckgegeben). wenn alle dieses Promises beendet sind, ist auch die Promise.all() -Funktion beendet und somit auch die event.waitUntil() -Funktion. Somit l\u00f6schen wir alle \"alten\" statischen Caches und behalten nur die Caches static-v1 und dynamic . Wenn wir also etwas in unseren *.html , *.css und/oder *.js -Dateien \u00e4ndern und das Ge\u00e4nderte wirksam werden lassen wollen, \u00e4ndern wir einfach die Namen der Caches im Service Worker und sobald der Service Worker aktiviert ist, existieren nur noch die neuen Caches und die alten sind gel\u00f6scht. Damit wir das an zentraler Stelle im sw.js machen, lagern wir die aktuellen Namen der Caches in Konstanten aus. Die vollst\u00e4ndige Implementierung unseres Service Workers sieht so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 const CURRENT_STATIC_CACHE = 'static-v2' ; const CURRENT_DYNAMIC_CACHE = 'dynamic-v2' ; self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( CURRENT_STATIC_CACHE ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . addAll ([ '/' , '/index.html' , '/src/js/app.js' , '/src/js/feed.js' , '/src/js/material.min.js' , '/src/css/app.css' , '/src/css/feed.css' , '/src/images/htw.jpg' , 'https://fonts.googleapis.com/css?family=Roboto:400,700' , 'https://fonts.googleapis.com/icon?family=Material+Icons' , 'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css' ]); }) ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); event . waitUntil ( caches . keys () . then ( keyList => { return Promise . all ( keyList . map ( key => { if ( key !== CURRENT_STATIC_CACHE && key !== CURRENT_DYNAMIC_CACHE ) { console . log ( 'service worker --> old cache removed :' , key ); return caches . delete ( key ); } })) }) ); return self . clients . claim (); }) self . addEventListener ( 'fetch' , event => { // check if request is made by chrome extensions or web page // if request is made for web page url must contains http. if ( ! ( event . request . url . indexOf ( 'http' ) === 0 )) return ; // skip the request. if request is not made with http protocol event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ) . then ( res => { // nicht erneut response nehmen, haben wir schon return caches . open ( CURRENT_DYNAMIC_CACHE ) // neuer, weiterer Cache namens dynamic . then ( cache => { cache . put ( event . request . url , res . clone ()); return res ; }) }); } }) ); }) Zusammenfassung \u00b6 Die Zusammanfassung f\u00fcr das Caching kann man im folgenden Bild darstellen. Mithilfe des Caching haben wir es geschafft, dass unsere Anwendung im Offline-Modus nicht mehr so aussieht, wie links, sondern wie rechts. Toll! Noch einige n\u00fctzliche Links: Service Worker API The offline cookbook Google: Service Worker","title":"Caching"},{"location":"caching/#caching-mit-service-workern","text":"Caching ist ein Konzept, um Ressourcen zu speichern, um sie nicht wieder vom Server laden zu m\u00fcssen. Browser verf\u00fcgen \u00fcber eigene Caches (\"Pufferspeicher\") und darin k\u00f6nnen Browser Bilder, CSS-Dateien, JavaScript-Dateien und andere Mediadateien (z.B. pdf) speichern, um diese nicht erneut vom Webserver laden zu m\u00fcssen. Das Caching beschleunigt das wiederholte Laden von Webseiten. Caching mit service workern verfolgt das gleiche Prinzip. Auch hier werden Ressourcen in einen Cache geladen. Der Vorteil hierbei ist jedoch nicht das schnellere Laden beim Wiederholen, sondern die M\u00f6glichkeit zu er\u00f6ffnen, die Webanwendung auch (teilweise) offline auszuf\u00fchren. Mit dem Service-Worker-Caching bieten wir somit die F\u00e4higkeit des Offline-Modus unserer Anwendung. Die Verwendung eines Caches durch einen service worker erfolgt mithilfe der Cache API .","title":"Caching mit Service Workern"},{"location":"caching/#die-cache-api","text":"Die Cache API verfolgt ein ganz simples Konzept. Mithilfe der Cache API werden einfach (Schl\u00fcssel-/Werte-)Paare von Requests und Responses gespeichert. Auf den Cache (also auf die Menge aller gespeicherten Request-/Response-Paare) k\u00f6nnen sowohl service worker als auch das JavaScript der Webanwendung zugreifen. Allerdings kann es ja sein, dass das \"normale\" JavaScript der Webanwendung (noch) nicht geladen werden kann, weil z.B. die Internetverbindung zu schwach ist oder nicht vorhanden, ein service worker kann aber trotzdem bereits Daten aus dem Cache liefern, ohne \u00fcberhaupt einen Request \u00fcber das Internet zu senden. Wichtig ist noch zu betonen, dass die Cache API (noch) nicht von besonders vielen Browsern unterst\u00fctzt wird. Das sieht man hier , wenn Sie nach ganz unten scrollen. Im Prinzip funktioniert es nur (vollst\u00e4ndig) mit Chrome, Firefox und Opera.","title":"Die Cache API"},{"location":"caching/#bereinigen-des-htw-insta-projektes","text":"Bevor wir unseren Service-Worker-Cache implementieren, bereinigen wir zun\u00e4chst noch unser HTW-Insta-Projekt. Aus der public/src/js/app.js entfernen wir den gesamten Code, der sich auf Promises und die Fetch API bezog. Die app.js sieht nun (wieder) so aus: public/src/js/app.js if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( '/sw.js' ) . then (() => { console . log ( 'service worker registriert' ) }) . catch ( err => { console . log ( err ); } ); } In der public/sw.js (also in unserem service worker ), l\u00f6schen wir die Ausgaben auf die Konsole f\u00fcr das fetch -Event. Stattdessen f\u00fcgen wir eine respondWith() -Funktion ein: public/sw.js self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) self . addEventListener ( 'fetch' , event => { event . respondWith ( fetch ( event . request )); }) Die respondWith() -Funktion ist eine Funktion des fetch -Events (also FetchEvent.respondWith() ). Sie sorgt einerseits daf\u00fcr, den Browser von seiner Standardbehandlung des FetchEvents abzuhalten und stattdessen eine eigene Promise f\u00fcr die Behandlung des FetchEvents zu definieren. Die Standardsyntax ist: fetchEvent . respondWith ( // Promise that resolves to a Response. ); Hier ist ein Beispiel f\u00fcr die respondWith() -Funktion aus : 1 2 3 4 5 6 7 8 9 10 11 addEventListener ( 'fetch' , event => { // Prevent the default, and handle the request ourselves. event . respondWith ( async function () { // Try to get the response from a cache. const cachedResponse = await caches . match ( event . request ); // Return it if we found one. if ( cachedResponse ) return cachedResponse ; // If we didn't find a match in the cache, use the network. return fetch ( event . request ); }()); }); Darin wird f\u00fcr ein fetch -Event zun\u00e4chst gepr\u00fcft, ob der request im Cache vorhanden ist (Zeile 5 ). Wenn ja, dann bekommt die Variable cachedResponse den Wert der response aus dem Cache ( match liefert die response zum zugeh\u00f6rigen request ). Wenn das der Fall ist, dann liefert responseWith() genau diese response aus dem Cache zur\u00fcck. Wenn der request nicht im Cache gespeichert ist, dann wird einfach der event.request weitergeleitet, also nichts aus dem Cache genommen. In unserer derzeitigen Implementierung (highlighted Zeile 11 oben), wird noch nicht auf den Cache zugegriffen, sondern der request direkt an den Webserver weitergeleitet. Sollten Sie daf\u00fcr einen Fehler bekommen, weil das Promise als nicht korrekt behandelt gilt, dann k\u00f6nnen Sie diese Zeile zun\u00e4chst auch einfach auskommentieren. Eine etwas gr\u00f6\u00dfere \u00c4nderung f\u00fchren wir in der public/src/js/feed.js durch. Wir f\u00fcgen statisch einen Blog-Eintrag hinzu. Die Anwendung sieht dann so aus: Schauen Sie in die index.html . In das folgende <div id=\"shared-moments\"></div> f\u00fcgen wir eine Card der Form <div class=\"shared-moment-card mdl-card mdl-shadow--2dp\"></div> hinzu, welche das Foto und den Text enth\u00e4lt. Das passiert in einer Funktion createCard() : public/src/js/feed.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 let shareImageButton = document . querySelector ( '#share-image-button' ); let createPostArea = document . querySelector ( '#create-post' ); let closeCreatePostModalButton = document . querySelector ( '#close-create-post-modal-btn' ); let sharedMomentsArea = document . querySelector ( '#shared-moments' ); function openCreatePostModal () { createPostArea . style . display = 'block' ; } function closeCreatePostModal () { createPostArea . style . display = 'none' ; } shareImageButton . addEventListener ( 'click' , openCreatePostModal ); closeCreatePostModalButton . addEventListener ( 'click' , closeCreatePostModal ); function createCard () { let cardWrapper = document . createElement ( 'div' ); cardWrapper . className = 'shared-moment-card mdl-card mdl-shadow--2dp' ; let cardTitle = document . createElement ( 'div' ); cardTitle . className = 'mdl-card__title' ; cardTitle . style . backgroundImage = 'url(\"/src/images/htw-gebaeude-h.jpg\")' ; cardTitle . style . backgroundSize = 'cover' ; cardTitle . style . height = '180px' ; cardWrapper . appendChild ( cardTitle ); let cardTitleTextElement = document . createElement ( 'h2' ); cardTitleTextElement . className = 'mdl-card__title-text' ; cardTitleTextElement . textContent = 'Vor der HTW-Mensa' ; cardTitle . appendChild ( cardTitleTextElement ); let cardSupportingText = document . createElement ( 'div' ); cardSupportingText . className = 'mdl-card__supporting-text' ; cardSupportingText . textContent = 'HTW Berlin' ; cardSupportingText . style . textAlign = 'center' ; cardWrapper . appendChild ( cardSupportingText ); componentHandler . upgradeElement ( cardWrapper ); sharedMomentsArea . appendChild ( cardWrapper ); } fetch ( 'https://httpbin.org/get' ) . then ( function ( res ) { return res . json (); }) . then ( function ( data ) { createCard (); }); Zun\u00e4chst wird in Zeile 4 auf das div mit der id=\"shared-moments\" zugegriffen. In dieses div wird die Card eingef\u00fcgt. Alles CSS-Klassen mit mdl- am Anfang sind Klassen von Material Design Ligt . F\u00fcr die CSS-Klasse shared-moment-card definieren wir in public/src/css/feed.css noch: . shared-moment-card . mdl-card { margin : 10 px auto ; } so, dass die Card einen Abstand vom Rand bekommt. Interessant ist vielleicht noch die Zeile 36 componentHandler.upgradeElement(cardWrapper); . Mit dieser Funktion m\u00fcssen dynamisch erzeugte DOM-Elemente registriert werden, damit sie von Material Design Lite automatisch verwaltet werden. Siehe dazu Uses MDL on dynamic websites .","title":"Bereinigen des HTW-Insta-Projektes"},{"location":"caching/#ikt-pwa-03-bei-github","text":"Das Bild htw-gebaeude-h.jpg muss auch noch dem public/src/images -Ordner hinzugef\u00fcgt werden. Die aktuelle Ausgangssituation unseres Projektes finden Sie hier . Achten Sie bitte darauf, dass Sie (zumindest so lange wir uns mit dem Service-Worker-Cache besch\u00e4ftigen) das H\u00e4kchen bei Disable Cache in den Developer Tools unter Network gesetzt haben:","title":"IKT-PWA-03 bei GitHub"},{"location":"caching/#was-soll-in-den-cache","text":"Zun\u00e4chst \u00fcberlegen wir uns, was \u00fcberhaupt in den Cache soll und was nicht. Prinzipiell verfolgen wir mit dem Service-Worker-Cache die Idee, dass die Anwendung auch offline verwendbar bleiben soll. Wenn wir unsere aktuelle Anwendung betrachten, dann k\u00f6nnen wir unterscheiden zwischen \"statischen\" und \"dynamischen\" Inhalten. Statisch ist im Prinzip der Rahmen unserer Anwendung, also im prinzip alles, was wir hatten vor unserem ersten Blog-Eintrag. Dieser Rahmen gibt uns das Gef\u00fchl, dass die Anwendung \"l\u00e4uft\" - es fehlen nur die dynamischen Inhalte, also die Blog-Eintr\u00e4ge. Stattdessen k\u00f6nnte man aber eine Meldung ausgeben, dass diese Inhalte derzeit nicht verf\u00fcgbar sind. Das w\u00e4re alles jedenfalls besser als eine 404-Seite oder ein unendliches Warten oder das hier: Der Rahmen einer Webanwendung wird auch App-Shell genannt. Wir wollen diese App-Shell zun\u00e4chst in unseren Service-Worker-Cache speichern.","title":"Was soll in den Cache?"},{"location":"caching/#static-cachingprecaching","text":"Wir wollen zun\u00e4chst die statischen Inhalte unserer Anwendung sin den Cache speichern. Dies geschieht beim Installieren (registrieren) des service workers. Das ist auch insofern praktisch, als dass der service worker ja nur dann neu registriert wird, wenn er ge\u00e4ndert wurde. Ansonsten bleibt einfach der \"alte\" existent. Ziel ist es also, zun\u00e4chst alles das in den Cache zu speichern, was unsere Webanwendung ausmacht: die index.html , alle *.css -Dateien, die mittels <link href=\"...\"> in dieser index.html einegunden werden, alle *.js -Dateien, die mittels <script src=\"...\"> in dieser index.html einegunden werden und alle *.png -Dateien, die mittels <link href=\"...\"> in dieser index.html einegunden werden.","title":"Static caching/Precaching"},{"location":"caching/#den-service-worker-cache-erstellen","text":"Wir haben bereits eingangs festgelegt, dass wir den Cache in dem Moment anlegen wollen, in dem der service worker installiert wird. Das bedeutet, wir erstellen den Cache in der Ereignisbehandlung des Lebenszyklus-Event install des service workers, also hier ( sw.js ): self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); // hier soll der Cache \"entstehen\" }) Den Service-Worker-Cache erstellen wir mithilfe der Anweisung caches.open(); . Hierbei handelt es sich um eine Funktion von CacheStorage . Die Funktion caches.open() erzeugt ein Cache -Objekt, wenn es noch nicht existiert. Die R\u00fcckgabe ( response der Promise ) ist also ein Cache -Objekt. Man k\u00f6nnte nun annehmen, man schreibt einfach das hier: 1 2 3 4 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); caches . open (); // nicht gut! }) Diese Idee ist aber nicht so gut, da wir immer im Hinterkopf behalten m\u00fcssen, dass in einem service worker alles asynchron abgearbeitet wird. Das bedeutet, dass wir in diesem Fall bei der Baehandlung des install -Events zwei Anweisungen einfach \"antriggern\": die Ausgabe auf die Konsole (Zeile 2 ) und das Erzeugen eines Cache -Objektes (Zeile 3 ). Wie lange jedes einzelne braucht und wann etwas fertig ist, wissen wir nicht. Das bedeutet z.B. dass die Ereignisbehandlung des install -Events fertig ist, noch bevor die Ausgabe auf die Konsole und/oder das Erzeugen des Cache -Objektes abgeschlossen ist/sind. Das wiederum w\u00fcrde bedeuten, dass wir asynchron evtl. bereits fetch -Anfragen ausl\u00f6sen, noch bevor der Cache bereit ist. Um dieses Problem zu verhindern, betten wir die Erzeugung des Cache -Objektes in eine event.waitUntil() -Funktion ein. Erst wenn diese Funktion abgeschlossen ist, ist auch die Ereignisbehandlung des install -Events abgeschlossen (siehe auch hier ). Das richtige Vorgehen ist also dieses: 1 2 3 4 5 6 7 8 9 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); }) ); }) caches.open() erzeugt also ein Promise , dessen response der erzeugte Cache ist. Wir konsumieren diesen Cache und geben zun\u00e4chst nur eine Ausgabe auf der Konsole aus. Der Parameter 'static' in caches.open() ist ein Name f\u00fcr den Cache. Die Namen sind frei w\u00e4hlbar und man kann verschiedene Namen vergeben. Das sind dann jeweils eine Art \"Unter\"-Caches (oder sub caches ) im Service-Worker-Cache.","title":"Den Service-Worker-Cache erstellen"},{"location":"caching/#eine-ressource-in-den-cache-speichern","text":"Nun kann der Cache entsprechend mit request - response -Schl\u00fcssel-Werte-Paaren bef\u00fcllt werden. Die auf den Cache anwenbaren Funktionen sind hier dokumentiert. Es sind match(request, options) , matchAll(request, options) , add(request) , , addAll(request) , , put(request, response) , delete(request, options) und , keys(request, options) . Alle liefern nat\u00fcrlich ein Promise zur\u00fcck. Um die statischen Inhalte unserer Webanwendung in den Cache zu laden, verwenden wir die add(request) -Funktion. Diese Funktion macht folgendes: sie f\u00fchrt den request aus ( fetch(request) ) und speichert die response (also die angefragte Ressource) \u2192 dieses Speichern entspricht einem put(request, response) im Cache. Wenn wir also folgendes implementieren: 1 2 3 4 5 6 7 8 9 10 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . add ( '/src/js/app.js' ); // relativ vom public-Ordner }) ); }) , dann wird beim Initialisieren des service workers die Ressource public/src/js/app.js beim Webserver angefragt und die response , also die app.js im Cache gespeichert. Wenn wir unsere Anwednung so ausf\u00fchren, dann sehen wir in den DeveloperTools im Reiter Application im Cache Storage den Cache static und darin die gespeicherte Ressource /src/js/app.js .","title":"Eine Ressource in den Cache speichern"},{"location":"caching/#eine-ressource-aus-dem-cache-lesen","text":"Jetzt haben wir einen Ressource in den Cache geladen, aber wir verwenden sie noch nicht, da wir in der bisherigen Behandlung des fetch -Events den Cache noch nicht nutzen. Zur Erinnerung: bei der Behandlung des fetch -Events wirkt der service worker wie ein Proxy. Er \"schaltet\" sich zwischen die Webanwendung und die Anfrage dieser an den Webserver. In unserer derzeitigen Implementierung des fetch -Events wird der request einfach an den Webserver durchgeschleust, ohne irgendetwas damit zu tun. Das wollen wir nun \u00e4ndern: 1 2 3 4 5 6 7 8 9 10 11 12 self . addEventListener ( 'fetch' , event => { event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ); } }) ); }) Wir reagieren auf das fetch -Ereignis zun\u00e4chst mit der respondWith() -Funktion, die wir bereits oben besprochen haben. Diese Funktion verhindert die Ausf\u00fchrung des Standardverhaltens beim fetch , n\u00e4mlich die Anfrage an den Webserver. Stattdessen fragen wir mithilfe der caches.match() -Funktion alle sub caches unseres Caches nach dem als Parameter \u00fcbergebenen request an. Im Cache sind die Eintr\u00e4ge als Schl\u00fcssel-Werte-Paare request - response abgespeichert. Findet sich der request im Cache, dann liefert die Promise ein response -Objekt zur\u00fcck. Wenn das so ist (Zeile 5 ), dann geben wir dieses response -Objekt an die Webanwendung zur\u00fcck (Zeile 6 ). Das ist dann also die aus dem Cache geladene Ressource. Wenn die match() -Funktion jedoch den Schl\u00fcssel request nicht im Cache gefunden hat (und somit auch keine response ), gibt sie zwar trotzdem ein Promise zur\u00fcck, aber dann ist die response null . Das bedeutet, dass die if -Abfrage in Zeile 5 ein false zur\u00fcckgibt und wir somit Zeile 8 ausf\u00fchren. Darin wird die Anfrage einfach an den Webserver weitergeleitet, die Ressource also vom Webserver geladen. Wir \u00fcberpr\u00fcfen die Funktionalit\u00e4t dieser fetch -Ereignisbehandlung: Unter dem Reiter Network in den DeveloperTools sehen wir, dass die app.js durch den Service Worker geladen wurde. Alle anderen Ressourcen wurden auch durch den Service Worker geladen, das liegt daran, dass wir im Service Worker die Anfrage an den Webserver durch den Service Worker durchschleusen. Wichtig ist aber, dass die app.js nicht vom Webserver geladen wurde. Das erkennen war daran, dass alle anderen Ressourcen mit ihren Gr\u00f6\u00dfenangaben in der Tabelle stehen und dass damit gesagt, wurde, wieviel Bytes vom Webserver geladen wurden. Die app.js taucht dabei aber nicht auf. Sie wurde durch den Service Worker aus dem Service-Worker-Cache ( Cache Storage ) geladen! Okay, das ist jetzt vielleicht noch nicht besonders eindrucksvoll, weil der Offline-Modus f\u00fcr unsere Webanwendung noch nicht funktioniert und wir bis jetzt nur die app.js in den Cache speichern und von dort bei einem fetch() laden. Dadurch sieht man noch nicht wirklich viel. Deshalb laden wir jetzt den statischen \"Rest\", insbesondere die index.html und die dazugeh\u00f6rigen *.css -Dateien. Zuvor jedoch noch eine kurze Anmerkung zu den Schl\u00fcssel-Werte-Paaren request und response im Cache:","title":"Eine Ressource aus dem Cache lesen"},{"location":"caching/#schlussel-werte-paare-request-und-response","text":"Wir laden jetzt unsere index.html -Datei in den Cache: 1 2 3 4 5 6 7 8 9 10 11 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . add ( '/index.html' ); cache . add ( '/src/js/app.js' ); // relativ vom public-Ordner }) ); }) Wenn wir unsere Anwendung neu starten und den service worker erneut registrieren, dann sollte jetzt die index.html im Offline-Modus angezeigt werden (wenn auch ohne die CSS-Styles). Allerdings sieht die Anwendung nach dem Reload im Offline-Modus leider so aus wie auf der linken Seite der folgenden Abbildung gezeigt: Der Grund daf\u00fcr ist, dass wir die Anwendung mit localhost:8080 (oder 127.0.0.1:8080 ) aufrufen, der request also / ist. Im Cache gespeichert haben wir aber den request /index.html . Und tats\u00e4chlich, wenn wir localhost:8080/index.html (oder 127.0.0.1:8080/index.html ) aufrufen, dann wird der request /index.html im Cache gefunden und als response die index.html zur\u00fcckgegeben (rechte Seite in der Abbildung). Wichtig ist also, dass wir bedenken, dass alle requests , f\u00fcr die wir responses im Cache hinterlegen wollen, auch tats\u00e4chlich in den Cache hinzugef\u00fcgt werden. Unsere sw.js sollte also auch so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . add ( '/' ); cache . add ( '/index.html' ); cache . add ( '/src/js/app.js' ); // relativ vom public-Ordner }) ); }) Dann erhalten wir auch das rechte Bild der Abbildung beim Aufruf von localhost:8080 (oder 127.0.0.1:8080 ) im Offline-Modus. Wir sollten also beachten, dass alle requests , die wir cachen wollen, auch tats\u00e4chlich in den Cache gespeichert werden.","title":"Schl\u00fcssel-Werte-Paare request und response"},{"location":"caching/#alle-statischen-ressourcen-in-den-cache-laden","text":"Wir laden jetzt alle statischen Ressourcen in den Cache, d.h. alles, was notwendig ist, um unsere Webanwendung auch im Offline-Modus so aussehen zu lassen, als w\u00fcrde sie \"laufen\". Dazu geh\u00f6rt nat\u00fcrlich die index.html und dann noch alle Ressourcen, die in der index.html eingebunden werden, also einige *.js -Dateien, einige *.css -Dateien und das Bild, das oben in der Webanwendung erscheint. Man k\u00f6nnte das alles mit einzelnen cache.add() -Funktionen erledigen, so wie oben. Daf\u00fcr gibt es aber auch die cache.addAll() -Funktion, der ein Array aus lauter requests \u00fcbergeben wird. Die Implementierung der install -Ereignisbehandlung in unserer sw.js sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . addAll ([ '/' , '/index.html' , '/src/js/app.js' , '/src/js/feed.js' , '/src/js/material.min.js' , '/src/css/app.css' , '/src/css/feed.css' , '/src/images/htw.jpg' , 'https://fonts.googleapis.com/css?family=Roboto:400,700' , 'https://fonts.googleapis.com/icon?family=Material+Icons' , 'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css' ]); }) ); }) Wenn wir nun unsere Anwendung neu starten und darauf achten, dass der neue Service Worker auch wirklich registriert wird und dann in den Offline-Modus schalten, dann sieht unsere Anwendung so aus: Wie auf der rechten Seite der Abbildung zu sehen ist, funktioniert auch das JavaScript, um zum Formular zu gelangen. Einige Sachen funktionieren im Offline-Modus nicht, weil wir sie nicht in den Cache geladen haben: die Hilfeseite ( /help/index.html und die dazugeh\u00f6rige help.css ) sowie den Blogeintrag, den wir bereits (statisch) vorgenommen haben (den binden wir gleich noch dynamisch ein). Eine andere Sache f\u00e4llt aber vielleicht auf: die Icons von Material Design Lite erscheinen nicht, d.h. das Men\u00fc links oben ist nur ein leeres Quadrat und auf dem roten runden Button fehlt das Plus, stattdessen steht dort add . Wenn wir diesem Problem nachgehen, dann sehen wir in den DeveloperTools unter dem Reiter Network , dass alle Ressourcen, die wir im Cache gespeichert haben, auch tats\u00e4chlich aus diesem Cache geladen werden: Zus\u00e4tzlich schlagen aber noch \"kryptische\" GET-Anfragen fehl (die roten ganz unten in der Abbildung). Hier werden offensichtlich noch Anfragen an den Webserver gestellt, von denen wir gar nichts wussten und die wir nicht im Cache vorhalten. Wo kommen diese Anfragen her? Wenn wir dort in den DeveloperTools bspw. auf die Ressource https://fonts.googleapis.com/icon?family=Material+Icons klicken, dann erscheint daneben der Inhalt der geladenen Ressource und wir finden darin einen weiteren request , den wir aber nicht in unserem Cache hinterlegt haben (weil wir es gar nicht wussten): Diese Anfragen schlagen im Offline-Modus (nat\u00fcrlich) fehl und deshalb fehlen uns die Material Design Icons. Gut w\u00e4re es, wenn solche dynamischen Anfragen ebenfalls im Cache landen w\u00fcrden. Mit diesem dynamischen Caching besch\u00e4ftigen wir uns deshalb jetzt:","title":"Alle statischen Ressourcen in den Cache laden"},{"location":"caching/#dynamisches-caching","text":"Bis jetzt haben wir mit cache.add() bzw. cache.addAll() vorab festgelegt, was in den Cache geladen werden soll. Das wird statisches Caching oder pre-caching genannt. Jetzt k\u00fcmmern wir uns um sogenanntes dynamisches Caching . Manchmal m\u00f6chte man gar nicht schon gleich zu Beginn alles in den Cache laden, um die \"Installation\", das erstmalige Aufrufen der Seite nicht zu aufw\u00e4ndig und somit zu langsam zu gestalten. Manchmal kennt man aber auch gar nicht die Ressourcen, die man noch zum Cache hinzuf\u00fcgen m\u00f6chte, wie das obere Beispiel gezeigt hat, als wir die Material Icons nicht in den Cache geladen haben, weil wir diese Anfrage vorab gar nicht kannten.","title":"Dynamisches Caching"},{"location":"caching/#die-behandlung-des-fetch-events-erweitern","text":"Wir schauen uns zun\u00e4chst nochmal die aktuelle Behandlung des fetch -Events im service worker an: 1 2 3 4 5 6 7 8 9 10 11 12 self . addEventListener ( 'fetch' , event => { event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ); } }) ); }) Zur Erinnerung: mit dieser behandlung schalten wir uns zwischen die Abfrage der Webseite an den Webserver. Diese Behandlung wirkt wie ein Proxy. Bei jeder Anfrage der Webseite an den Webserver wird diese Implementierung des fetch -Events aufgerufen. Wir erwidern den request mit einer response . Entweder kommt diese response aus dem Cache, n\u00e4mlich dann, wenn caches.match(event.request) eine response zur\u00fcckgibt. In diesem Fall wird die response zur\u00fcck an die Webseite geschickt und der Webserver wird gar nicht mehr weiter angefragt. Oder wir leiten die Anfrage tats\u00e4chlich an den Webserver weiter ( return fetch(event.request); ), n\u00e4mlich dann, wenn der event.request nicht als Schl\u00fcssel im Cache verf\u00fcgbar ist und dieser deshalb keine response zur\u00fcckgibt. An dieser Stelle f\u00fcgen wir nun unser dynamisches Caching ein. Der Webserver wird mit einer response antworten und wir werden diese response in unseren Cache laden. Dazu ben\u00f6tigen wir zwei Dinge: einen neuen, weiteren Cache, in dem wir den entsprechenden request und die response des Webservers speichern und die cache.put() -Anweisung. put() unterscheidet sich von add() dahingehend, dass add() nur einen Parameter ben\u00f6tigt, n\u00e4mlich den request und die response automatisch als ein Schl\u00fcssel-Werte-Paar ( request, response ) speichert, w\u00e4hrend put() beide Werte als Schl\u00fcssel-Werte-Paar speichert, d.h. zwei Parameter erwartet ( request , response ). Ein erster Implementierungsversuch sieht so aus: 7 8 9 10 11 12 13 14 15 } else { return fetch ( event . request ) . then ( res => { // nicht erneut response nehmen, haben wir schon caches . open ( 'dynamic' ) // neuer, weiterer Cache namens dynamic . then ( cache => { cache . put ( event . request . url , res ); // hier die put-Anweisung }) }); } Die Zeilen 9-14 sind hinzugekommen. Die fetch() -Anweisung ist ein Promise , deshalb f\u00fcgen wir ein .then() an. Die response m\u00fcssen wir jetzt anders nennen, da es die Variable response ja bereits gibt und es jetzt um die response des Webservers geht, also nennen wir sie res (kann nat\u00fcrlich auch anders hei\u00dfen). Dann \u00f6ffnen wir einen neuen Cache, den wir dynamic nennen - kann auch anders hei\u00dfen. Wenn der Cache noch nicht existiert, wird er durch open() erstellt. open() ist wiederum ein Promise, so dass wir .then() ankn\u00fcpfen k\u00f6nnen und f\u00fcgen in den Cache mithilfe von put() das Schl\u00fcssel-Werte-Paar ( event.request.url, res ) ein. Das w\u00e4re schon fast korrekt, aber es fehlt noch, dass wir die Response res nat\u00fcrlich an die Webseite zur\u00fcckgeben wollen. Dazu f\u00fcgen wir einerseits return res; ein, m\u00fcssen aber auch daf\u00fcr sorgen, dass die res auch an den fetch() -Aufruf zur\u00fcckgegeben wird. Dehalb ben\u00f6tigen wir auch vor caches.open() noch ein return . Au\u00dferdem m\u00fcssen wir noch einen weiteren Aspekt beachten. Wenn eine Response verwendet wird, wird sie konsumiert , d.h. verbraucht. Das ist so f\u00fcr Responses, auch wenn es nicht so wirklich nachvollziehbar und verst\u00e4ndlich ist. Wir verwenden in unserem Code zwei Mal res , einmal um es in den Cache zu speichern und ein anderes Mal, um es an die Webseite zur\u00fcckzugeben. In einer der beiden Verwendungen w\u00fcrde unsere res verbraucht/konsumiert werden und das andere Mal w\u00e4re sie leer. Kein Ahnung, warum das so ist ;-) . Aber wir ben\u00f6tigen an einer der beiden Stellen ein res.clone() , um den Clone der Response zu verwenden und die Response nicht zu \"verbrauchen\". Wir speichern den Clone der Response in den Cache (wir k\u00f6nnten auch die res in den Cache speichern und res.clone() zur\u00fcckgeben). Die gesamte Implementierung sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 self . addEventListener ( 'fetch' , event => { event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ) . then ( res => { // nicht erneut response nehmen, haben wir schon return caches . open ( 'dynamic' ) // neuer, weiterer Cache namens dynamic . then ( cache => { cache . put ( event . request . url , res . clone ()); return res ; }) }); } }) ); }) Wenn wir nun die Anwendung ausf\u00fchren ( npm start ), dann in den Offline -Modus gehen und ein Reload im Browser durchf\u00fchren, sehen wir, dass die Material-Icons nun auch im Offline-Modus vorhanden sind: Wenn wir uns in den DeveloperTools unter Application auf der linken Seite unter Cache den Cache Storage anschauen, dann sehen wir, dass dort nun 2 Caches sind, der static und der dynamic Cache. In dem dynmic Cache finden wir nun auch die Material Icons wieder und unter dem Network -Reiter gibt es auch keine \"Fehler\" mehr, sondern alle Ressourcen werden vom Service Worker aus dem Cache geladen: Als weiteres Zeichen, dass nun alle Inhalte dynamisch geladen werden, erkennen wir auch die \"Mensa-Card\" in unserer Anwendung im Offline-Modus. Diese hatten wir ja statisch nicht hinzugef\u00fcgt. Probieren Sie auch einmal die \"Hilfe-Seite\" der Anwendung aus. Im Offline-Modus ist sie noch nicht verf\u00fcgbar. Wenn wir aber wieder online gehen, die \"Hilfe-Seite\" aufrufen und dann wieder offline gehen, ist die Hilfe-Seite im Cache und wird angezeigt.","title":"Die Behandlung des fetch-Events erweitern"},{"location":"caching/#chromewebrequest-api","text":"Der Chromium-Browser hat eine eigene API f\u00fcr Requests und schaltet sich bei Anfragen selbst dazwischen, um den Traffic zu analysieren und eventuelle Anfragen zu blockieren. Auch diese Anfragen l\u00f6sen ein fetch -Event aus. Allerdings gibt es bei von Chromium ausgel\u00f6sten Requests in dem request keine url -Eigenschaft. Vielleicht haben Sie einen solchen Fehler auch in Ihren DeveloperTools entdeckt. Eine Chromium-Anfrage unterscheidet sich von einer \"normalen\" Anfrage der Webseite an den Webserver dadurch, dass in einer \"normalen\" Anfrage die angefragte Ressource unter \" htttp://... \", also unter einer URL verf\u00fcgbar ist. Um nun den fehlerhaften Zugriff auf die url -Eigenschaft von request bei einer Anfrage durch Chrome zu vermeiden, f\u00fcgen wir ganz am Anfang der Ereignisbehandlung des fetch -Events noch die Abfrage ein, ob der request das Wort \" http \" enth\u00e4lt. Wenn nicht, verlassen wir die Behandlung des Events einfach: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 self . addEventListener ( 'fetch' , event => { // check if request is made by chrome extensions or web page // if request is made for web page url must contains http. if ( ! ( event . request . url . indexOf ( 'http' ) === 0 )) return ; // skip the request if request is not made with http protocol event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ) . then ( res => { // nicht erneut response nehmen, haben wir schon return caches . open ( 'dynamic' ) // neuer, weiterer Cache namens dynamic . then ( cache => { cache . put ( event . request . url , res . clone ()); return res ; }) }); } }) ); })","title":"chrome.webRequest-API"},{"location":"caching/#versionierung-von-caches","text":"Wir haben nun sowohl statisch als auch dynamisch Ressourcen unserer Webanwendung geladen. Wenn wir eine Weile auf unserer Anwendung navigieren, laden wir nach und nach alle Ressourcen in den Cache, die unsere Anwendung ausmachen. Irgendwann k\u00f6nnen wir sie komplett offline betreiben. Alle Ressourcen sind im Cache und keine Ressourcen werden mehr vom Webserver geladen. Was passiert aber, wenn wir etwas \u00e4ndern? Wenn wir den Service worker sw.js \u00e4ndern, dann k\u00f6nnen wir daf\u00fcr sorgen, dass er neu geladen wird. Der Service worker darf auch niemals in den Cache geladen werden, denn dann h\u00e4tten wir eine unendliche Schleife, die immer wieder Ressourcen in den Cache l\u00e4dt! Wenn wir irgendeine andere Datei, eine *.html -, *.css - oder *.js -Datei \u00e4ndern, dann wird diese nie mehr in ihrer aktuellen Version vom Webserver geladen, da sie ja bereits im Cache ist und deshalb immer (in ihrer alten Version) aus dem Cache geladen wird. Um dieses problem zu beheben, versionieren wir unsere Caches.","title":"Versionierung von Caches"},{"location":"caching/#neue-cache-versionen-erstellen","text":"Eine neue \"Version\" eines Caches erstellen wir dadurch, dass wir einen neuen Cache mit anderem Namen erstellen. Unsere beiden Caches (der statische und der dynamische) werden jeweils im Service Worker ( sw.js ) benannt: aktueller Stand sw.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( 'static' ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . addAll ([ '/' , '/index.html' , '/src/js/app.js' , '/src/js/feed.js' , '/src/js/material.min.js' , '/src/css/app.css' , '/src/css/feed.css' , '/src/images/htw.jpg' , 'https://fonts.googleapis.com/css?family=Roboto:400,700' , 'https://fonts.googleapis.com/icon?family=Material+Icons' , 'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css' ]); }) ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) self . addEventListener ( 'fetch' , event => { // check if request is made by chrome extensions or web page // if request is made for web page url must contains http. if ( ! ( event . request . url . indexOf ( 'http' ) === 0 )) return ; // skip the request. if request is not made with http protocol event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ) . then ( res => { // nicht erneut response nehmen, haben wir schon return caches . open ( 'dynamic' ) // neuer, weiterer Cache namens dynamic . then ( cache => { cache . put ( event . request . url , res . clone ()); return res ; }) }); } }) ); }) Mit wechselndem Namen wechseln wir auch die \"Version\" des Caches. Wenn wir die Implementierung des statischen Service Workers (mit dem dynamischen ist es gleich, wir zeigen es hier zun\u00e4chst nur f\u00fcr den statischen) in der Zeile 4 bespielsweise auf caches . open ( 'static-v1' ) \u00e4ndern, ensteht ein neuer zus\u00e4tzlicher Caches static-v1 . Mit solchen \"Versionierungen\" erreichen wir, dass der Service Worker neu ausgef\u00fchrt und somit wirksam wird. Ge\u00e4nderte Dateien gelangen so neu in diesen neuen Caches. Leider bleiben aber auch die alten Caches noch bestehen und die Funktion caches.match() sucht in allen Caches nach dem passenden Request. Die \u00c4nderungen w\u00e4ren dann also trotzdem noch nicht sichtbar. Wir m\u00fcssen jetzt noch daf\u00fcr sorgen, dass die \"alten\" Caches gel\u00f6scht werden. Um uns zu \u00fcberlegen, an welcher Stelle ein geeigneter Platz w\u00e4re, die alten Caches zu l\u00f6schen, hier nochmal eine kurze Wiederholung des Service-Worker-Lifecycles : install : Das install -Ereignis ist das erste Ereignis, das ein Service Worker ausl\u00f6st. Es wird genau einmal ausgel\u00f6st. Die Promise in installEvent.waitUntil() gibt Auskunft dar\u00fcber, ob das Installieren des Service Workers erfolgreich war oder nicht. So lange der Service Worker installiert wird, kann er keine fetch -Ereignisse empfangen und behandeln. activate : Sobald die Installation erfolgreich abgeschlossen ist, wird das activate -Ereignis ausgel\u00f6st. waiting : Wenn ein Service Worker activated ist, d.h. das activate -Event f\u00fcr diesen Service Worker ausgel\u00f6st wurde, kontrolliert er die Anfragen der Webseite (insb. wenn clients.claim() ausgef\u00fchrt wurde, was dazu f\u00fchrt, dass auch alle Unterseiten der Seite \"kontrolliert\" werden). Wird der Service Worker ge\u00e4ndert (aktualisiert) und erneut installiert, kann der ge\u00e4nderte Service Worker nicht sofort in den activated Zustand \u00fcbergehen, so lange ein anderer Service Worker active ist. Der aktualisierte Service Worker ist dann waiting . Das Bild zeigt einen aktualisierten Service Worker ( #877 ) waiting solange der Service Worker #875 noch activated ist. Erst, wenn skipWaiting geklickt wird ( self.skipWaiting() ), wird der aktualisierte Service Worker activated . Ein guter Punkt, existierende Caches zu l\u00f6schen, die man nicht mehr verwenden m\u00f6chte, ist, wenn ein (neuer/aktualisierter) Service Worker activated ist. Wir erweitern also die behandlung des activate -Ereignisses: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); event . waitUntil ( caches . keys () . then ( keyList => { return Promise . all ( keyList . map ( key => { if ( key !== 'static-v1' && key !== 'dynamic' ) { console . log ( 'service worker --> old cache removed :' , key ); return caches . delete ( key ); } })) }) ); return self . clients . claim (); }) Die ersten beiden und die letzten beiden Zeilen hatten wir bereits. Zeilen 3-13 sind neu. Betrachten wir den Code genauer: Die Funktion waitUntil() (Zeile 4 ) gibt es sowohl f\u00fcr das install -Event als auch f\u00fcr das activate -Ereignis. Dieser Funktion wird ein Promise \u00fcbergeben. Wir \u00fcbergeben als Promise die Funktion caches.keys() (Zeile 5 ). caches.keys gibt alle Namen der Service-Worker-Caches als Schl\u00fcssel zur\u00fcck. In unserem Fall also static , static-v1 und dynamic . die Funktion Promise.all() wird, verwendet, wenn auf ein Array von Promises \"gewartet\" werden soll. Die Funktion ist also dann beendet, wenn alle Promises des Arrays beendet sind. Promise.all() wartet auf ein Array von Promises. Wir haben aber mit keyList \"nur\" ein Array von Strings (die Namen der Caches). Mithilfe der map() -Funktion wandeln wir dieses Array von Strings in ein Array von Promises um. die map -Funktion nimmt nun jeden einzelnen String aus dem Array keyList und \"macht\" damit etwas (Zeilen 7-10 ) es wird gepr\u00fcft, ob der key entweder dem dynamischen Cache entspricht ( 'dynamic' ) oder dem neuen statischen Cache ( 'static-v1' ). Wenn das nicht der Fall ist, dann wird der Cache mit dem Namen key gel\u00f6scht (Zeile 9 ). return caches.delete(key) gibt somit ein Promise zur\u00fcck (an die map -Funktion). Somit wird jeder Schl\u00fcssel aus der keyList in ein Promise umgewandelt (f\u00fcr static-v1 und dynamic wird null zur\u00fcckgegeben). wenn alle dieses Promises beendet sind, ist auch die Promise.all() -Funktion beendet und somit auch die event.waitUntil() -Funktion. Somit l\u00f6schen wir alle \"alten\" statischen Caches und behalten nur die Caches static-v1 und dynamic . Wenn wir also etwas in unseren *.html , *.css und/oder *.js -Dateien \u00e4ndern und das Ge\u00e4nderte wirksam werden lassen wollen, \u00e4ndern wir einfach die Namen der Caches im Service Worker und sobald der Service Worker aktiviert ist, existieren nur noch die neuen Caches und die alten sind gel\u00f6scht. Damit wir das an zentraler Stelle im sw.js machen, lagern wir die aktuellen Namen der Caches in Konstanten aus. Die vollst\u00e4ndige Implementierung unseres Service Workers sieht so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 const CURRENT_STATIC_CACHE = 'static-v2' ; const CURRENT_DYNAMIC_CACHE = 'dynamic-v2' ; self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); event . waitUntil ( caches . open ( CURRENT_STATIC_CACHE ) . then ( cache => { console . log ( 'Service-Worker-Cache erzeugt und offen' ); cache . addAll ([ '/' , '/index.html' , '/src/js/app.js' , '/src/js/feed.js' , '/src/js/material.min.js' , '/src/css/app.css' , '/src/css/feed.css' , '/src/images/htw.jpg' , 'https://fonts.googleapis.com/css?family=Roboto:400,700' , 'https://fonts.googleapis.com/icon?family=Material+Icons' , 'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css' ]); }) ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); event . waitUntil ( caches . keys () . then ( keyList => { return Promise . all ( keyList . map ( key => { if ( key !== CURRENT_STATIC_CACHE && key !== CURRENT_DYNAMIC_CACHE ) { console . log ( 'service worker --> old cache removed :' , key ); return caches . delete ( key ); } })) }) ); return self . clients . claim (); }) self . addEventListener ( 'fetch' , event => { // check if request is made by chrome extensions or web page // if request is made for web page url must contains http. if ( ! ( event . request . url . indexOf ( 'http' ) === 0 )) return ; // skip the request. if request is not made with http protocol event . respondWith ( caches . match ( event . request ) . then ( response => { if ( response ) { return response ; } else { return fetch ( event . request ) . then ( res => { // nicht erneut response nehmen, haben wir schon return caches . open ( CURRENT_DYNAMIC_CACHE ) // neuer, weiterer Cache namens dynamic . then ( cache => { cache . put ( event . request . url , res . clone ()); return res ; }) }); } }) ); })","title":"Neue Cache-Versionen erstellen"},{"location":"caching/#zusammenfassung","text":"Die Zusammanfassung f\u00fcr das Caching kann man im folgenden Bild darstellen. Mithilfe des Caching haben wir es geschafft, dass unsere Anwendung im Offline-Modus nicht mehr so aussieht, wie links, sondern wie rechts. Toll! Noch einige n\u00fctzliche Links: Service Worker API The offline cookbook Google: Service Worker","title":"Zusammenfassung"},{"location":"einfuehrung/","text":"Einf\u00fchrung \u00b6 In diesem Semester geht es um Progressive Web Apps (PWA) . PWA sind Funktionen, die wir Webanwendungen hinzuf\u00fcgen k\u00f6nnen, um sie in ihrer Funktionalit\u00e4t zu erweitern. Die so werweiterten Webanwendungen kommen mit solchen Funktionen nativen Apps immer n\u00e4her, d.h. das Look and Feel gleicht sich mit PWAs nativen Apps an. Dazu geh\u00f6ren Funktionalit\u00e4ten, wie z.B. die M\u00f6glichkeit, die Webanwendung auch offline zu verwenden, die Kamera zu nutzen, den eigenen Standort zu verwenden, Daten im Hintergrund zu synchronisieren. Das bedeutet aber nicht automatisch, dass wir ausschlie\u00dflich auf moderne Browser angewiesen sind, die diese Funktionalit\u00e4ten von PWAs unterst\u00fctzen. Die Webanwendungen sollen auch weiterhin auf alten Webbrowsern laufen, dann jedoch eventuell ohne einige oder alle PWA-Funktionalit\u00e4ten. Progressive Web Apps m\u00fcssen zuverl\u00e4ssig ( reliable ) sein, d.h. sie m\u00fcssen schnelle Ladezeiten aufweisen und sogar (teilweise) offline funktionieren, schnell sein, d.h. schnell auf Nutzerinteraktionen reagieren, motivierend sein, die Webanwendung zu verwenden, d.h. einerseits intuitiv bedienbar und anderseits, z.B. \u00fcber Push-Notifikationen, die Nutzerinnen animieren, die App zu nutzen. Die prinzipielle Idee einer Progressive Web App l\u00e4sst sich vereinfacht durch die folgenden Abbildung veranschaulichen: Eine Progressive Web App ist eine Webanwendung, die sich wie eine native mobile App verh\u00e4lt. Webanwendungen vs. native Apps \u00b6 Die meisten Nutzerinnen verwenden die meiste Zeit native Apps auf ihrem Smartphone. Nur zu einem geringen Prozentsatz werden Web-Anwendungen (also der Browser) auf dem Smartphone verwendet. Das spricht eigentlich eher daf\u00fcr, dass wir uns mit der Entwicklung nativer Apps besch\u00e4ftigen sollten, als mit der Entwicklung von (mobilen) Webanwendungen. Die vorrangige Verwendung nativer Apps hat mehrere Gr\u00fcnde: Push-Notifikationen : Native Apps laufen im Hintergrund und die Nutzerinnen werden \u00fcber Push-Notifikationen informiert, wenn etwas Neues passiert ist, z.B. neue Nachrichten , E-Mails, etc. Man muss also gar nicht aktiv die native App bedienen, um \u00fcber Aktuelles informiert zu werden. App-Icons auf dem Home-Bildschirm : erm\u00f6glichen einen schnellen, direkten Zugang zu den Apps. Ger\u00e4tefunktionen : wie z.B. Standortermittlung, Kameras und Mikrofine k\u00f6nnen leicht in native Apps eingebaut werden. F\u00fcr Webanwendungen ist dies nur aufw\u00e4ndig m\u00f6glich. Offline-Funktionalit\u00e4ten : viele native Apps k\u00f6nnen auch offline ganz oder teilweise verwendet werden, z.B. Spiele oder Musikapps, die heruntergeladene Musik abspielen. App-Icons auf dem Home-Bildschirm k\u00f6nnen wir auch f\u00fcr Links auf unsere Webanwendung erstellen und die anderen drei Argumente wollen wir ja genau mit Progressive Web Apps zunichte machen. Das hei\u00dft, mit Progressive Web Apps kommen die Vorteile nativer Apps im Vergleich zu Webanwendungen nicht mehr zum Tragen. Demgegen\u00fcber stahen zwei Gr\u00fcnde, warum Webanwendungen besser sind als native Apps: Native Apps m\u00fcssen sowohl f\u00fcr iOS als auch f\u00fcr Android erstellt werden, um eine m\u00f6glichst gro\u00dfe Nutzerinnenzahl anzusprechen. Dazu m\u00fcssen auch unterschiedliche programmiersprachen verwendet werden (Swift f\u00fcr iOS und Java/Kotlin f\u00fcr Android). Zwar versuchen Hybride Tools diesen Nachteil zu umgehen, aber es gelingt nicht wirklich. Es werden so gut wie nie neue native Apps auf Smartphones geladen. Umfragen ergeben, dass Nutzerinnen die allermeiste Zeit am Smartphone mit h\u00f6chstens drei Apps verbringen. Alle weiteren Apps werden am Anfang der Nutzung installiert. Es kommen im Laufe eines \"Smartphone-Lebens\" kaum welche hinzu. Die durchschnittliche Anzahl neuhinzugef\u00fcgter Apps im Monat liegt bei nahe 0. Die Verwendung von Webanwendungen ist deutlich einfacher. Man muss nichts installieren. Man googlet einfach und \u00f6ffnet dann die Seite. Die Bandbreite aller Webanwendungen ist deutlich schneller erreichbar als eine gro\u00dfe Anzahl an nativen Apps. Die Reichweite einer Webanwendung ist deutlich gr\u00f6\u00dfer als die Reichweite einer nativen App. Funktionalit\u00e4ten Nutzerinnen-Reichweite native App Zugriff auf Ger\u00e4tefunktionalit\u00e4ten nur sehr wenige Apps werden von sehr vielen Nutzerinnen die meiste Zeit verwendet herk\u00f6mmliche Webanwendungen sehr eingeschr\u00e4nkter (gar kein) Zugriff auf Ger\u00e4tefunktionalit\u00e4ten hohe Reichweite, sehr einfacher Zugang progressive Webanwendungen Zugriff auf Ger\u00e4tefunktionalit\u00e4ten hohe Reichweite, sehr einfacher Zugang Links und Videos \u00b6 Hier zwei kurze Einf\u00fchrungsvideos zu PWAs: Progressive Web Apps in 100 Seconds Progressive Web Apps - PWA Roadshow Hier einige intressante Links zu PWAs: Learn PWA Progressive Web-Apps: Was versprechen die progressiven Apps? Online Verzeichnis PWAs PWAs vs. SPAs \u00b6 Wir haben noch immer nicht unsere erste Progressive Web App erstellt ;-(. Bevor wir das tun, diskutieren wie zun\u00e4chst noch die Unterschiede zwischen einer Progressive Web App und einer Single Page Application , wie wir sie im WebTech-Kurs erstellt haben. Single Page Applications (SPAs) sind Webanwendungen, die mit JavaScript erstellt werden, typischerweise mit einem JavaScript-Framewaork, wie Angular , React oder Vue.js . In SPAs wird das DOM st\u00e4ndig neu gerendert, welches sich durch Nutzereingaben oder Lifecycle-Events \u00e4ndert. Das Grundger\u00fcst einer SPA besteht aus genau einer HTML -Seite (typischerweise index.html ), in die verschiedene Komponenten eingebunden wird. Eine Single Page Application ist vornehmlich hoch reaktiv auf Nutzereingaben, im Sinne von schneller Reaktion. Progressive Web Applications (PWAs) sind eine Sammlung verschiedener Technologien. Es ist v\u00f6llig egal, ob diese Technologien in eine Single Page Application eingebunden werden oder in eine \"herk\u00f6mmliche\" (Multi-Page-) Webanwendung. Die Idee einer PWA ist, dass sie hoch reaktiv im Sinne st\u00e4ndiger Verf\u00fcgbarkeit ist. JavaScript spielt bei PWAs nicht die dominate Rolle, wie bei SPAs. Sie k\u00f6nnen eine oder mehrere progressive Funktionalit\u00e4ten existierender Webanwendungen hinzuf\u00fcgen (service worker, caching, push notifivcations, ...) oder eine PWA von Grund auf neu implementieren. Lighthouse \u00b6 Lighthouse ist ein Plugin f\u00fcr die Developertools von Chrome, mit dessen Hilfe gemessen werden kann, wie progressive eine Webanwendung ist. Die folgende Abbildung zeigt den Einsatz von Lighthouse f\u00fcr die PWA https://2048.love2dev.com/ - ein Spiel, das Sie wahrscheinlich kennen. Wechseln Sie in den Developertools auf die mobile Ansicht. W\u00e4hlen Sie dann im Reiter Lighthouse die Analyse. Probieren Sie auch mal aus, die Anwendung im Offline-Modus zu verwenden. Wechseln Sie dazu in den Developertools auf den Reiter Network und dort in der Auswahlliste auf Offline . Selbst wenn Sie Disable Cache anklicken, werden Sie feststellen, dass sich das Spiel noch spielen l\u00e4sst. Viel Spa\u00df! ;-) PWA Checklist \u00b6 Im Lighthouse-Plugin finden Sie auch einen Link zur PWA Checklist . Diese Checklist wird verwendet, um zu beurteilen, wie progressive eine Webanwendung ist. Eine gute \u00dcbersicht finden Sie auch hier . Erstes kleines Beispiel \u00b6 Wir erstellen uns in einem Ordner eine index.html mit index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < link rel = \"shortcut icon\" href = \"favicon.ico\" type = \"image/x-icon\" /> <!-- muss nicht --> < title > IKT Start </ title > </ head > < body > < h1 > Willkommen zu den Aktuellen Trends der IKT </ h1 > < p > Wir besch\u00e4ftigen uns mit < i > Progressive Web Apps (PWA) </ i > . Ein wesentlicher Bestandteil von PWAs sind < i > Service Worker </ i > . </ p > </ body > </ html > Einen gro\u00dfen Teil unserer Untersuchungen in diesem Modul nehmen Web APIs ein. Wir werden einige von Ihnen n\u00e4her beleuchten. Das zentrale Konzept von PWAs sind ServiceWorker . Wir erstellen uns in unserem Ordner eine Datei service-worker.js und binden diese in unsere index.html ein: index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < link rel = \"shortcut icon\" href = \"favicon.ico\" type = \"image/x-icon\" /> <!-- muss nicht --> < title > IKT Start </ title > </ head > < body > < h1 > Willkommen zu den Aktuellen Trends der IKT </ h1 > < p > Wir besch\u00e4ftigen uns mit < i > Progressive Web Apps (PWA) </ i > . Ein wesentlicher Bestandteil von PWAs sind < i > Service Worker </ i > . </ p > < script > // Check that service workers are supported if ( 'serviceWorker' in navigator ) { // Use the window load event to keep the page load performant window . addEventListener ( 'load' , () => { navigator . serviceWorker . register ( '/service-worker.js' ); }); } </ script > </ body > </ html > In die service-worker.js schreiben wir zun\u00e4chst nur service-worker.js console . log ( 'service worker registriert' ); Wir starten die Anwendung (z.B. mit npx serve ) und schalten die Entwicklertools ein. Auf der Konsole erscheint service worker registriert . Wir wechseln nach Application --> Service Worker und sehen den aktiven service-worker.js . Wenn wir die Anwendung im Browser erneut laden, erscheint die Ausgabe nicht erneut. Wir \u00e4ndern den Service worker, z.B. auf console.log('neuer service worker registriert ) und laden die Anwendung erneut. Die Ausgabe erscheint. Wechseln sie erneut nach Application --> Service Worker . Der Service worker l\u00e4uft auch dann noch, wenn die Anwendung geschlossen ist! Installierbar \u00b6 Wenn wir unter Lighthouse einen Report generieren, dann sieht es zwar prinzipiell schon ganz gut aus, es handelt sich aber auch noch nicht um eine PWA, da sie (noch) nicht installierbar ist. Wir werden n\u00e4chste Woche damit beginnen, unsere App installierbar zu machen. Hier \"verraten\" wir aber bereits, dass wir dazu eine manifest.json ben\u00f6tigen. Diese erstellen wir und binden sie in die index.html ein: index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < link rel = \"shortcut icon\" href = \"favicon.ico\" type = \"image/x-icon\" /> <!-- muss nicht --> < link rel = \"manifest\" href = \"manifest.json\" > < title > IKT Start </ title > </ head > < body > < h1 > Willkommen zu den Aktuellen Trends der IKT </ h1 > < p > Wir besch\u00e4ftigen uns mit < i > Progressive Web Apps (PWA) </ i > . Ein wesentlicher Bestandteil von PWAs sind < i > Service Worker </ i > . </ p > < script > // Check that service workers are supported if ( 'serviceWorker' in navigator ) { // Use the window load event to keep the page load performant window . addEventListener ( 'load' , () => { navigator . serviceWorker . register ( '/service-worker.js' ); }); } </ script > </ body > </ html > In die manifest.json tragen wir ein: manifest.json 1 2 3 4 5 6 7 8 9 10 { \"name\" : \"IKT-PWA\" , \"start_url\" : \"/\" , \"id\" : \"/\" , \"icons\" : [], \"theme_color\" : \"#000000\" , \"background_color\" : \"#FFFFFF\" , \"display\" : \"fullscreen\" , \"orientation\" : \"portrait\" } Wir kommen zu den einzelnen Eigenschaften n\u00e4chste Woche noch ausf\u00fchrlich. Die manifest.json ist jedoch noch nicht vollst\u00e4ndig, da das icons -Array noch bef\u00fcllt werden muss. In dieses Array tragen wir alle Bilder ein, die als Icons auf dem Startbildschirm verwendet werden sollen, je nach Aufl\u00f6sung des Ger\u00e4tes, auf dem die Anwendung gestartet werden soll. Die Generierung dieser Icons wird uns zum Gl\u00fcck abgenommen. Wir erstellen die Icons auf Basis eines Icons, das in recht gro\u00dfer Aufl\u00f6sung vorliegt. F\u00fcgen Sie dazu das fiwlogo in Ihren Projektordner ein. Wir nutzen den pwa-asset-generator . Im Terminal geben wir in unserem Projektordner ein: npx pwa-asset-generator fiwlogo.png icons Dabei ist fiwlogo.png das Icon, auf dessen Basis alle weiteren Icons erzeugt werden sollen und diese sollen in den Ordner icons erstellt werden. Die Ausgabe ist ungef\u00e4hr wie folgt: 11:49:08 getSplashScreenMetaData Initialising puppeteer to load latest splash screen metadata \ud83e\udd16 11:49:08 getAppleSplashScreenData Navigating to Apple Human Interface Guidelines website - https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/adaptivity-and-layout/ 11:49:10 getAppleSplashScreenData Waiting for the data table to be loaded 11:49:10 getAppleSplashScreenData Retrieved splash screen data 11:49:10 getSplashScreenMetaData Loaded metadata for iOS platform \ud83d\ude4c 11:49:11 generateImages Looks like folder icons doesn't exist. Created one for you \ud83e\udd14 11:49:11 saveImages Initialising puppeteer to take screenshots \ud83e\udd16 11:49:11 getShellHtml Generating shell html with provided image source 11:49:11 getShellHtml Providing shell html as page content 11:49:12 saveImages Saved image apple-splash-2388-1668 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2732-2048 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-1536-2048 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2048-1536 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-1668-2388 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2048-2732 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-1668-2224 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2224-1668 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-1620-2160 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2436-1125 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-1242-2688 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2532-1170 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2160-1620 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1125-2436 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1284-2778 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1242-2208 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1792-828 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1170-2532 \ud83d\ude4c 11:49:13 saveImages Saved image manifest-icon-192 \ud83d\ude4c 11:49:13 saveImages Saved image manifest-icon-512 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-2778-1284 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-2208-1242 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1136-640 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-2688-1242 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-750-1334 \ud83d\ude4c 11:49:13 saveImages Saved image apple-icon-180 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-640-1136 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1334-750 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-828-1792 \ud83d\ude4c 11:49:13 cli Web App Manifest file is not specified, printing out the content to console instead \ud83e\udd14 11:49:13 cli Below is the icons content for your manifest.json file. You can copy/paste it manually \ud83d\ude4c [ { \"src\": \"icons/manifest-icon-192.maskable.png\", \"sizes\": \"192x192\", \"type\": \"image/png\", \"purpose\": \"any\" }, { \"src\": \"icons/manifest-icon-192.maskable.png\", \"sizes\": \"192x192\", \"type\": \"image/png\", \"purpose\": \"maskable\" }, { \"src\": \"icons/manifest-icon-512.maskable.png\", \"sizes\": \"512x512\", \"type\": \"image/png\", \"purpose\": \"any\" }, { \"src\": \"icons/manifest-icon-512.maskable.png\", \"sizes\": \"512x512\", \"type\": \"image/png\", \"purpose\": \"maskable\" } ] 11:49:13 cli Index html file is not specified, printing out the content to console instead \ud83e\udd14 11:49:13 cli Below is the iOS meta tags content for your index.html file. You can copy/paste it manually \ud83d\ude4c <link rel=\"apple-touch-icon\" href=\"icons/apple-icon-180.png\"> <meta name=\"apple-mobile-web-app-capable\" content=\"yes\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2048-2732.jpg\" media=\"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2732-2048.jpg\" media=\"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1668-2388.jpg\" media=\"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2388-1668.jpg\" media=\"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1536-2048.jpg\" media=\"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2048-1536.jpg\" media=\"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1668-2224.jpg\" media=\"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2224-1668.jpg\" media=\"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1620-2160.jpg\" media=\"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2160-1620.jpg\" media=\"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1284-2778.jpg\" media=\"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2778-1284.jpg\" media=\"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1170-2532.jpg\" media=\"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2532-1170.jpg\" media=\"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1125-2436.jpg\" media=\"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2436-1125.jpg\" media=\"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1242-2688.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2688-1242.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-828-1792.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1792-828.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1242-2208.jpg\" media=\"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2208-1242.jpg\" media=\"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-750-1334.jpg\" media=\"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1334-750.jpg\" media=\"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-640-1136.jpg\" media=\"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1136-640.jpg\" media=\"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> Wir h\u00e4tten auch die manifest.json mit angeben k\u00f6nnen (Flag m ) und auch die index.html (Flag -i ), aber wir kopieren die Ausgaben h\u00e4ndisch in die jeweiligen Dateien. Das JSON { \"src\": \"icons/manifest-icon-192.maskable.png\", \"sizes\": \"192x192\", \"type\": \"image/png\", \"purpose\": \"any\" }, { \"src\": \"icons/manifest-icon-192.maskable.png\", \"sizes\": \"192x192\", \"type\": \"image/png\", \"purpose\": \"maskable\" }, { \"src\": \"icons/manifest-icon-512.maskable.png\", \"sizes\": \"512x512\", \"type\": \"image/png\", \"purpose\": \"any\" }, { \"src\": \"icons/manifest-icon-512.maskable.png\", \"sizes\": \"512x512\", \"type\": \"image/png\", \"purpose\": \"maskable\" } kopieren wir in das icons -Array der manifest.json : manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 { \"name\" : \"IKT-PWA\" , \"start_url\" : \"/\" , \"id\" : \"/\" , \"icons\" : [ { \"src\" : \"icons/manifest-icon-192.maskable.png\" , \"sizes\" : \"192x192\" , \"type\" : \"image/png\" , \"purpose\" : \"any\" }, { \"src\" : \"icons/manifest-icon-192.maskable.png\" , \"sizes\" : \"192x192\" , \"type\" : \"image/png\" , \"purpose\" : \"maskable\" }, { \"src\" : \"icons/manifest-icon-512.maskable.png\" , \"sizes\" : \"512x512\" , \"type\" : \"image/png\" , \"purpose\" : \"any\" }, { \"src\" : \"icons/manifest-icon-512.maskable.png\" , \"sizes\" : \"512x512\" , \"type\" : \"image/png\" , \"purpose\" : \"maskable\" } ], \"theme_color\" : \"#000000\" , \"background_color\" : \"#FFFFFF\" , \"display\" : \"fullscreen\" , \"orientation\" : \"portrait\" } und die iOS meta tags in die index.html : index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < link rel = \"shortcut icon\" href = \"favicon.ico\" /> < link rel = \"manifest\" href = \"manifest.json\" > < link rel = \"apple-touch-icon\" href = \"icons/apple-icon-180.png\" > < meta name = \"apple-mobile-web-app-capable\" content = \"yes\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2048-2732.jpg\" media = \"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2732-2048.jpg\" media = \"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1668-2388.jpg\" media = \"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2388-1668.jpg\" media = \"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1536-2048.jpg\" media = \"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2048-1536.jpg\" media = \"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1668-2224.jpg\" media = \"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2224-1668.jpg\" media = \"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1620-2160.jpg\" media = \"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2160-1620.jpg\" media = \"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1284-2778.jpg\" media = \"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2778-1284.jpg\" media = \"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1170-2532.jpg\" media = \"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2532-1170.jpg\" media = \"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1125-2436.jpg\" media = \"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2436-1125.jpg\" media = \"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1242-2688.jpg\" media = \"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2688-1242.jpg\" media = \"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-828-1792.jpg\" media = \"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1792-828.jpg\" media = \"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1242-2208.jpg\" media = \"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2208-1242.jpg\" media = \"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-750-1334.jpg\" media = \"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1334-750.jpg\" media = \"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-640-1136.jpg\" media = \"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1136-640.jpg\" media = \"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < title > IKT Start </ title > </ head > < body > < h1 > Willkommen zu den aktuellen Trends der IKT </ h1 > < script > if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( 'service-worker.js' ); } </ script > </ body > </ html > Prinzipiell w\u00e4re jetzt alles da, damit unsere Anwendung installiert werden kann. Jedoch gibt es derzeit keine M\u00f6glichkeit, dass die Anwendung auch offline verwendbar ist. Dazu ben\u00f6tigt es eine M\u00f6glichkeit des Cachings von Daten. Ohne jetzt schon wirklich zu wissen, was wir tun, passen wir die service-worker.js wie folgt an: service-worker.js importScripts ( 'https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js' ); workbox . routing . registerRoute ( ({ request }) => request . destination === 'image' , new workbox . strategies . NetworkFirst () // NetworkFirst() vs CacheFirst() ) Wir haben also bereits mehrer Sachen identifiziert, mit denen wir uns besch\u00e4ftigen wollen: Manifest , Service worker und Caching und das sind auch genau die Themen der kommenden Wochen. Success Wir haben jetzt eine Idee davon, was Progressive Web Apps sind. Jetzt legen wir los und erstellen eigene PWAs!","title":"Einf\u00fchrung"},{"location":"einfuehrung/#einfuhrung","text":"In diesem Semester geht es um Progressive Web Apps (PWA) . PWA sind Funktionen, die wir Webanwendungen hinzuf\u00fcgen k\u00f6nnen, um sie in ihrer Funktionalit\u00e4t zu erweitern. Die so werweiterten Webanwendungen kommen mit solchen Funktionen nativen Apps immer n\u00e4her, d.h. das Look and Feel gleicht sich mit PWAs nativen Apps an. Dazu geh\u00f6ren Funktionalit\u00e4ten, wie z.B. die M\u00f6glichkeit, die Webanwendung auch offline zu verwenden, die Kamera zu nutzen, den eigenen Standort zu verwenden, Daten im Hintergrund zu synchronisieren. Das bedeutet aber nicht automatisch, dass wir ausschlie\u00dflich auf moderne Browser angewiesen sind, die diese Funktionalit\u00e4ten von PWAs unterst\u00fctzen. Die Webanwendungen sollen auch weiterhin auf alten Webbrowsern laufen, dann jedoch eventuell ohne einige oder alle PWA-Funktionalit\u00e4ten. Progressive Web Apps m\u00fcssen zuverl\u00e4ssig ( reliable ) sein, d.h. sie m\u00fcssen schnelle Ladezeiten aufweisen und sogar (teilweise) offline funktionieren, schnell sein, d.h. schnell auf Nutzerinteraktionen reagieren, motivierend sein, die Webanwendung zu verwenden, d.h. einerseits intuitiv bedienbar und anderseits, z.B. \u00fcber Push-Notifikationen, die Nutzerinnen animieren, die App zu nutzen. Die prinzipielle Idee einer Progressive Web App l\u00e4sst sich vereinfacht durch die folgenden Abbildung veranschaulichen: Eine Progressive Web App ist eine Webanwendung, die sich wie eine native mobile App verh\u00e4lt.","title":"Einf\u00fchrung"},{"location":"einfuehrung/#webanwendungen-vs-native-apps","text":"Die meisten Nutzerinnen verwenden die meiste Zeit native Apps auf ihrem Smartphone. Nur zu einem geringen Prozentsatz werden Web-Anwendungen (also der Browser) auf dem Smartphone verwendet. Das spricht eigentlich eher daf\u00fcr, dass wir uns mit der Entwicklung nativer Apps besch\u00e4ftigen sollten, als mit der Entwicklung von (mobilen) Webanwendungen. Die vorrangige Verwendung nativer Apps hat mehrere Gr\u00fcnde: Push-Notifikationen : Native Apps laufen im Hintergrund und die Nutzerinnen werden \u00fcber Push-Notifikationen informiert, wenn etwas Neues passiert ist, z.B. neue Nachrichten , E-Mails, etc. Man muss also gar nicht aktiv die native App bedienen, um \u00fcber Aktuelles informiert zu werden. App-Icons auf dem Home-Bildschirm : erm\u00f6glichen einen schnellen, direkten Zugang zu den Apps. Ger\u00e4tefunktionen : wie z.B. Standortermittlung, Kameras und Mikrofine k\u00f6nnen leicht in native Apps eingebaut werden. F\u00fcr Webanwendungen ist dies nur aufw\u00e4ndig m\u00f6glich. Offline-Funktionalit\u00e4ten : viele native Apps k\u00f6nnen auch offline ganz oder teilweise verwendet werden, z.B. Spiele oder Musikapps, die heruntergeladene Musik abspielen. App-Icons auf dem Home-Bildschirm k\u00f6nnen wir auch f\u00fcr Links auf unsere Webanwendung erstellen und die anderen drei Argumente wollen wir ja genau mit Progressive Web Apps zunichte machen. Das hei\u00dft, mit Progressive Web Apps kommen die Vorteile nativer Apps im Vergleich zu Webanwendungen nicht mehr zum Tragen. Demgegen\u00fcber stahen zwei Gr\u00fcnde, warum Webanwendungen besser sind als native Apps: Native Apps m\u00fcssen sowohl f\u00fcr iOS als auch f\u00fcr Android erstellt werden, um eine m\u00f6glichst gro\u00dfe Nutzerinnenzahl anzusprechen. Dazu m\u00fcssen auch unterschiedliche programmiersprachen verwendet werden (Swift f\u00fcr iOS und Java/Kotlin f\u00fcr Android). Zwar versuchen Hybride Tools diesen Nachteil zu umgehen, aber es gelingt nicht wirklich. Es werden so gut wie nie neue native Apps auf Smartphones geladen. Umfragen ergeben, dass Nutzerinnen die allermeiste Zeit am Smartphone mit h\u00f6chstens drei Apps verbringen. Alle weiteren Apps werden am Anfang der Nutzung installiert. Es kommen im Laufe eines \"Smartphone-Lebens\" kaum welche hinzu. Die durchschnittliche Anzahl neuhinzugef\u00fcgter Apps im Monat liegt bei nahe 0. Die Verwendung von Webanwendungen ist deutlich einfacher. Man muss nichts installieren. Man googlet einfach und \u00f6ffnet dann die Seite. Die Bandbreite aller Webanwendungen ist deutlich schneller erreichbar als eine gro\u00dfe Anzahl an nativen Apps. Die Reichweite einer Webanwendung ist deutlich gr\u00f6\u00dfer als die Reichweite einer nativen App. Funktionalit\u00e4ten Nutzerinnen-Reichweite native App Zugriff auf Ger\u00e4tefunktionalit\u00e4ten nur sehr wenige Apps werden von sehr vielen Nutzerinnen die meiste Zeit verwendet herk\u00f6mmliche Webanwendungen sehr eingeschr\u00e4nkter (gar kein) Zugriff auf Ger\u00e4tefunktionalit\u00e4ten hohe Reichweite, sehr einfacher Zugang progressive Webanwendungen Zugriff auf Ger\u00e4tefunktionalit\u00e4ten hohe Reichweite, sehr einfacher Zugang","title":"Webanwendungen vs. native Apps"},{"location":"einfuehrung/#links-und-videos","text":"Hier zwei kurze Einf\u00fchrungsvideos zu PWAs: Progressive Web Apps in 100 Seconds Progressive Web Apps - PWA Roadshow Hier einige intressante Links zu PWAs: Learn PWA Progressive Web-Apps: Was versprechen die progressiven Apps? Online Verzeichnis PWAs","title":"Links und Videos"},{"location":"einfuehrung/#pwas-vs-spas","text":"Wir haben noch immer nicht unsere erste Progressive Web App erstellt ;-(. Bevor wir das tun, diskutieren wie zun\u00e4chst noch die Unterschiede zwischen einer Progressive Web App und einer Single Page Application , wie wir sie im WebTech-Kurs erstellt haben. Single Page Applications (SPAs) sind Webanwendungen, die mit JavaScript erstellt werden, typischerweise mit einem JavaScript-Framewaork, wie Angular , React oder Vue.js . In SPAs wird das DOM st\u00e4ndig neu gerendert, welches sich durch Nutzereingaben oder Lifecycle-Events \u00e4ndert. Das Grundger\u00fcst einer SPA besteht aus genau einer HTML -Seite (typischerweise index.html ), in die verschiedene Komponenten eingebunden wird. Eine Single Page Application ist vornehmlich hoch reaktiv auf Nutzereingaben, im Sinne von schneller Reaktion. Progressive Web Applications (PWAs) sind eine Sammlung verschiedener Technologien. Es ist v\u00f6llig egal, ob diese Technologien in eine Single Page Application eingebunden werden oder in eine \"herk\u00f6mmliche\" (Multi-Page-) Webanwendung. Die Idee einer PWA ist, dass sie hoch reaktiv im Sinne st\u00e4ndiger Verf\u00fcgbarkeit ist. JavaScript spielt bei PWAs nicht die dominate Rolle, wie bei SPAs. Sie k\u00f6nnen eine oder mehrere progressive Funktionalit\u00e4ten existierender Webanwendungen hinzuf\u00fcgen (service worker, caching, push notifivcations, ...) oder eine PWA von Grund auf neu implementieren.","title":"PWAs vs. SPAs"},{"location":"einfuehrung/#lighthouse","text":"Lighthouse ist ein Plugin f\u00fcr die Developertools von Chrome, mit dessen Hilfe gemessen werden kann, wie progressive eine Webanwendung ist. Die folgende Abbildung zeigt den Einsatz von Lighthouse f\u00fcr die PWA https://2048.love2dev.com/ - ein Spiel, das Sie wahrscheinlich kennen. Wechseln Sie in den Developertools auf die mobile Ansicht. W\u00e4hlen Sie dann im Reiter Lighthouse die Analyse. Probieren Sie auch mal aus, die Anwendung im Offline-Modus zu verwenden. Wechseln Sie dazu in den Developertools auf den Reiter Network und dort in der Auswahlliste auf Offline . Selbst wenn Sie Disable Cache anklicken, werden Sie feststellen, dass sich das Spiel noch spielen l\u00e4sst. Viel Spa\u00df! ;-)","title":"Lighthouse"},{"location":"einfuehrung/#pwa-checklist","text":"Im Lighthouse-Plugin finden Sie auch einen Link zur PWA Checklist . Diese Checklist wird verwendet, um zu beurteilen, wie progressive eine Webanwendung ist. Eine gute \u00dcbersicht finden Sie auch hier .","title":"PWA Checklist"},{"location":"einfuehrung/#erstes-kleines-beispiel","text":"Wir erstellen uns in einem Ordner eine index.html mit index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < link rel = \"shortcut icon\" href = \"favicon.ico\" type = \"image/x-icon\" /> <!-- muss nicht --> < title > IKT Start </ title > </ head > < body > < h1 > Willkommen zu den Aktuellen Trends der IKT </ h1 > < p > Wir besch\u00e4ftigen uns mit < i > Progressive Web Apps (PWA) </ i > . Ein wesentlicher Bestandteil von PWAs sind < i > Service Worker </ i > . </ p > </ body > </ html > Einen gro\u00dfen Teil unserer Untersuchungen in diesem Modul nehmen Web APIs ein. Wir werden einige von Ihnen n\u00e4her beleuchten. Das zentrale Konzept von PWAs sind ServiceWorker . Wir erstellen uns in unserem Ordner eine Datei service-worker.js und binden diese in unsere index.html ein: index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < link rel = \"shortcut icon\" href = \"favicon.ico\" type = \"image/x-icon\" /> <!-- muss nicht --> < title > IKT Start </ title > </ head > < body > < h1 > Willkommen zu den Aktuellen Trends der IKT </ h1 > < p > Wir besch\u00e4ftigen uns mit < i > Progressive Web Apps (PWA) </ i > . Ein wesentlicher Bestandteil von PWAs sind < i > Service Worker </ i > . </ p > < script > // Check that service workers are supported if ( 'serviceWorker' in navigator ) { // Use the window load event to keep the page load performant window . addEventListener ( 'load' , () => { navigator . serviceWorker . register ( '/service-worker.js' ); }); } </ script > </ body > </ html > In die service-worker.js schreiben wir zun\u00e4chst nur service-worker.js console . log ( 'service worker registriert' ); Wir starten die Anwendung (z.B. mit npx serve ) und schalten die Entwicklertools ein. Auf der Konsole erscheint service worker registriert . Wir wechseln nach Application --> Service Worker und sehen den aktiven service-worker.js . Wenn wir die Anwendung im Browser erneut laden, erscheint die Ausgabe nicht erneut. Wir \u00e4ndern den Service worker, z.B. auf console.log('neuer service worker registriert ) und laden die Anwendung erneut. Die Ausgabe erscheint. Wechseln sie erneut nach Application --> Service Worker . Der Service worker l\u00e4uft auch dann noch, wenn die Anwendung geschlossen ist!","title":"Erstes kleines Beispiel"},{"location":"einfuehrung/#installierbar","text":"Wenn wir unter Lighthouse einen Report generieren, dann sieht es zwar prinzipiell schon ganz gut aus, es handelt sich aber auch noch nicht um eine PWA, da sie (noch) nicht installierbar ist. Wir werden n\u00e4chste Woche damit beginnen, unsere App installierbar zu machen. Hier \"verraten\" wir aber bereits, dass wir dazu eine manifest.json ben\u00f6tigen. Diese erstellen wir und binden sie in die index.html ein: index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < link rel = \"shortcut icon\" href = \"favicon.ico\" type = \"image/x-icon\" /> <!-- muss nicht --> < link rel = \"manifest\" href = \"manifest.json\" > < title > IKT Start </ title > </ head > < body > < h1 > Willkommen zu den Aktuellen Trends der IKT </ h1 > < p > Wir besch\u00e4ftigen uns mit < i > Progressive Web Apps (PWA) </ i > . Ein wesentlicher Bestandteil von PWAs sind < i > Service Worker </ i > . </ p > < script > // Check that service workers are supported if ( 'serviceWorker' in navigator ) { // Use the window load event to keep the page load performant window . addEventListener ( 'load' , () => { navigator . serviceWorker . register ( '/service-worker.js' ); }); } </ script > </ body > </ html > In die manifest.json tragen wir ein: manifest.json 1 2 3 4 5 6 7 8 9 10 { \"name\" : \"IKT-PWA\" , \"start_url\" : \"/\" , \"id\" : \"/\" , \"icons\" : [], \"theme_color\" : \"#000000\" , \"background_color\" : \"#FFFFFF\" , \"display\" : \"fullscreen\" , \"orientation\" : \"portrait\" } Wir kommen zu den einzelnen Eigenschaften n\u00e4chste Woche noch ausf\u00fchrlich. Die manifest.json ist jedoch noch nicht vollst\u00e4ndig, da das icons -Array noch bef\u00fcllt werden muss. In dieses Array tragen wir alle Bilder ein, die als Icons auf dem Startbildschirm verwendet werden sollen, je nach Aufl\u00f6sung des Ger\u00e4tes, auf dem die Anwendung gestartet werden soll. Die Generierung dieser Icons wird uns zum Gl\u00fcck abgenommen. Wir erstellen die Icons auf Basis eines Icons, das in recht gro\u00dfer Aufl\u00f6sung vorliegt. F\u00fcgen Sie dazu das fiwlogo in Ihren Projektordner ein. Wir nutzen den pwa-asset-generator . Im Terminal geben wir in unserem Projektordner ein: npx pwa-asset-generator fiwlogo.png icons Dabei ist fiwlogo.png das Icon, auf dessen Basis alle weiteren Icons erzeugt werden sollen und diese sollen in den Ordner icons erstellt werden. Die Ausgabe ist ungef\u00e4hr wie folgt: 11:49:08 getSplashScreenMetaData Initialising puppeteer to load latest splash screen metadata \ud83e\udd16 11:49:08 getAppleSplashScreenData Navigating to Apple Human Interface Guidelines website - https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/adaptivity-and-layout/ 11:49:10 getAppleSplashScreenData Waiting for the data table to be loaded 11:49:10 getAppleSplashScreenData Retrieved splash screen data 11:49:10 getSplashScreenMetaData Loaded metadata for iOS platform \ud83d\ude4c 11:49:11 generateImages Looks like folder icons doesn't exist. Created one for you \ud83e\udd14 11:49:11 saveImages Initialising puppeteer to take screenshots \ud83e\udd16 11:49:11 getShellHtml Generating shell html with provided image source 11:49:11 getShellHtml Providing shell html as page content 11:49:12 saveImages Saved image apple-splash-2388-1668 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2732-2048 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-1536-2048 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2048-1536 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-1668-2388 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2048-2732 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-1668-2224 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2224-1668 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-1620-2160 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2436-1125 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-1242-2688 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2532-1170 \ud83d\ude4c 11:49:12 saveImages Saved image apple-splash-2160-1620 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1125-2436 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1284-2778 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1242-2208 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1792-828 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1170-2532 \ud83d\ude4c 11:49:13 saveImages Saved image manifest-icon-192 \ud83d\ude4c 11:49:13 saveImages Saved image manifest-icon-512 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-2778-1284 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-2208-1242 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1136-640 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-2688-1242 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-750-1334 \ud83d\ude4c 11:49:13 saveImages Saved image apple-icon-180 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-640-1136 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-1334-750 \ud83d\ude4c 11:49:13 saveImages Saved image apple-splash-828-1792 \ud83d\ude4c 11:49:13 cli Web App Manifest file is not specified, printing out the content to console instead \ud83e\udd14 11:49:13 cli Below is the icons content for your manifest.json file. You can copy/paste it manually \ud83d\ude4c [ { \"src\": \"icons/manifest-icon-192.maskable.png\", \"sizes\": \"192x192\", \"type\": \"image/png\", \"purpose\": \"any\" }, { \"src\": \"icons/manifest-icon-192.maskable.png\", \"sizes\": \"192x192\", \"type\": \"image/png\", \"purpose\": \"maskable\" }, { \"src\": \"icons/manifest-icon-512.maskable.png\", \"sizes\": \"512x512\", \"type\": \"image/png\", \"purpose\": \"any\" }, { \"src\": \"icons/manifest-icon-512.maskable.png\", \"sizes\": \"512x512\", \"type\": \"image/png\", \"purpose\": \"maskable\" } ] 11:49:13 cli Index html file is not specified, printing out the content to console instead \ud83e\udd14 11:49:13 cli Below is the iOS meta tags content for your index.html file. You can copy/paste it manually \ud83d\ude4c <link rel=\"apple-touch-icon\" href=\"icons/apple-icon-180.png\"> <meta name=\"apple-mobile-web-app-capable\" content=\"yes\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2048-2732.jpg\" media=\"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2732-2048.jpg\" media=\"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1668-2388.jpg\" media=\"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2388-1668.jpg\" media=\"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1536-2048.jpg\" media=\"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2048-1536.jpg\" media=\"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1668-2224.jpg\" media=\"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2224-1668.jpg\" media=\"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1620-2160.jpg\" media=\"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2160-1620.jpg\" media=\"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1284-2778.jpg\" media=\"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2778-1284.jpg\" media=\"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1170-2532.jpg\" media=\"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2532-1170.jpg\" media=\"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1125-2436.jpg\" media=\"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2436-1125.jpg\" media=\"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1242-2688.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2688-1242.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-828-1792.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1792-828.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1242-2208.jpg\" media=\"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2208-1242.jpg\" media=\"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-750-1334.jpg\" media=\"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1334-750.jpg\" media=\"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-640-1136.jpg\" media=\"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"> <link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1136-640.jpg\" media=\"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"> Wir h\u00e4tten auch die manifest.json mit angeben k\u00f6nnen (Flag m ) und auch die index.html (Flag -i ), aber wir kopieren die Ausgaben h\u00e4ndisch in die jeweiligen Dateien. Das JSON { \"src\": \"icons/manifest-icon-192.maskable.png\", \"sizes\": \"192x192\", \"type\": \"image/png\", \"purpose\": \"any\" }, { \"src\": \"icons/manifest-icon-192.maskable.png\", \"sizes\": \"192x192\", \"type\": \"image/png\", \"purpose\": \"maskable\" }, { \"src\": \"icons/manifest-icon-512.maskable.png\", \"sizes\": \"512x512\", \"type\": \"image/png\", \"purpose\": \"any\" }, { \"src\": \"icons/manifest-icon-512.maskable.png\", \"sizes\": \"512x512\", \"type\": \"image/png\", \"purpose\": \"maskable\" } kopieren wir in das icons -Array der manifest.json : manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 { \"name\" : \"IKT-PWA\" , \"start_url\" : \"/\" , \"id\" : \"/\" , \"icons\" : [ { \"src\" : \"icons/manifest-icon-192.maskable.png\" , \"sizes\" : \"192x192\" , \"type\" : \"image/png\" , \"purpose\" : \"any\" }, { \"src\" : \"icons/manifest-icon-192.maskable.png\" , \"sizes\" : \"192x192\" , \"type\" : \"image/png\" , \"purpose\" : \"maskable\" }, { \"src\" : \"icons/manifest-icon-512.maskable.png\" , \"sizes\" : \"512x512\" , \"type\" : \"image/png\" , \"purpose\" : \"any\" }, { \"src\" : \"icons/manifest-icon-512.maskable.png\" , \"sizes\" : \"512x512\" , \"type\" : \"image/png\" , \"purpose\" : \"maskable\" } ], \"theme_color\" : \"#000000\" , \"background_color\" : \"#FFFFFF\" , \"display\" : \"fullscreen\" , \"orientation\" : \"portrait\" } und die iOS meta tags in die index.html : index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < link rel = \"shortcut icon\" href = \"favicon.ico\" /> < link rel = \"manifest\" href = \"manifest.json\" > < link rel = \"apple-touch-icon\" href = \"icons/apple-icon-180.png\" > < meta name = \"apple-mobile-web-app-capable\" content = \"yes\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2048-2732.jpg\" media = \"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2732-2048.jpg\" media = \"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1668-2388.jpg\" media = \"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2388-1668.jpg\" media = \"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1536-2048.jpg\" media = \"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2048-1536.jpg\" media = \"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1668-2224.jpg\" media = \"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2224-1668.jpg\" media = \"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1620-2160.jpg\" media = \"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2160-1620.jpg\" media = \"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1284-2778.jpg\" media = \"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2778-1284.jpg\" media = \"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1170-2532.jpg\" media = \"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2532-1170.jpg\" media = \"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1125-2436.jpg\" media = \"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2436-1125.jpg\" media = \"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1242-2688.jpg\" media = \"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2688-1242.jpg\" media = \"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-828-1792.jpg\" media = \"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1792-828.jpg\" media = \"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1242-2208.jpg\" media = \"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-2208-1242.jpg\" media = \"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-750-1334.jpg\" media = \"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1334-750.jpg\" media = \"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-640-1136.jpg\" media = \"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\" > < link rel = \"apple-touch-startup-image\" href = \"icons/apple-splash-1136-640.jpg\" media = \"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\" > < title > IKT Start </ title > </ head > < body > < h1 > Willkommen zu den aktuellen Trends der IKT </ h1 > < script > if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( 'service-worker.js' ); } </ script > </ body > </ html > Prinzipiell w\u00e4re jetzt alles da, damit unsere Anwendung installiert werden kann. Jedoch gibt es derzeit keine M\u00f6glichkeit, dass die Anwendung auch offline verwendbar ist. Dazu ben\u00f6tigt es eine M\u00f6glichkeit des Cachings von Daten. Ohne jetzt schon wirklich zu wissen, was wir tun, passen wir die service-worker.js wie folgt an: service-worker.js importScripts ( 'https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js' ); workbox . routing . registerRoute ( ({ request }) => request . destination === 'image' , new workbox . strategies . NetworkFirst () // NetworkFirst() vs CacheFirst() ) Wir haben also bereits mehrer Sachen identifiziert, mit denen wir uns besch\u00e4ftigen wollen: Manifest , Service worker und Caching und das sind auch genau die Themen der kommenden Wochen. Success Wir haben jetzt eine Idee davon, was Progressive Web Apps sind. Jetzt legen wir los und erstellen eigene PWAs!","title":"Installierbar"},{"location":"grundgeruest/","text":"Grundger\u00fcst unserer PWA \u00b6 Wir beginnen jetzt mit der Implementierung von progressive Funktionalit\u00e4ten. Das machen wir, indem wir sukzessive eine Progressive Web App erstellen, die viele der derzeit verf\u00fcgbaren Funktionalit\u00e4ten enth\u00e4lt, die derzeit f\u00fcr Progressive Web Apps verf\u00fcgbar sind. Das Grundger\u00fcst (oder der Ausgangspunkt) unserer PWA wird deshalb zur Verf\u00fcgung gestellt, weil wir uns nicht um die Implementierung von HTML, CSS und JavaScript, sondern nur um die progressive Funktionalit\u00e4ten k\u00fcmmern wollen. Auf Basis dieses Grundger\u00fcstes werden sukzessive Funktionalit\u00e4ten, wie Push-Notifikationen, Offline-Verwendung, Geolocation, Kameranutzung usw. hinzuf\u00fcgen. Die Idee ist, dass wir eine Art HTW-Instagram erstellen. Ich habe Instagram aber noch nie genutzt, deshalb wei\u00df ich nicht, ob wir dem \"Original\" nahe kommen werden. Wahrscheinlich nicht, aber daf\u00fcr behalten wir unsere Daten auch bei uns. Installation \u00b6 Den Quellcode f\u00fcr das Grundger\u00fcst finden Sie hier (GitHub) . Clonen Sie sich das Projekt in einem Ordner Ihrer Wahl und folgen Sie dann der README.MD : Zum Ausf\u00fchren des Projektes wird Node.js verendet. Sie m\u00fcssen es auf Ihren Rechner installieren. In der Wahl Ihrer IDE sind Sie v\u00f6llig frei. Empfehlungen finden Sie unter https://freiheit.f4.htw-berlin.de/ikt/tools/#integrated-development-environment-ide Zum Starten des Projektes wechseln Sie im Terminal (Terminal Ihres Rechners oder das Terminal in der IDE) in den Projektordner ( cd IKT-PWA-01 ) und f\u00fchren dort npm install aus. Damit werden alle erforderlichen Abh\u00e4ngigkeiten installiert. Nach erfolgreicher Installation der Abh\u00e4ngigkeiten, geben Sie npm start ein (oder genereller: npm run start ), um Ihr Projekt auszuf\u00fchren. Klicken Sie danach auf localhost:8080 oder geben Sie die URL direkt in Ihren Browser ein. Starten \u00b6 Starten Sie das Projekt mit npm start (nachdem Sie einmalig npm install ausgef\u00fchrt haben) und \u00f6ffnen Sie dann den Browser mit der URL http://localhost:8080/ . Es erscheint bzw. wenn Sie die Viewport-Breite verkleinern . Sie erkennen wahrscheinlich schon, dass wir Material Design Lite verwenden. Die Navigationskomponente kennen wir auch schon aus WebTech. Wenn Sie auf den + -Button klicken, erscheint ein kleines Men\u00fc. Dort k\u00f6nnen Sie zwar schon etwas eintragen, aber der SPEICHERN -Button funktioniert noch nicht. Auch beim BENACHRICHTIGUNGEN EIN -Button ist noch keine Ereignisbehandlung hinterlegt. Wenn Sie im Men\u00fc Hilfe klicken, \u00f6ffnet sich die (fast leere) Hilfe-Seite. Schalten Sie beim Betrachten der Anwendung stets die DeveloperTools ein. Sie k\u00f6nnen dort sehr leicht auf die mobile Ansicht wechseln. Wichtig ist, dass Sie - zum besseren Ausprobieren der Anwendung - in den DeveloperTools unter dem Reiter Network ein H\u00e4kchen bei Disable Cache setzen. Wir wollen in Zukunft das Caching unseren Service workern \u00fcberlassen und nicht den Cache des Browsers verwenden. Projekt \u00b6 Bevor wir loslegen, werfen wir noch einen kurzen Blick auf die bisherigen Dateien im Projekt. Wir beginnen mit der index.html aus dem public -Ordner. public/index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 <!doctype html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > IKT-PWA </ title > < link href = \"https://fonts.googleapis.com/css?family=Roboto:400,700\" rel = \"stylesheet\" > < link rel = \"stylesheet\" href = \"https://fonts.googleapis.com/icon?family=Material+Icons\" > < link rel = \"stylesheet\" href = \"https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css\" > < link rel = \"stylesheet\" href = \"/src/css/app.css\" > < link rel = \"stylesheet\" href = \"/src/css/feed.css\" > </ head > < body > < div id = \"app\" > < div class = \"mdl-layout mdl-js-layout mdl-layout--fixed-header\" > < header class = \"mdl-layout__header\" > < div class = \"mdl-layout__header-row\" > <!-- Title --> < span class = \"mdl-layout-title\" > IKT-PWA </ span > <!-- Add spacer, to align navigation to the right --> < div class = \"mdl-layout-spacer\" ></ div > <!-- Navigation. We hide it in small screens. --> < nav class = \"mdl-navigation mdl-layout--large-screen-only\" > < a class = \"mdl-navigation__link\" href = \"/\" > Bilder </ a > < a class = \"mdl-navigation__link\" href = \"/help\" > Hilfe </ a > < div class = \"drawer-option\" > < button class = \"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\" > Benachrichtigungen Ein </ button > </ div > </ nav > </ div > </ header > < div class = \"mdl-layout__drawer\" > < span class = \"mdl-layout-title\" > IKT-PWA </ span > < nav class = \"mdl-navigation\" > < a class = \"mdl-navigation__link\" href = \"/\" > Bilder </ a > < a class = \"mdl-navigation__link\" href = \"/help\" > Hilfe </ a > < div class = \"drawer-option\" > < button class = \"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\" > Benachrichtigungen Ein </ button > </ div > </ nav > </ div > < main class = \"mdl-layout__content mat-typography\" > < div id = \"create-post\" > < form > < div class = \"input-section mdl-textfield mdl-js-textfield mdl-textfield--floating-label\" > < input class = \"mdl-textfield__input\" type = \"text\" id = \"title\" > < label class = \"mdl-textfield__label\" for = \"title\" name = \"title\" > Titel </ label > </ div > < div class = \"input-section mdl-textfield mdl-js-textfield mdl-textfield--floating-label\" id = \"manual-location\" > < input class = \"mdl-textfield__input\" type = \"text\" id = \"location\" > < label class = \"mdl-textfield__label\" for = \"location\" name = \"location\" > Ort </ label > </ div > < br > < div > < button class = \"mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\" type = \"submit\" id = \"post-btn\" > Speichern </ button > </ div > < br > < div > < button class = \"mdl-button mdl-js-button mdl-button--fab\" id = \"close-create-post-modal-btn\" type = \"button\" > < i class = \"material-icons\" > close </ i > </ button > </ div > </ form > </ div > < img src = \"/src/images/htw.jpg\" alt = \"HTW Wilhelminenhof\" class = \"main-image\" > < div class = \"page-content\" > < h5 class = \"text-center mdl-color-text--primary\" > HTW-Insta </ h5 > < div id = \"shared-moments\" ></ div > </ div > < div class = \"floating-button\" > < button class = \"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\" id = \"share-image-button\" > < i class = \"material-icons\" > add </ i > </ button > </ div > < div id = \"confirmation-toast\" aria-live = \"assertive\" aria-atomic = \"true\" aria-relevant = \"text\" class = \"mdl-snackbar mdl-js-snackbar\" > < div class = \"mdl-snackbar__text\" ></ div > < button type = \"button\" class = \"mdl-snackbar__action\" ></ button > </ div > </ main > </ div > </ div > < script defer src = \"/src/js/material.min.js\" ></ script > < script src = \"/src/js/app.js\" ></ script > < script src = \"/src/js/feed.js\" ></ script > </ body > </ html > Sie sieht recht umfangreich aus. Tats\u00e4chlich ist aber das meiste darin f\u00fcr das Navigationstemplate. Die Zeilen 21-36 und 38-49 beschreiben das gleiche, n\u00e4mlich die Navigationsleiste. Der obere Block ist f\u00fcr breite Viewports (Klasse mdl-layout--large-screen-only ). Alle mdl -Klassen sind von Material. Einen guten \u00dcberblick \u00fcber die einzelnen Material-Komponenten finden Sie hier . N\u00e4heres zu den Navigationen finden Sie darin z.B. hier . Dann kommt das Bild (Zeilen 75-77 ), dann der Text HTW Insta (Zeilen 78-81 ) und dann der + -Button (Zeilen 82-87 ). In den Zeilen 88-91 ist bereits eine Best\u00e4tigungsnachricht hinterlegt, derzeit aber noch hidden . In den eingeundenen eigenen Stylesheets app.css und feed.css steht nicht viel: public/src/css/app.css 1 2 3 4 5 6 7 . text-center { text-align : center ; } . drawer-option { padding : 16 px ; } public/src/css/feed.css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # create-post { z-index : 1001 ; position : fixed ; width : 100 % ; min-height : 100 vh ; overflow-y : scroll ; bottom : 0 ; top : 56 px ; background : white ; text-align : center ; display : none ; } . main-image { max-width : 100 % ; margin : auto ; display : block ; } . floating-button { z-index : 1000 ; position : fixed ; bottom : 0 ; right : 0 ; padding : 30 px ; } . input-section { display : block ; margin : 10 px auto ; } Kurze Erinnerung an CSS: Punktselektoren beschreiben Klassen (z.B. .input-selection ) und #-Selektoren beschreiben Ids (z.B. #create-post ). Sie k\u00f6nnen die Anwendung der Klassen und der Ids ja mal in der index.html suchen, wenn Sie m\u00f6chten. Die public/help/index.html enth\u00e4lt noch weniger als die public/index.html . Erw\u00e4hnenswert ist hier, dass wir mit einem Framework wie z.B. Angular nat\u00fcrlich der Navigation eine eigenen Komponente spendiert und diese nicht in beiden Dateien wiederholt h\u00e4tten. public/help/index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 <!doctype html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Help </ title > < link href = \"https://fonts.googleapis.com/css?family=Roboto:400,700\" rel = \"stylesheet\" > < link rel = \"stylesheet\" href = \"https://fonts.googleapis.com/icon?family=Material+Icons\" > < link rel = \"stylesheet\" href = \"https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css\" > < link rel = \"stylesheet\" href = \"/src/css/help.css\" > </ head > < body > < div id = \"app\" > < div class = \"mdl-layout mdl-js-layout mdl-layout--fixed-header\" > < header class = \"mdl-layout__header\" > < div class = \"mdl-layout__header-row\" > <!-- Title --> < span class = \"mdl-layout-title\" > IKT-PWA </ span > <!-- Add spacer, to align navigation to the right --> < div class = \"mdl-layout-spacer\" ></ div > <!-- Navigation. We hide it in small screens. --> < nav class = \"mdl-navigation mdl-layout--large-screen-only\" > < a class = \"mdl-navigation__link\" href = \"/\" > Bilder </ a > < a class = \"mdl-navigation__link\" href = \"/settings\" > Einstellungen </ a > < div class = \"drawer-option\" > < button class = \"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\" > Benachrichtigungen Ein </ button > </ div > </ nav > </ div > </ header > < div class = \"mdl-layout__drawer\" > < span class = \"mdl-layout-title\" > IKT-PWA </ span > < nav class = \"mdl-navigation\" > < a class = \"mdl-navigation__link\" href = \"/\" > Feed </ a > < a class = \"mdl-navigation__link\" href = \"/help\" > Help </ a > < div class = \"drawer-option\" > < button class = \"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\" > Benachrichtigungen Ein </ button > </ div > </ nav > </ div > < main class = \"mdl-layout__content mat-typography\" > < div class = \"mdl-grid\" > < div class = \"mdl-cell mdl-cell--12-col text-center\" > < h3 > Brauchst Du Hilfe? </ h3 > < p > Hier erf\u00e4hrst Du, wie Du die App benutzen und neue Bildeintr\u00e4ge erstellen kannst. </ p > </ div > </ div > < div class = \"mdl-grid\" > < div class = \"mdl-cell mdl-cell--12-col text-center\" > < h3 > Kontakt </ h3 > < div > < button class = \"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\" > < i class = \"material-icons\" > call </ i > </ button > < button class = \"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\" > < i class = \"material-icons\" > email </ i > </ button > < button class = \"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\" > < i class = \"material-icons\" > chat_bubble </ i > </ button > </ div > </ div > </ div > </ main > </ div > </ div > < script defer src = \"/src/js/material.min.js\" ></ script > < script src = \"/src/js/app.js\" ></ script > </ body > </ html > Von den beiden JavaScript-Dateien public/src/js/app.js und public/src/js/feed.js steht derzeit nur etwas in der feed.js . Das schauen wir uns aber erst dann an, wenn wir neue Bildeintr\u00e4ge speichern wollen. Ngrok \u00b6 Beachten Sie, dass eine Anforderung an eine PWA ist, dass sie entweder unter localhost oder unter https l\u00e4uft. Das Werkzeug ngrok bietet sichere Tunnel an und simuliert so einen sicheren Webserver. Angenommen, Ihre Anwendung l\u00e4uft unter Port 8080 , dann geben Sie im Terminal einfach ngrok http 8080 ein und es erscheint in etwa: ngrok by @inconshreveable (Ctrl+C to quit) Session Status online Account J\u00f6rn Freiheit (Plan: Free) Version 2.3.40 Region United States (us) Web Interface http://127.0.0.1:4040 Forwarding http://039a-141-45-155-245.ngrok.io -> http://localhost:8080 Forwarding https://039a-141-45-155-245.ngrok.io -> http://localhost:8080 Connections ttl opn rt1 rt5 p50 p90 11 0 0.00 0.01 0.33 6.43 HTTP Requests ------------- GET /favicon.ico 200 OK GET /src/js/feed.js 200 OK GET /manifest.json 200 OK GET /src/js/material.min.js 200 OK GET /src/js/app.js 200 OK GET /src/images/htw.jpg 200 OK GET /src/css/feed.css 200 OK GET / 200 OK GET /src/css/app.css 200 OK GET /src/images/icons/fiw256x256.png 200 OK Sie haben nun unter der Adresse https://039a-141-45-155-245.ngrok.io (bei Ihnen anders!) eine https -Verbindung zum Webserver. Sie k\u00f6nnen die Anwendung somit unter dieser Adresse auch in Ihrem Smartphone aufrufen. Lassen Sie sich dazu am besten von Ihrem Browser einen QR-Code erzeugen und fotografieren ihn mit der Kamera ab. Schauen Sie sich auch ruhig einmal das Web-Interface von ngrok an, das unter http://127.0.0.1:4040 verf\u00fcgbar ist.","title":"Grundger\u00fcst"},{"location":"grundgeruest/#grundgerust-unserer-pwa","text":"Wir beginnen jetzt mit der Implementierung von progressive Funktionalit\u00e4ten. Das machen wir, indem wir sukzessive eine Progressive Web App erstellen, die viele der derzeit verf\u00fcgbaren Funktionalit\u00e4ten enth\u00e4lt, die derzeit f\u00fcr Progressive Web Apps verf\u00fcgbar sind. Das Grundger\u00fcst (oder der Ausgangspunkt) unserer PWA wird deshalb zur Verf\u00fcgung gestellt, weil wir uns nicht um die Implementierung von HTML, CSS und JavaScript, sondern nur um die progressive Funktionalit\u00e4ten k\u00fcmmern wollen. Auf Basis dieses Grundger\u00fcstes werden sukzessive Funktionalit\u00e4ten, wie Push-Notifikationen, Offline-Verwendung, Geolocation, Kameranutzung usw. hinzuf\u00fcgen. Die Idee ist, dass wir eine Art HTW-Instagram erstellen. Ich habe Instagram aber noch nie genutzt, deshalb wei\u00df ich nicht, ob wir dem \"Original\" nahe kommen werden. Wahrscheinlich nicht, aber daf\u00fcr behalten wir unsere Daten auch bei uns.","title":"Grundger\u00fcst unserer PWA"},{"location":"grundgeruest/#installation","text":"Den Quellcode f\u00fcr das Grundger\u00fcst finden Sie hier (GitHub) . Clonen Sie sich das Projekt in einem Ordner Ihrer Wahl und folgen Sie dann der README.MD : Zum Ausf\u00fchren des Projektes wird Node.js verendet. Sie m\u00fcssen es auf Ihren Rechner installieren. In der Wahl Ihrer IDE sind Sie v\u00f6llig frei. Empfehlungen finden Sie unter https://freiheit.f4.htw-berlin.de/ikt/tools/#integrated-development-environment-ide Zum Starten des Projektes wechseln Sie im Terminal (Terminal Ihres Rechners oder das Terminal in der IDE) in den Projektordner ( cd IKT-PWA-01 ) und f\u00fchren dort npm install aus. Damit werden alle erforderlichen Abh\u00e4ngigkeiten installiert. Nach erfolgreicher Installation der Abh\u00e4ngigkeiten, geben Sie npm start ein (oder genereller: npm run start ), um Ihr Projekt auszuf\u00fchren. Klicken Sie danach auf localhost:8080 oder geben Sie die URL direkt in Ihren Browser ein.","title":"Installation"},{"location":"grundgeruest/#starten","text":"Starten Sie das Projekt mit npm start (nachdem Sie einmalig npm install ausgef\u00fchrt haben) und \u00f6ffnen Sie dann den Browser mit der URL http://localhost:8080/ . Es erscheint bzw. wenn Sie die Viewport-Breite verkleinern . Sie erkennen wahrscheinlich schon, dass wir Material Design Lite verwenden. Die Navigationskomponente kennen wir auch schon aus WebTech. Wenn Sie auf den + -Button klicken, erscheint ein kleines Men\u00fc. Dort k\u00f6nnen Sie zwar schon etwas eintragen, aber der SPEICHERN -Button funktioniert noch nicht. Auch beim BENACHRICHTIGUNGEN EIN -Button ist noch keine Ereignisbehandlung hinterlegt. Wenn Sie im Men\u00fc Hilfe klicken, \u00f6ffnet sich die (fast leere) Hilfe-Seite. Schalten Sie beim Betrachten der Anwendung stets die DeveloperTools ein. Sie k\u00f6nnen dort sehr leicht auf die mobile Ansicht wechseln. Wichtig ist, dass Sie - zum besseren Ausprobieren der Anwendung - in den DeveloperTools unter dem Reiter Network ein H\u00e4kchen bei Disable Cache setzen. Wir wollen in Zukunft das Caching unseren Service workern \u00fcberlassen und nicht den Cache des Browsers verwenden.","title":"Starten"},{"location":"grundgeruest/#projekt","text":"Bevor wir loslegen, werfen wir noch einen kurzen Blick auf die bisherigen Dateien im Projekt. Wir beginnen mit der index.html aus dem public -Ordner. public/index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 <!doctype html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > IKT-PWA </ title > < link href = \"https://fonts.googleapis.com/css?family=Roboto:400,700\" rel = \"stylesheet\" > < link rel = \"stylesheet\" href = \"https://fonts.googleapis.com/icon?family=Material+Icons\" > < link rel = \"stylesheet\" href = \"https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css\" > < link rel = \"stylesheet\" href = \"/src/css/app.css\" > < link rel = \"stylesheet\" href = \"/src/css/feed.css\" > </ head > < body > < div id = \"app\" > < div class = \"mdl-layout mdl-js-layout mdl-layout--fixed-header\" > < header class = \"mdl-layout__header\" > < div class = \"mdl-layout__header-row\" > <!-- Title --> < span class = \"mdl-layout-title\" > IKT-PWA </ span > <!-- Add spacer, to align navigation to the right --> < div class = \"mdl-layout-spacer\" ></ div > <!-- Navigation. We hide it in small screens. --> < nav class = \"mdl-navigation mdl-layout--large-screen-only\" > < a class = \"mdl-navigation__link\" href = \"/\" > Bilder </ a > < a class = \"mdl-navigation__link\" href = \"/help\" > Hilfe </ a > < div class = \"drawer-option\" > < button class = \"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\" > Benachrichtigungen Ein </ button > </ div > </ nav > </ div > </ header > < div class = \"mdl-layout__drawer\" > < span class = \"mdl-layout-title\" > IKT-PWA </ span > < nav class = \"mdl-navigation\" > < a class = \"mdl-navigation__link\" href = \"/\" > Bilder </ a > < a class = \"mdl-navigation__link\" href = \"/help\" > Hilfe </ a > < div class = \"drawer-option\" > < button class = \"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\" > Benachrichtigungen Ein </ button > </ div > </ nav > </ div > < main class = \"mdl-layout__content mat-typography\" > < div id = \"create-post\" > < form > < div class = \"input-section mdl-textfield mdl-js-textfield mdl-textfield--floating-label\" > < input class = \"mdl-textfield__input\" type = \"text\" id = \"title\" > < label class = \"mdl-textfield__label\" for = \"title\" name = \"title\" > Titel </ label > </ div > < div class = \"input-section mdl-textfield mdl-js-textfield mdl-textfield--floating-label\" id = \"manual-location\" > < input class = \"mdl-textfield__input\" type = \"text\" id = \"location\" > < label class = \"mdl-textfield__label\" for = \"location\" name = \"location\" > Ort </ label > </ div > < br > < div > < button class = \"mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\" type = \"submit\" id = \"post-btn\" > Speichern </ button > </ div > < br > < div > < button class = \"mdl-button mdl-js-button mdl-button--fab\" id = \"close-create-post-modal-btn\" type = \"button\" > < i class = \"material-icons\" > close </ i > </ button > </ div > </ form > </ div > < img src = \"/src/images/htw.jpg\" alt = \"HTW Wilhelminenhof\" class = \"main-image\" > < div class = \"page-content\" > < h5 class = \"text-center mdl-color-text--primary\" > HTW-Insta </ h5 > < div id = \"shared-moments\" ></ div > </ div > < div class = \"floating-button\" > < button class = \"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\" id = \"share-image-button\" > < i class = \"material-icons\" > add </ i > </ button > </ div > < div id = \"confirmation-toast\" aria-live = \"assertive\" aria-atomic = \"true\" aria-relevant = \"text\" class = \"mdl-snackbar mdl-js-snackbar\" > < div class = \"mdl-snackbar__text\" ></ div > < button type = \"button\" class = \"mdl-snackbar__action\" ></ button > </ div > </ main > </ div > </ div > < script defer src = \"/src/js/material.min.js\" ></ script > < script src = \"/src/js/app.js\" ></ script > < script src = \"/src/js/feed.js\" ></ script > </ body > </ html > Sie sieht recht umfangreich aus. Tats\u00e4chlich ist aber das meiste darin f\u00fcr das Navigationstemplate. Die Zeilen 21-36 und 38-49 beschreiben das gleiche, n\u00e4mlich die Navigationsleiste. Der obere Block ist f\u00fcr breite Viewports (Klasse mdl-layout--large-screen-only ). Alle mdl -Klassen sind von Material. Einen guten \u00dcberblick \u00fcber die einzelnen Material-Komponenten finden Sie hier . N\u00e4heres zu den Navigationen finden Sie darin z.B. hier . Dann kommt das Bild (Zeilen 75-77 ), dann der Text HTW Insta (Zeilen 78-81 ) und dann der + -Button (Zeilen 82-87 ). In den Zeilen 88-91 ist bereits eine Best\u00e4tigungsnachricht hinterlegt, derzeit aber noch hidden . In den eingeundenen eigenen Stylesheets app.css und feed.css steht nicht viel: public/src/css/app.css 1 2 3 4 5 6 7 . text-center { text-align : center ; } . drawer-option { padding : 16 px ; } public/src/css/feed.css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # create-post { z-index : 1001 ; position : fixed ; width : 100 % ; min-height : 100 vh ; overflow-y : scroll ; bottom : 0 ; top : 56 px ; background : white ; text-align : center ; display : none ; } . main-image { max-width : 100 % ; margin : auto ; display : block ; } . floating-button { z-index : 1000 ; position : fixed ; bottom : 0 ; right : 0 ; padding : 30 px ; } . input-section { display : block ; margin : 10 px auto ; } Kurze Erinnerung an CSS: Punktselektoren beschreiben Klassen (z.B. .input-selection ) und #-Selektoren beschreiben Ids (z.B. #create-post ). Sie k\u00f6nnen die Anwendung der Klassen und der Ids ja mal in der index.html suchen, wenn Sie m\u00f6chten. Die public/help/index.html enth\u00e4lt noch weniger als die public/index.html . Erw\u00e4hnenswert ist hier, dass wir mit einem Framework wie z.B. Angular nat\u00fcrlich der Navigation eine eigenen Komponente spendiert und diese nicht in beiden Dateien wiederholt h\u00e4tten. public/help/index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 <!doctype html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Help </ title > < link href = \"https://fonts.googleapis.com/css?family=Roboto:400,700\" rel = \"stylesheet\" > < link rel = \"stylesheet\" href = \"https://fonts.googleapis.com/icon?family=Material+Icons\" > < link rel = \"stylesheet\" href = \"https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css\" > < link rel = \"stylesheet\" href = \"/src/css/help.css\" > </ head > < body > < div id = \"app\" > < div class = \"mdl-layout mdl-js-layout mdl-layout--fixed-header\" > < header class = \"mdl-layout__header\" > < div class = \"mdl-layout__header-row\" > <!-- Title --> < span class = \"mdl-layout-title\" > IKT-PWA </ span > <!-- Add spacer, to align navigation to the right --> < div class = \"mdl-layout-spacer\" ></ div > <!-- Navigation. We hide it in small screens. --> < nav class = \"mdl-navigation mdl-layout--large-screen-only\" > < a class = \"mdl-navigation__link\" href = \"/\" > Bilder </ a > < a class = \"mdl-navigation__link\" href = \"/settings\" > Einstellungen </ a > < div class = \"drawer-option\" > < button class = \"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\" > Benachrichtigungen Ein </ button > </ div > </ nav > </ div > </ header > < div class = \"mdl-layout__drawer\" > < span class = \"mdl-layout-title\" > IKT-PWA </ span > < nav class = \"mdl-navigation\" > < a class = \"mdl-navigation__link\" href = \"/\" > Feed </ a > < a class = \"mdl-navigation__link\" href = \"/help\" > Help </ a > < div class = \"drawer-option\" > < button class = \"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\" > Benachrichtigungen Ein </ button > </ div > </ nav > </ div > < main class = \"mdl-layout__content mat-typography\" > < div class = \"mdl-grid\" > < div class = \"mdl-cell mdl-cell--12-col text-center\" > < h3 > Brauchst Du Hilfe? </ h3 > < p > Hier erf\u00e4hrst Du, wie Du die App benutzen und neue Bildeintr\u00e4ge erstellen kannst. </ p > </ div > </ div > < div class = \"mdl-grid\" > < div class = \"mdl-cell mdl-cell--12-col text-center\" > < h3 > Kontakt </ h3 > < div > < button class = \"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\" > < i class = \"material-icons\" > call </ i > </ button > < button class = \"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\" > < i class = \"material-icons\" > email </ i > </ button > < button class = \"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\" > < i class = \"material-icons\" > chat_bubble </ i > </ button > </ div > </ div > </ div > </ main > </ div > </ div > < script defer src = \"/src/js/material.min.js\" ></ script > < script src = \"/src/js/app.js\" ></ script > </ body > </ html > Von den beiden JavaScript-Dateien public/src/js/app.js und public/src/js/feed.js steht derzeit nur etwas in der feed.js . Das schauen wir uns aber erst dann an, wenn wir neue Bildeintr\u00e4ge speichern wollen.","title":"Projekt"},{"location":"grundgeruest/#ngrok","text":"Beachten Sie, dass eine Anforderung an eine PWA ist, dass sie entweder unter localhost oder unter https l\u00e4uft. Das Werkzeug ngrok bietet sichere Tunnel an und simuliert so einen sicheren Webserver. Angenommen, Ihre Anwendung l\u00e4uft unter Port 8080 , dann geben Sie im Terminal einfach ngrok http 8080 ein und es erscheint in etwa: ngrok by @inconshreveable (Ctrl+C to quit) Session Status online Account J\u00f6rn Freiheit (Plan: Free) Version 2.3.40 Region United States (us) Web Interface http://127.0.0.1:4040 Forwarding http://039a-141-45-155-245.ngrok.io -> http://localhost:8080 Forwarding https://039a-141-45-155-245.ngrok.io -> http://localhost:8080 Connections ttl opn rt1 rt5 p50 p90 11 0 0.00 0.01 0.33 6.43 HTTP Requests ------------- GET /favicon.ico 200 OK GET /src/js/feed.js 200 OK GET /manifest.json 200 OK GET /src/js/material.min.js 200 OK GET /src/js/app.js 200 OK GET /src/images/htw.jpg 200 OK GET /src/css/feed.css 200 OK GET / 200 OK GET /src/css/app.css 200 OK GET /src/images/icons/fiw256x256.png 200 OK Sie haben nun unter der Adresse https://039a-141-45-155-245.ngrok.io (bei Ihnen anders!) eine https -Verbindung zum Webserver. Sie k\u00f6nnen die Anwendung somit unter dieser Adresse auch in Ihrem Smartphone aufrufen. Lassen Sie sich dazu am besten von Ihrem Browser einen QR-Code erzeugen und fotografieren ihn mit der Kamera ab. Schauen Sie sich auch ruhig einmal das Web-Interface von ngrok an, das unter http://127.0.0.1:4040 verf\u00fcgbar ist.","title":"Ngrok"},{"location":"manifest/","text":"Web-App-Manifest \u00b6 Das Web-App-Manifest ist zun\u00e4chst einmal eine Datei, n\u00e4mlich manifest.json . Sie wird also in der JavaScript Object Notation (JSON) geschrieben. Diese Datei dient als Information f\u00fcr den Browser. Sie wird also vom Browser ausgelesen. Beispielsweise kann in der manifest.json vereinbart werden, dass sich die Webanwendung selbst auf dem Startbildschirm Ihres Mobilger\u00e4tes installiert. Dann gen\u00fcgt ein Klick auf das Icon auf dem Startbildschirm und die Webanwendung wird durch den Browser ge\u00f6ffnet. Somit h\u00e4tten wir schonmal eine wesentliche Gemeinsamkeit zu einer nativen App geschaffen, welche ja auch durch ein Klick auf ein Icon auf dem Startbildschirm gestartet werden k\u00f6nnen. Wir lernen kennen, wie wir ein solches Manifest unserer PWA hinzuf\u00fcgen, wie es konfiguriert werden kann und wie wir die Auswirkungen eines solchen Manifestes auf mobilen Ger\u00e4ten sehen k\u00f6nnen. Installierbar \u00b6 Mithilfe eines Web-App-Manifestes machen wir unsere Webanwendung installierbar auf einem mobilen Ger\u00e4t. Die Anwendung muss nicht einem App-Store hinzugef\u00fcgt werden, sondern wird einfach \u00fcber das Web durch einen Browser geladen. Normalerweise kann eine Webanwendung ja nur dadurch gestartet werden, dass ihre URL in den Browser eingetragen wird (oder Sie haben ein lesezeichen auf die Webanwendung in Ihrem Browser gesetzt). Nun wollen wir auf den Startbildschirm des Smartphones ein Icon setzen (genau wie f\u00fcr native Apps) und dar\u00fcber die Anwendung starten. Daf\u00fcr f\u00fcgen wir im Projektordner in dem Ordner /public die Datei manifest.json hinzu: Diese Datei sollte genau so hei\u00dfen und es ist g\u00fcnstig, sie in den /public -Ordner zu legen. Achten Sie darauf, wohin Sie die Datei legen. Wenn Sie sie direkt in den Projektordner legen, dann gelten alle Pfadangaben in dieser Datei ausgehend von dieser Position. Wenn Sie sie in den public -Ordner legen, so wie wir, dann betrachten Sie die relativen Pfade, die Sie angeben, immer von diesem Ordner aus. Nun m\u00fcssen wir diese Datei jeder HTML-Seite unserer Anwendung bekannt machen. In unserer Anwendung existieren zwei *.html -Dateien, die public/index.html und die public/help/index.html . In beide Datein tragen wir im <head> folgenden Eintrag ein: < link rel = \"manifest\" href = \"/manifest.json\" > Aber Achtung! : Die public/help/index.html liegt ja im Unterordner /help . Das bedeutet, dass von der Datei public/help/index.html aus gesehen, muss der help -Ordner erst verlassen werden, um die manifest.json -Datei zu erreichen. In die public/help/index.html schreiben wir also < link rel = \"manifest\" href = \"../manifest.json\" > Das hei\u00dft, der <head> -Bereich der public/index.html sieht dann wie folgt aus (und der von public/help/index.html sehr \u00e4hnlich - achten Sie auf den korrekten relativen Pfad!): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > IKT-PWA </ title > < link href = \"https://fonts.googleapis.com/css?family=Roboto:400,700\" rel = \"stylesheet\" > < link rel = \"stylesheet\" href = \"https://fonts.googleapis.com/icon?family=Material+Icons\" > < link rel = \"stylesheet\" href = \"https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css\" > < link rel = \"stylesheet\" href = \"/src/css/app.css\" > < link rel = \"stylesheet\" href = \"/src/css/feed.css\" > < link rel = \"manifest\" href = \"/manifest.json\" > </ head > In einer Single Page Application muss der Eintrag nur einmal erfolgen - in der single page, der index.html . M\u00f6gliche Eigenschaften in der manifest.json \u00b6 Eintr\u00e4ge in einer JSON-Datei sind key-value-Paare , d.h. ein Eintrag hat die folgende Form: \"property\" : value oder auf Deutsch \"eigenschaft\": wert . JSON-Dateien beginnen und enden immer mit einer geschweiften Klammer und die einzelnen key-value-Paare sind durch Komma getrennt. value kann selbst ein JSON sein oder ein Array oder ein String oder eine Zahl. Wir betrachten nun einige ausgew\u00e4hlte properties , die in einer manifest.json definiert werden k\u00f6nnen. Einen vollst\u00e4ndigen \u00dcberblick \u00fcber alle m\u00f6glichen Eigenschaften und deren Umsetzung in den einzelnen Browsern finden Sie hier . Eine kurze Einf\u00fchrung zu manifest.json finden Sie auch hier . Die Spezifikation f\u00fcr das Web-App-Manifest vom W3C finden Sie hier . name \u00b6 Mit der Eigenschaft name geben wir unserer Webanwendung eine Beschreibung. In der package.json haben wir unserer Anwendung bereits einen Namen gegeben, aber name aus der manifest.json beschreibt zum Beispiel den Namen der App auf dem Begr\u00fc\u00dfungsschrim, wie wir gleich sehen werden. Es ist ratsam, den Namen nicht l\u00e4nger als 45 Zeichen zu w\u00e4hlen (das ist die Begrenzung, die Google Chrome und Microsoft Edge f\u00fcr sich festgelegt haben). Wir sagen mal: \"name\" : \"HTW-Insta Erweiterung\" Die Eigenschaft name ist in der manifest.json verpflichtend, d.h. sie muss angegeben werden (au\u00dferdem noch version und manifest_version , alle anderen Eigenschaften sind optional.) short_name \u00b6 Der Wert von short_name wird z.B. verwendet als Name unserer App unter dem Icon auf dem Startbildschirm (falls der Name dort mit erscheint). Der short_name sollte nicht l\u00e4nger als 12 Zeichen sein. Ist kein short_name in der manifest.json angegeben, wird der Wert von name verwendet und, falls n\u00f6tig, einfach gek\u00fcrzt. \"short_name\" : \"HTW-Insta\" start_url \u00b6 Der Wert von start_url gibt den Pfad und die Datei an, die beim Starten unserer Anwendung geladen werden soll. In unserem Fall soll die /public/index.html geladen werden. Die manifest.json -Datei befindet sich im /public -ordner, also ist der Pfad zur Datei nur / .: \"start_url\" : \"/index.html\" Beachten Sie (nochmal): der Pfad ist immer relativ zur manifest.json . Anegenommen, der Wert von start_url ist ../start_point.html und die URL der manifest.json ist https://example.com/resources/manifest.json , dann w\u00fcrde die Anwendung unter https://example.com/start_point.html starten. display \u00b6 Der Wert von display gibt an, wie die Anwendung beim Start aussehen soll. Wir haben die Auswahl zwischen den folgenden Werten: \"fullscreen\" , \"standalone\" , \"minimal-ui\" N\u00e4here Erl\u00e4uterungen zu den einzelnen Werten finden Sie hier , aber am besten ist, Sie probieren die unterschiedlichen Werte einfach mal aus. \"display\" : \"standalone\" Bei \"standalone\" wird das Browser-fenster ausgeblendet, d.h. wir sehen die URL-Leiste nicht und auch nicht die Steuerelemente des Browsers. Die Anwendung wirkt wie eine native App. background_color \u00b6 Der Wert von background_color ist eine Farbe, die wir typischerweise in hexadezimaler Schreibweise angeben. Ob wir diese Farbe \u00fcberhaupt sehen, h\u00e4ngt davon ab, wie lange unsere Anwendung zum Laden bracuht, denn mit background_color geben wir die Hintergrundfarbe des Bildschirms an, der gezeigt wird, w\u00e4hrend die Anwendung l\u00e4dt. Meistens sieht man das nicht, weil der Ladevorgang so schnell ist. \"background_color\" : \"#76B900\" Wir w\u00e4hlen nat\u00fcrlich das HTW-Gr\u00fcn. theme_color \u00b6 Der Wert von theme_color ist eine Farbe, die z.B. die Farbe der Werkzeugleiste auf dem Smartphone bestimmt. \"theme_color\" : \"#FF5F00\" Wir w\u00e4hlen mal das HTW-Orange. description \u00b6 Wenn der Browser eine Beschreibung der App speichert, dann nutzt er den Wert von description , z.B. wenn Sie die App als Lesezeichen speichern. \"description\" : \"Eine tolle HTW-Insta-PWA\" lang \u00b6 Mit der lang uage-Eigeneschaft definieren Sie die Sprache Ihrer App. Der Wert ist der 4-buchstabige L\u00e4ndercode, z.B. \"en-US\", \"en-UK\" oder \"de-DE\". \"lang\" : \"de-DE\" Diese Eigenschaft wird vom Browser als Meta-Eigenschaft verwendet, kennen Sie schon aus den HTML-Dokumenten. dir \u00b6 Mit der dir ection-Eigeneschaft definieren Sie die Textrichtung Ihrer App. Die Werte sind einer der drei: \"ltr\" ( left to right ) \"rtl\" ( right to left ) \"auto\" Der Wert ist der 4-buchstabige L\u00e4ndercode, z.B. \"en-US\", \"en-UK\" oder \"de-DE\". \"dir\" : \"ltr\" orientation \u00b6 Mit der orientation -Eigeneschaft definieren Sie, in welchem Bildschirmmodus die App betrieben (geffnet) werden soll. Bei den Werten haben Sie die Wahl zwischen: \"any\" \"natural\" \"landscape\" \"landscape-primary\" \"landscape-secondary\" \"portrait\" \"portrait-primary\" \"portrait-secondary\" Die Angaben primary und secondary beziehen sich jeweils auf eine 180-Grad-Dreheung des Ger\u00e4tes. secondary \u00f6ffnet es also jeweils \"auf dem Kopf\". \"orientation\" : \"portrait-primary\" Die Web-App sollte aber so gebaut werden, dass sie sowohl im Portrait- als auch im Landscape-Modus gut bedient werden kann (responsive). icons \u00b6 Die icons -Eigenschaft enth\u00e4lt ein Array aus Icons, die als das Icon der App auf dem Startbildschirm verwendet werden k\u00f6nnen. Typischerweise gibt man hier mehrere an, die sich in ihrer Aufl\u00f6sung unterscheiden, um das geeignete Icon ausw\u00e4hlen zu k\u00f6nnen, das zur Aufl\u00f6sung des Ausgabeger\u00e4tes passt. Gute Dimensionen sind z.B. 48X48 Pixel bis hin zu 512x512 Pixel. Die Beschreibung eines Icons ist selbst ein JSON und enth\u00e4lt drei Eigenschaften: \"src\" (der Pafd zum Icon und die Datei) \"type\" (der Typ des Bildes, z.B. image/png ) \"sizes\" (die Gr\u00f6\u00dfe des Bildes in Pixeln) Der Browser sucht sich in Abh\u00e4ngigkeit von der Aufl\u00f6sung des Ausgabeger\u00e4tes das am besten geeignete Icon selbst\u00e4ndig aus. \"icons\" : [ { \"src\" : \"/src/images/icons/fiw48x48.png\" , \"type\" : \"image/png\" , \"sizes\" : \"48x48\" }, { \"src\" : \"/src/images/icons/fiw72x72.png\" , \"type\" : \"image/png\" , \"sizes\" : \"72x72\" }, { \"src\" : \"/src/images/icons/fiw96x96.png\" , \"type\" : \"image/png\" , \"sizes\" : \"96x96\" }, { \"src\" : \"/src/images/icons/fiw128x128.png\" , \"type\" : \"image/png\" , \"sizes\" : \"128x128\" }, { \"src\" : \"/src/images/icons/fiw256x256.png\" , \"type\" : \"image/png\" , \"sizes\" : \"256x256\" }, { \"src\" : \"/src/images/icons/fiw484x484.png\" , \"type\" : \"image/png\" , \"sizes\" : \"484x484\" } ] Auch hier sind wieder die korrekten relativen Pfade zu beachten. Es ist ziemlich m\u00fchsam, alle ben\u00f6tigten Icons und auch die obige JSON zu erzeugen. Zum Gl\u00fcck gibt es aber ein Werkzeug, das das f\u00fcr uns \u00fcbernimmt: pwa-asset-generator . Sie ben\u00f6tigen nur das Ausgangsicon in Originalgr\u00f6\u00dfe und alles andere wird f\u00fcr Sie erledgt. Bitte unbedingt verwenden, um sich m\u00fchsame Arbeit zu sparen! Testen der manifest.json \u00b6 Insgesamt sieht unsere manifest.json nun so aus: public/manifest.json { \"name\" : \"HTW-Insta Erweiterung\" , \"short_name\" : \"HTW-Insta\" , \"start_url\" : \"/index.html\" , \"id\" : \"/index.html\" , \"display\" : \"standalone\" , \"background_color\" : \"#76B900\" , \"description\" : \"Eine tolle HTW-Insta-PWA\" , \"lang\" : \"de-DE\" , \"dir\" : \"ltr\" , \"orientation\" : \"portrait-primary\" , \"icons\" : [ { \"src\" : \"/src/images/icons/fiw48x48.png\" , \"type\" : \"image/png\" , \"sizes\" : \"48x48\" }, { \"src\" : \"/src/images/icons/fiw72x72.png\" , \"type\" : \"image/png\" , \"sizes\" : \"72x72\" }, { \"src\" : \"/src/images/icons/fiw96x96.png\" , \"type\" : \"image/png\" , \"sizes\" : \"96x96\" }, { \"src\" : \"/src/images/icons/fiw128x128.png\" , \"type\" : \"image/png\" , \"sizes\" : \"128x128\" }, { \"src\" : \"/src/images/icons/fiw256x256.png\" , \"type\" : \"image/png\" , \"sizes\" : \"256x256\" }, { \"src\" : \"/src/images/icons/fiw484x484.png\" , \"type\" : \"image/png\" , \"sizes\" : \"484x484\" } ] } Wir rufen unsere Anwendung im Browser (Verwenden Sie Google Chrome!) auf und \u00f6ffnen au\u00dferdem die DevTools: W\u00e4hlen Sie f\u00fcr die Darstellung der App eine Mobilansicht aus ( ) und klicken Sie auf den Reiter Application in den DevTools. Klicken Sie in den DevTools unter dem Reiter Application im linken Application -Men\u00fc auf Manifest . Dort sehen Sie, dass Ihre Konfiguration korrekt eingelesen wird. Es sollte nur eine einzige Warnung erscheinen, dass wir (noch) keine service worker eingerichtet haben. Mit dem Web-Manifest ist unsere Anwendung installierbar - leider noch nicht ganz, da wir noch keinen Service worker haben und die Anwendung nicht offline verwendbar ist. Die Installierbarkeit l\u00e4sst sich aber trotzdem testen, dazu m\u00fcssen wir die Anwendung jedoch simulieren. Diese Schritte sind unter Optional - f\u00fcr Interessierte beschrieben. Sie m\u00fcssen das aber nicht machen, Sie k\u00f6nnen stattdessen auch einfach einen ganz einfachen Service worker implementieren. Dazu erstellen wir eine public/sw.js und binden diese wie folgt in die public/index.html ein (siehe auch Einf\u00fchrung ): < script > // Check that service workers are supported if ( 'serviceWorker' in navigator ) { // Use the window load event to keep the page load performant window . addEventListener ( 'load' , () => { navigator . serviceWorker . register ( '/sw.js' ); }); } </ script > und in die public/sw.js schreiben wir: importScripts ( 'https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js' ); workbox . routing . registerRoute ( ({ request }) => request . destination === 'image' , new workbox . strategies . NetworkFirst () // NetworkFirst() vs CacheFirst() ) Unsere Anwendung simuliert nun eine Offline-F\u00e4higkeit und ist nun installierbar. Wenn wir die Anwendung mit npm start starten, dann erscheint: Sie k\u00f6nnen die Anwendung \u00fcber das Icon installieren oder auch \u00fcber das Options-Men\u00fc (die drei vertikalen Punkte neben der URL-Leiste). Es erscheint ein Confirmation-Men\u00fc: Nach der Installation der App ist diese (unter Mac) einerseits unter Programme/Chrome-Apps zu finden, aber z.B. auch im Launchpad. Das beforeinstallprompt -Ereignis \u00b6 Das BeforeInstallPromptEvent wird ausgel\u00f6st, wenn Ihre Anwendung installierbar ist und Sie diese das erste Mal ausf\u00fchren. Es wird ausgel\u00f6st, um Ihre Anwendung zu installieren. Ein typisches Vorgehen f\u00fcr die Behandlung des Ereignisses schl\u00e4gt vor, die Anwendung nicht sofort, d.h. nicht durch die Behandlung des beforeinstallprompt -Ereignisses, zu installieren, sondern zun\u00e4chst abzuwarten, ob die Anwendung auch tats\u00e4chlich so genutzt wird, dass sich eine Installation lohnt. F\u00fcr unsere Anwendung k\u00f6nnte das z.B. bedeuten, dass diese nicht beim ersten Aufruf installiert wird, sondern dass gewartet wird, bis die Nutzerin zum ersten Mal den + -Button klickt. Ein solches typisches Vorgehen ist z.B. hier beschrieben oder hier . Wir zeigen hier einmal die Auswertung dieses Ereignisses, indem wir das Installieren durch einen Klick auf einen Installationsbutton erledigen lassen. Wie gesagt, die Behandlung des Klick-Ereignisses dieses Installationsbuttons geh\u00f6rt eigentlich woanders hin, je nachdem, was in der Anwendung gew\u00fcnscht ist, also wann die Anwendung tats\u00e4chlich installiert werden soll. Wir f\u00fcgen zun\u00e4chst den Button in die index.html ein: < button id = \"install\" style = \"display:none;\" class = \"mdl-button mdl-js-button mdl-button--raised mdl-button--accent\" > Installieren </ button > Au\u00dferdem f\u00fcgen wir folgendes Script in die index.html hinzu: < script > const installButton = document . getElementById ( 'install' ); console . log ( 'installButton' , installButton ) let deferredPrompt ; window . addEventListener ( 'beforeinstallprompt' , evt => { console . log ( evt . platforms ); // e.g., [\"web\", \"android\", \"windows\"] evt . preventDefault (); deferredPrompt = evt ; installButton . style . display = 'block' ; }) installButton . addEventListener ( 'click' , async () => { await deferredPrompt . prompt (); const choiceResult = await deferredPrompt . userChoice ; console . log ( choiceResult . outcome ); }); window . addEventListener ( 'appinstalled' , () => { installButton . style . display = 'none' ; }) < /script> Der Button ist zun\u00e4chst auf display:none gestellt, also nicht sichtbar. Wird das beforeinstallprompt -Ereignis ausgel\u00f6st, wird zun\u00e4chst der \"normale\" Ablauf der Ereignisbehandlung ausgesetzt ( preventDefault() ). Stattdessen wird diese Aufforderung in deferredPrompt zwischengespeichert. Der Button wird auf sichtbar gesetzt ( style.display = 'block' ). Durch Klick auf den Button wird nun die Aufforderung, die in deferredPrompt zwischengespeichert ist, mithilfe von prompt() angezeigt. Klicken wir nun auf den Button, erscheint die Aufforderung. Entscheiden wir uns daf\u00fcr, die App zu installieren, wird diese installiert, was wiederum das Ereignis appinstalled aufruft. Als Ereignisnehandlung dieses Ereignisses k\u00f6nnen wir den Button wieder auf unsichtbar setzen. Beachten Sie, dass das BeforeInstallPromptEvent nicht von allen Browsern unterst\u00fctzt wird. Hier die aktuelle \u00dcbersicht aus BeforeInstallPromptEvent : Optional - f\u00fcr Interessierte \u00b6 Um die Funktionsweise des Web-App-Manifestes tats\u00e4chlich zu testen, ben\u00f6tigen wir jedoch ein Smartphone (oder Tablet). Wir wollen ein solches emulieren (ein Android-Smartphone) und starten dazu Android Studio . Wenn wir Android Studio \u00f6ffnen, w\u00e4hlen wir zun\u00e4chst + Create New Project . Durch die folgenden Vorschl\u00e4ge k\u00f6nnen wir einfach stets mit Next und dann mit Finish navigieren, ohne irgendetwas zu \u00e4ndern. Wir sind gar nicht am Projekt interessiert, sondern nur am AVD Manager ( Android Virtual Device Manaager ), den wir unter dem Men\u00fcpunkt Tools finden. Nach dem \u00d6ffnen des AVD-Managers haben Sie die M\u00f6glichkeit, weitere Android-Phones zur Liste Ihrer virtuellen Ger\u00e4te hinzuzuf\u00fcgen. Das k\u00f6nnen Sie ruhig machen, um ger\u00e4te mit verschiedenen Aufl\u00f6sungen ausprobieren zu k\u00f6nnen. W\u00e4hlen Sie dann ein Ger\u00e4t Ihrer Wahl und klicken Sie f\u00fcr das Ger\u00e4t unter der Spalte Actions auf den Play-Button: Das dauert dann eine ganze Weile, aber am Ende erscheint ein Smartphone auf Ihrem Bildschirm: Auf diesem Android-Ger\u00e4t ist Google Chrome verf\u00fcgbar. Starten Sie Google Chrome dort durch Mausklick und geben Sie als URL 10.0.2.2.:8080 ein. Unsere Webanwendung wird ge\u00f6ffnet: Klicken Sie jetzt auf die drei vertikalen Punkte neben der URL-Leiste und w\u00e4hlen Sie Add to Home screen : Es wird uns eines unserer Icons angeboten und der unter name gew\u00e4hlte Name: Klicken Sie Add und dann Add automatically . Das Icon erscheint auf dem Homescreen (Startbildschirm). Eventuell m\u00fcssen Sie den Browser zuvor schlie\u00dfen. Klicken Sie auf das Icon, um unsere Anwendung zu starten. Sie sehen kurz den Splashscreen mit der von uns gew\u00e4hlten Hintergrundfarbe HTW-Gr\u00fcn. Beachten Sie auch, dass um unsere Anwendung herum kein Browser-Fenster zu sehen ist. Sie l\u00e4uft standalone (nat\u00fcrlich im Browser, aber der ist nicht zu sehen). Das sieht man insbesondere, wenn man sich alle ge\u00f6ffneten Anwendungen anschaut: Sobald wir f\u00fcr unserer PWA auch noch einen service worker registriert haben, kommen wir nochmal hierher zur\u00fcck und werden daf\u00fcr sorgen, dass der Browser uns sogar fragt, ob wir ein Icon auf dem Startbildschirm ablegen wollen. Erstaz f\u00fcr manifest.json f\u00fcr Safari \u00b6 Leider unterst\u00fctzt Safari (Apple) das manifest.json (noch) nicht, obwohl es eine Spezifikation des W3C ist. \u00dcber die Browser-Untert\u00fctzung f\u00fcr das Web-App-Manifest k\u00f6nnen Sie sich z.B. hier informieren. Die Seite enth\u00e4lt auch eine gute Zusammenfassung aller Eigenschaften des Web-App-Manifestes. Es lohnt sich auch ein Blick hierauf . Um f\u00fcr Safari eine \u00e4hnliche Funktionalit\u00e4t zur Verf\u00fcgung zu stellen, wie das Web-App-Manifest, m\u00fcssen in den HTML-Dateien unserer Anwendung ein paar Meta-Angaben erfolgen: 1 2 3 4 5 6 7 8 9 10 11 12 < meta name = \"apple-mobile-web-app-capable\" content = \"yes\" > < meta name = \"apple-mobile-web-app-status-bar-style\" content = \"black\" > < meta name = \"apple-mobile-web-app-title\" content = \"HTW-Insta\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw57x57.png\" sizes = \"57x57\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw60x60.png\" sizes = \"60x60\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw72x72.png\" sizes = \"72x72\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw76x76.png\" sizes = \"76x76\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw114x114.png\" sizes = \"114x114\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw120x120.png\" sizes = \"120x120\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw144x144.png\" sizes = \"144x144\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw152x152.png\" sizes = \"152x152\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw180x180.png\" sizes = \"180x180\" > So wirklich klar ist es allerdings nicht, inwieweit Apple tats\u00e4chlich PWAs unterst\u00fctzt und unterst\u00fctzen m\u00f6chte. Es scheint eher so, dass Apple volle Kontrolle dar\u00fcber behalten m\u00f6chte, welche Apps auf iPhones oder iOS-Tablets laufen d\u00fcrfen, n\u00e4mlich solche, die (nur) \u00fcber den App-Store verf\u00fcgbar sind. Siehe dazu z.B. hier und hier . Sollten Sie ein iPhone haben und sollte Ihre Anwendung mithilfe von npm start ausgef\u00fchrt sein, so k\u00f6nnen Sie allerdings mal http://141.45.57.28:8080 in Ihren Browser im Handy eingeben. Es muss nichts weiter installiert werden. Sie k\u00f6nnen aber kein Icon auf den Startbildschirm ablegen :-(. Eine weitere Unterst\u00fctzung f\u00fcr iOS Safari bietet PWACompat . Sie m\u00fcssten dann entweder in die index.html unterhalb des Einbindens der manifest.json noch < script async src = \"https://unpkg.com/pwacompat\" crossorigin = \"anonymous\" ></ script > statisch hinzuf\u00fcgen oder dynamisch f\u00fcr den folgenden Fall: < script type = \"module\" > // detect iOS Safari if (( 'standalone' in navigator ) && ( ! navigator . standalone )) { import ( 'https://unpkg.com/pwacompat' ); } </ script > Success Wir haben unsere Webanwendung installierbar gemacht. Zumindest auf Android-Ger\u00e4ten. Dies geschieht mithilfe der Datei manifest.json , die wir in alle html -Seiten unserer Anwendung einbinden. Wir haben viele Eigenschaften kennengelernt, die wir in diesem Web-App-Manifest definieren k\u00f6nnen. Mithilfe des Emulators von Android Studio k\u00f6nnen wir die Anwendung des Web-App-Manifestes auf Android-Ger\u00e4ten ausprobieren. Wir schauen uns nun einen weiteren zentralen Funktionsblock an, n\u00e4mlich Service Worker .","title":"Manifest"},{"location":"manifest/#web-app-manifest","text":"Das Web-App-Manifest ist zun\u00e4chst einmal eine Datei, n\u00e4mlich manifest.json . Sie wird also in der JavaScript Object Notation (JSON) geschrieben. Diese Datei dient als Information f\u00fcr den Browser. Sie wird also vom Browser ausgelesen. Beispielsweise kann in der manifest.json vereinbart werden, dass sich die Webanwendung selbst auf dem Startbildschirm Ihres Mobilger\u00e4tes installiert. Dann gen\u00fcgt ein Klick auf das Icon auf dem Startbildschirm und die Webanwendung wird durch den Browser ge\u00f6ffnet. Somit h\u00e4tten wir schonmal eine wesentliche Gemeinsamkeit zu einer nativen App geschaffen, welche ja auch durch ein Klick auf ein Icon auf dem Startbildschirm gestartet werden k\u00f6nnen. Wir lernen kennen, wie wir ein solches Manifest unserer PWA hinzuf\u00fcgen, wie es konfiguriert werden kann und wie wir die Auswirkungen eines solchen Manifestes auf mobilen Ger\u00e4ten sehen k\u00f6nnen.","title":"Web-App-Manifest"},{"location":"manifest/#installierbar","text":"Mithilfe eines Web-App-Manifestes machen wir unsere Webanwendung installierbar auf einem mobilen Ger\u00e4t. Die Anwendung muss nicht einem App-Store hinzugef\u00fcgt werden, sondern wird einfach \u00fcber das Web durch einen Browser geladen. Normalerweise kann eine Webanwendung ja nur dadurch gestartet werden, dass ihre URL in den Browser eingetragen wird (oder Sie haben ein lesezeichen auf die Webanwendung in Ihrem Browser gesetzt). Nun wollen wir auf den Startbildschirm des Smartphones ein Icon setzen (genau wie f\u00fcr native Apps) und dar\u00fcber die Anwendung starten. Daf\u00fcr f\u00fcgen wir im Projektordner in dem Ordner /public die Datei manifest.json hinzu: Diese Datei sollte genau so hei\u00dfen und es ist g\u00fcnstig, sie in den /public -Ordner zu legen. Achten Sie darauf, wohin Sie die Datei legen. Wenn Sie sie direkt in den Projektordner legen, dann gelten alle Pfadangaben in dieser Datei ausgehend von dieser Position. Wenn Sie sie in den public -Ordner legen, so wie wir, dann betrachten Sie die relativen Pfade, die Sie angeben, immer von diesem Ordner aus. Nun m\u00fcssen wir diese Datei jeder HTML-Seite unserer Anwendung bekannt machen. In unserer Anwendung existieren zwei *.html -Dateien, die public/index.html und die public/help/index.html . In beide Datein tragen wir im <head> folgenden Eintrag ein: < link rel = \"manifest\" href = \"/manifest.json\" > Aber Achtung! : Die public/help/index.html liegt ja im Unterordner /help . Das bedeutet, dass von der Datei public/help/index.html aus gesehen, muss der help -Ordner erst verlassen werden, um die manifest.json -Datei zu erreichen. In die public/help/index.html schreiben wir also < link rel = \"manifest\" href = \"../manifest.json\" > Das hei\u00dft, der <head> -Bereich der public/index.html sieht dann wie folgt aus (und der von public/help/index.html sehr \u00e4hnlich - achten Sie auf den korrekten relativen Pfad!): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > IKT-PWA </ title > < link href = \"https://fonts.googleapis.com/css?family=Roboto:400,700\" rel = \"stylesheet\" > < link rel = \"stylesheet\" href = \"https://fonts.googleapis.com/icon?family=Material+Icons\" > < link rel = \"stylesheet\" href = \"https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css\" > < link rel = \"stylesheet\" href = \"/src/css/app.css\" > < link rel = \"stylesheet\" href = \"/src/css/feed.css\" > < link rel = \"manifest\" href = \"/manifest.json\" > </ head > In einer Single Page Application muss der Eintrag nur einmal erfolgen - in der single page, der index.html .","title":"Installierbar"},{"location":"manifest/#mogliche-eigenschaften-in-der-manifestjson","text":"Eintr\u00e4ge in einer JSON-Datei sind key-value-Paare , d.h. ein Eintrag hat die folgende Form: \"property\" : value oder auf Deutsch \"eigenschaft\": wert . JSON-Dateien beginnen und enden immer mit einer geschweiften Klammer und die einzelnen key-value-Paare sind durch Komma getrennt. value kann selbst ein JSON sein oder ein Array oder ein String oder eine Zahl. Wir betrachten nun einige ausgew\u00e4hlte properties , die in einer manifest.json definiert werden k\u00f6nnen. Einen vollst\u00e4ndigen \u00dcberblick \u00fcber alle m\u00f6glichen Eigenschaften und deren Umsetzung in den einzelnen Browsern finden Sie hier . Eine kurze Einf\u00fchrung zu manifest.json finden Sie auch hier . Die Spezifikation f\u00fcr das Web-App-Manifest vom W3C finden Sie hier .","title":"M\u00f6gliche Eigenschaften in der manifest.json"},{"location":"manifest/#name","text":"Mit der Eigenschaft name geben wir unserer Webanwendung eine Beschreibung. In der package.json haben wir unserer Anwendung bereits einen Namen gegeben, aber name aus der manifest.json beschreibt zum Beispiel den Namen der App auf dem Begr\u00fc\u00dfungsschrim, wie wir gleich sehen werden. Es ist ratsam, den Namen nicht l\u00e4nger als 45 Zeichen zu w\u00e4hlen (das ist die Begrenzung, die Google Chrome und Microsoft Edge f\u00fcr sich festgelegt haben). Wir sagen mal: \"name\" : \"HTW-Insta Erweiterung\" Die Eigenschaft name ist in der manifest.json verpflichtend, d.h. sie muss angegeben werden (au\u00dferdem noch version und manifest_version , alle anderen Eigenschaften sind optional.)","title":"name"},{"location":"manifest/#short_name","text":"Der Wert von short_name wird z.B. verwendet als Name unserer App unter dem Icon auf dem Startbildschirm (falls der Name dort mit erscheint). Der short_name sollte nicht l\u00e4nger als 12 Zeichen sein. Ist kein short_name in der manifest.json angegeben, wird der Wert von name verwendet und, falls n\u00f6tig, einfach gek\u00fcrzt. \"short_name\" : \"HTW-Insta\"","title":"short_name"},{"location":"manifest/#start_url","text":"Der Wert von start_url gibt den Pfad und die Datei an, die beim Starten unserer Anwendung geladen werden soll. In unserem Fall soll die /public/index.html geladen werden. Die manifest.json -Datei befindet sich im /public -ordner, also ist der Pfad zur Datei nur / .: \"start_url\" : \"/index.html\" Beachten Sie (nochmal): der Pfad ist immer relativ zur manifest.json . Anegenommen, der Wert von start_url ist ../start_point.html und die URL der manifest.json ist https://example.com/resources/manifest.json , dann w\u00fcrde die Anwendung unter https://example.com/start_point.html starten.","title":"start_url"},{"location":"manifest/#display","text":"Der Wert von display gibt an, wie die Anwendung beim Start aussehen soll. Wir haben die Auswahl zwischen den folgenden Werten: \"fullscreen\" , \"standalone\" , \"minimal-ui\" N\u00e4here Erl\u00e4uterungen zu den einzelnen Werten finden Sie hier , aber am besten ist, Sie probieren die unterschiedlichen Werte einfach mal aus. \"display\" : \"standalone\" Bei \"standalone\" wird das Browser-fenster ausgeblendet, d.h. wir sehen die URL-Leiste nicht und auch nicht die Steuerelemente des Browsers. Die Anwendung wirkt wie eine native App.","title":"display"},{"location":"manifest/#background_color","text":"Der Wert von background_color ist eine Farbe, die wir typischerweise in hexadezimaler Schreibweise angeben. Ob wir diese Farbe \u00fcberhaupt sehen, h\u00e4ngt davon ab, wie lange unsere Anwendung zum Laden bracuht, denn mit background_color geben wir die Hintergrundfarbe des Bildschirms an, der gezeigt wird, w\u00e4hrend die Anwendung l\u00e4dt. Meistens sieht man das nicht, weil der Ladevorgang so schnell ist. \"background_color\" : \"#76B900\" Wir w\u00e4hlen nat\u00fcrlich das HTW-Gr\u00fcn.","title":"background_color"},{"location":"manifest/#theme_color","text":"Der Wert von theme_color ist eine Farbe, die z.B. die Farbe der Werkzeugleiste auf dem Smartphone bestimmt. \"theme_color\" : \"#FF5F00\" Wir w\u00e4hlen mal das HTW-Orange.","title":"theme_color"},{"location":"manifest/#description","text":"Wenn der Browser eine Beschreibung der App speichert, dann nutzt er den Wert von description , z.B. wenn Sie die App als Lesezeichen speichern. \"description\" : \"Eine tolle HTW-Insta-PWA\"","title":"description"},{"location":"manifest/#lang","text":"Mit der lang uage-Eigeneschaft definieren Sie die Sprache Ihrer App. Der Wert ist der 4-buchstabige L\u00e4ndercode, z.B. \"en-US\", \"en-UK\" oder \"de-DE\". \"lang\" : \"de-DE\" Diese Eigenschaft wird vom Browser als Meta-Eigenschaft verwendet, kennen Sie schon aus den HTML-Dokumenten.","title":"lang"},{"location":"manifest/#dir","text":"Mit der dir ection-Eigeneschaft definieren Sie die Textrichtung Ihrer App. Die Werte sind einer der drei: \"ltr\" ( left to right ) \"rtl\" ( right to left ) \"auto\" Der Wert ist der 4-buchstabige L\u00e4ndercode, z.B. \"en-US\", \"en-UK\" oder \"de-DE\". \"dir\" : \"ltr\"","title":"dir"},{"location":"manifest/#orientation","text":"Mit der orientation -Eigeneschaft definieren Sie, in welchem Bildschirmmodus die App betrieben (geffnet) werden soll. Bei den Werten haben Sie die Wahl zwischen: \"any\" \"natural\" \"landscape\" \"landscape-primary\" \"landscape-secondary\" \"portrait\" \"portrait-primary\" \"portrait-secondary\" Die Angaben primary und secondary beziehen sich jeweils auf eine 180-Grad-Dreheung des Ger\u00e4tes. secondary \u00f6ffnet es also jeweils \"auf dem Kopf\". \"orientation\" : \"portrait-primary\" Die Web-App sollte aber so gebaut werden, dass sie sowohl im Portrait- als auch im Landscape-Modus gut bedient werden kann (responsive).","title":"orientation"},{"location":"manifest/#icons","text":"Die icons -Eigenschaft enth\u00e4lt ein Array aus Icons, die als das Icon der App auf dem Startbildschirm verwendet werden k\u00f6nnen. Typischerweise gibt man hier mehrere an, die sich in ihrer Aufl\u00f6sung unterscheiden, um das geeignete Icon ausw\u00e4hlen zu k\u00f6nnen, das zur Aufl\u00f6sung des Ausgabeger\u00e4tes passt. Gute Dimensionen sind z.B. 48X48 Pixel bis hin zu 512x512 Pixel. Die Beschreibung eines Icons ist selbst ein JSON und enth\u00e4lt drei Eigenschaften: \"src\" (der Pafd zum Icon und die Datei) \"type\" (der Typ des Bildes, z.B. image/png ) \"sizes\" (die Gr\u00f6\u00dfe des Bildes in Pixeln) Der Browser sucht sich in Abh\u00e4ngigkeit von der Aufl\u00f6sung des Ausgabeger\u00e4tes das am besten geeignete Icon selbst\u00e4ndig aus. \"icons\" : [ { \"src\" : \"/src/images/icons/fiw48x48.png\" , \"type\" : \"image/png\" , \"sizes\" : \"48x48\" }, { \"src\" : \"/src/images/icons/fiw72x72.png\" , \"type\" : \"image/png\" , \"sizes\" : \"72x72\" }, { \"src\" : \"/src/images/icons/fiw96x96.png\" , \"type\" : \"image/png\" , \"sizes\" : \"96x96\" }, { \"src\" : \"/src/images/icons/fiw128x128.png\" , \"type\" : \"image/png\" , \"sizes\" : \"128x128\" }, { \"src\" : \"/src/images/icons/fiw256x256.png\" , \"type\" : \"image/png\" , \"sizes\" : \"256x256\" }, { \"src\" : \"/src/images/icons/fiw484x484.png\" , \"type\" : \"image/png\" , \"sizes\" : \"484x484\" } ] Auch hier sind wieder die korrekten relativen Pfade zu beachten. Es ist ziemlich m\u00fchsam, alle ben\u00f6tigten Icons und auch die obige JSON zu erzeugen. Zum Gl\u00fcck gibt es aber ein Werkzeug, das das f\u00fcr uns \u00fcbernimmt: pwa-asset-generator . Sie ben\u00f6tigen nur das Ausgangsicon in Originalgr\u00f6\u00dfe und alles andere wird f\u00fcr Sie erledgt. Bitte unbedingt verwenden, um sich m\u00fchsame Arbeit zu sparen!","title":"icons"},{"location":"manifest/#testen-der-manifestjson","text":"Insgesamt sieht unsere manifest.json nun so aus: public/manifest.json { \"name\" : \"HTW-Insta Erweiterung\" , \"short_name\" : \"HTW-Insta\" , \"start_url\" : \"/index.html\" , \"id\" : \"/index.html\" , \"display\" : \"standalone\" , \"background_color\" : \"#76B900\" , \"description\" : \"Eine tolle HTW-Insta-PWA\" , \"lang\" : \"de-DE\" , \"dir\" : \"ltr\" , \"orientation\" : \"portrait-primary\" , \"icons\" : [ { \"src\" : \"/src/images/icons/fiw48x48.png\" , \"type\" : \"image/png\" , \"sizes\" : \"48x48\" }, { \"src\" : \"/src/images/icons/fiw72x72.png\" , \"type\" : \"image/png\" , \"sizes\" : \"72x72\" }, { \"src\" : \"/src/images/icons/fiw96x96.png\" , \"type\" : \"image/png\" , \"sizes\" : \"96x96\" }, { \"src\" : \"/src/images/icons/fiw128x128.png\" , \"type\" : \"image/png\" , \"sizes\" : \"128x128\" }, { \"src\" : \"/src/images/icons/fiw256x256.png\" , \"type\" : \"image/png\" , \"sizes\" : \"256x256\" }, { \"src\" : \"/src/images/icons/fiw484x484.png\" , \"type\" : \"image/png\" , \"sizes\" : \"484x484\" } ] } Wir rufen unsere Anwendung im Browser (Verwenden Sie Google Chrome!) auf und \u00f6ffnen au\u00dferdem die DevTools: W\u00e4hlen Sie f\u00fcr die Darstellung der App eine Mobilansicht aus ( ) und klicken Sie auf den Reiter Application in den DevTools. Klicken Sie in den DevTools unter dem Reiter Application im linken Application -Men\u00fc auf Manifest . Dort sehen Sie, dass Ihre Konfiguration korrekt eingelesen wird. Es sollte nur eine einzige Warnung erscheinen, dass wir (noch) keine service worker eingerichtet haben. Mit dem Web-Manifest ist unsere Anwendung installierbar - leider noch nicht ganz, da wir noch keinen Service worker haben und die Anwendung nicht offline verwendbar ist. Die Installierbarkeit l\u00e4sst sich aber trotzdem testen, dazu m\u00fcssen wir die Anwendung jedoch simulieren. Diese Schritte sind unter Optional - f\u00fcr Interessierte beschrieben. Sie m\u00fcssen das aber nicht machen, Sie k\u00f6nnen stattdessen auch einfach einen ganz einfachen Service worker implementieren. Dazu erstellen wir eine public/sw.js und binden diese wie folgt in die public/index.html ein (siehe auch Einf\u00fchrung ): < script > // Check that service workers are supported if ( 'serviceWorker' in navigator ) { // Use the window load event to keep the page load performant window . addEventListener ( 'load' , () => { navigator . serviceWorker . register ( '/sw.js' ); }); } </ script > und in die public/sw.js schreiben wir: importScripts ( 'https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js' ); workbox . routing . registerRoute ( ({ request }) => request . destination === 'image' , new workbox . strategies . NetworkFirst () // NetworkFirst() vs CacheFirst() ) Unsere Anwendung simuliert nun eine Offline-F\u00e4higkeit und ist nun installierbar. Wenn wir die Anwendung mit npm start starten, dann erscheint: Sie k\u00f6nnen die Anwendung \u00fcber das Icon installieren oder auch \u00fcber das Options-Men\u00fc (die drei vertikalen Punkte neben der URL-Leiste). Es erscheint ein Confirmation-Men\u00fc: Nach der Installation der App ist diese (unter Mac) einerseits unter Programme/Chrome-Apps zu finden, aber z.B. auch im Launchpad.","title":"Testen der manifest.json"},{"location":"manifest/#das-beforeinstallprompt-ereignis","text":"Das BeforeInstallPromptEvent wird ausgel\u00f6st, wenn Ihre Anwendung installierbar ist und Sie diese das erste Mal ausf\u00fchren. Es wird ausgel\u00f6st, um Ihre Anwendung zu installieren. Ein typisches Vorgehen f\u00fcr die Behandlung des Ereignisses schl\u00e4gt vor, die Anwendung nicht sofort, d.h. nicht durch die Behandlung des beforeinstallprompt -Ereignisses, zu installieren, sondern zun\u00e4chst abzuwarten, ob die Anwendung auch tats\u00e4chlich so genutzt wird, dass sich eine Installation lohnt. F\u00fcr unsere Anwendung k\u00f6nnte das z.B. bedeuten, dass diese nicht beim ersten Aufruf installiert wird, sondern dass gewartet wird, bis die Nutzerin zum ersten Mal den + -Button klickt. Ein solches typisches Vorgehen ist z.B. hier beschrieben oder hier . Wir zeigen hier einmal die Auswertung dieses Ereignisses, indem wir das Installieren durch einen Klick auf einen Installationsbutton erledigen lassen. Wie gesagt, die Behandlung des Klick-Ereignisses dieses Installationsbuttons geh\u00f6rt eigentlich woanders hin, je nachdem, was in der Anwendung gew\u00fcnscht ist, also wann die Anwendung tats\u00e4chlich installiert werden soll. Wir f\u00fcgen zun\u00e4chst den Button in die index.html ein: < button id = \"install\" style = \"display:none;\" class = \"mdl-button mdl-js-button mdl-button--raised mdl-button--accent\" > Installieren </ button > Au\u00dferdem f\u00fcgen wir folgendes Script in die index.html hinzu: < script > const installButton = document . getElementById ( 'install' ); console . log ( 'installButton' , installButton ) let deferredPrompt ; window . addEventListener ( 'beforeinstallprompt' , evt => { console . log ( evt . platforms ); // e.g., [\"web\", \"android\", \"windows\"] evt . preventDefault (); deferredPrompt = evt ; installButton . style . display = 'block' ; }) installButton . addEventListener ( 'click' , async () => { await deferredPrompt . prompt (); const choiceResult = await deferredPrompt . userChoice ; console . log ( choiceResult . outcome ); }); window . addEventListener ( 'appinstalled' , () => { installButton . style . display = 'none' ; }) < /script> Der Button ist zun\u00e4chst auf display:none gestellt, also nicht sichtbar. Wird das beforeinstallprompt -Ereignis ausgel\u00f6st, wird zun\u00e4chst der \"normale\" Ablauf der Ereignisbehandlung ausgesetzt ( preventDefault() ). Stattdessen wird diese Aufforderung in deferredPrompt zwischengespeichert. Der Button wird auf sichtbar gesetzt ( style.display = 'block' ). Durch Klick auf den Button wird nun die Aufforderung, die in deferredPrompt zwischengespeichert ist, mithilfe von prompt() angezeigt. Klicken wir nun auf den Button, erscheint die Aufforderung. Entscheiden wir uns daf\u00fcr, die App zu installieren, wird diese installiert, was wiederum das Ereignis appinstalled aufruft. Als Ereignisnehandlung dieses Ereignisses k\u00f6nnen wir den Button wieder auf unsichtbar setzen. Beachten Sie, dass das BeforeInstallPromptEvent nicht von allen Browsern unterst\u00fctzt wird. Hier die aktuelle \u00dcbersicht aus BeforeInstallPromptEvent :","title":"Das beforeinstallprompt-Ereignis"},{"location":"manifest/#optional-fur-interessierte","text":"Um die Funktionsweise des Web-App-Manifestes tats\u00e4chlich zu testen, ben\u00f6tigen wir jedoch ein Smartphone (oder Tablet). Wir wollen ein solches emulieren (ein Android-Smartphone) und starten dazu Android Studio . Wenn wir Android Studio \u00f6ffnen, w\u00e4hlen wir zun\u00e4chst + Create New Project . Durch die folgenden Vorschl\u00e4ge k\u00f6nnen wir einfach stets mit Next und dann mit Finish navigieren, ohne irgendetwas zu \u00e4ndern. Wir sind gar nicht am Projekt interessiert, sondern nur am AVD Manager ( Android Virtual Device Manaager ), den wir unter dem Men\u00fcpunkt Tools finden. Nach dem \u00d6ffnen des AVD-Managers haben Sie die M\u00f6glichkeit, weitere Android-Phones zur Liste Ihrer virtuellen Ger\u00e4te hinzuzuf\u00fcgen. Das k\u00f6nnen Sie ruhig machen, um ger\u00e4te mit verschiedenen Aufl\u00f6sungen ausprobieren zu k\u00f6nnen. W\u00e4hlen Sie dann ein Ger\u00e4t Ihrer Wahl und klicken Sie f\u00fcr das Ger\u00e4t unter der Spalte Actions auf den Play-Button: Das dauert dann eine ganze Weile, aber am Ende erscheint ein Smartphone auf Ihrem Bildschirm: Auf diesem Android-Ger\u00e4t ist Google Chrome verf\u00fcgbar. Starten Sie Google Chrome dort durch Mausklick und geben Sie als URL 10.0.2.2.:8080 ein. Unsere Webanwendung wird ge\u00f6ffnet: Klicken Sie jetzt auf die drei vertikalen Punkte neben der URL-Leiste und w\u00e4hlen Sie Add to Home screen : Es wird uns eines unserer Icons angeboten und der unter name gew\u00e4hlte Name: Klicken Sie Add und dann Add automatically . Das Icon erscheint auf dem Homescreen (Startbildschirm). Eventuell m\u00fcssen Sie den Browser zuvor schlie\u00dfen. Klicken Sie auf das Icon, um unsere Anwendung zu starten. Sie sehen kurz den Splashscreen mit der von uns gew\u00e4hlten Hintergrundfarbe HTW-Gr\u00fcn. Beachten Sie auch, dass um unsere Anwendung herum kein Browser-Fenster zu sehen ist. Sie l\u00e4uft standalone (nat\u00fcrlich im Browser, aber der ist nicht zu sehen). Das sieht man insbesondere, wenn man sich alle ge\u00f6ffneten Anwendungen anschaut: Sobald wir f\u00fcr unserer PWA auch noch einen service worker registriert haben, kommen wir nochmal hierher zur\u00fcck und werden daf\u00fcr sorgen, dass der Browser uns sogar fragt, ob wir ein Icon auf dem Startbildschirm ablegen wollen.","title":"Optional - f\u00fcr Interessierte"},{"location":"manifest/#erstaz-fur-manifestjson-fur-safari","text":"Leider unterst\u00fctzt Safari (Apple) das manifest.json (noch) nicht, obwohl es eine Spezifikation des W3C ist. \u00dcber die Browser-Untert\u00fctzung f\u00fcr das Web-App-Manifest k\u00f6nnen Sie sich z.B. hier informieren. Die Seite enth\u00e4lt auch eine gute Zusammenfassung aller Eigenschaften des Web-App-Manifestes. Es lohnt sich auch ein Blick hierauf . Um f\u00fcr Safari eine \u00e4hnliche Funktionalit\u00e4t zur Verf\u00fcgung zu stellen, wie das Web-App-Manifest, m\u00fcssen in den HTML-Dateien unserer Anwendung ein paar Meta-Angaben erfolgen: 1 2 3 4 5 6 7 8 9 10 11 12 < meta name = \"apple-mobile-web-app-capable\" content = \"yes\" > < meta name = \"apple-mobile-web-app-status-bar-style\" content = \"black\" > < meta name = \"apple-mobile-web-app-title\" content = \"HTW-Insta\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw57x57.png\" sizes = \"57x57\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw60x60.png\" sizes = \"60x60\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw72x72.png\" sizes = \"72x72\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw76x76.png\" sizes = \"76x76\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw114x114.png\" sizes = \"114x114\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw120x120.png\" sizes = \"120x120\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw144x144.png\" sizes = \"144x144\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw152x152.png\" sizes = \"152x152\" > < link rel = \"apple-touch-icon\" href = \"/src/images/icons/ios-fiw180x180.png\" sizes = \"180x180\" > So wirklich klar ist es allerdings nicht, inwieweit Apple tats\u00e4chlich PWAs unterst\u00fctzt und unterst\u00fctzen m\u00f6chte. Es scheint eher so, dass Apple volle Kontrolle dar\u00fcber behalten m\u00f6chte, welche Apps auf iPhones oder iOS-Tablets laufen d\u00fcrfen, n\u00e4mlich solche, die (nur) \u00fcber den App-Store verf\u00fcgbar sind. Siehe dazu z.B. hier und hier . Sollten Sie ein iPhone haben und sollte Ihre Anwendung mithilfe von npm start ausgef\u00fchrt sein, so k\u00f6nnen Sie allerdings mal http://141.45.57.28:8080 in Ihren Browser im Handy eingeben. Es muss nichts weiter installiert werden. Sie k\u00f6nnen aber kein Icon auf den Startbildschirm ablegen :-(. Eine weitere Unterst\u00fctzung f\u00fcr iOS Safari bietet PWACompat . Sie m\u00fcssten dann entweder in die index.html unterhalb des Einbindens der manifest.json noch < script async src = \"https://unpkg.com/pwacompat\" crossorigin = \"anonymous\" ></ script > statisch hinzuf\u00fcgen oder dynamisch f\u00fcr den folgenden Fall: < script type = \"module\" > // detect iOS Safari if (( 'standalone' in navigator ) && ( ! navigator . standalone )) { import ( 'https://unpkg.com/pwacompat' ); } </ script > Success Wir haben unsere Webanwendung installierbar gemacht. Zumindest auf Android-Ger\u00e4ten. Dies geschieht mithilfe der Datei manifest.json , die wir in alle html -Seiten unserer Anwendung einbinden. Wir haben viele Eigenschaften kennengelernt, die wir in diesem Web-App-Manifest definieren k\u00f6nnen. Mithilfe des Emulators von Android Studio k\u00f6nnen wir die Anwendung des Web-App-Manifestes auf Android-Ger\u00e4ten ausprobieren. Wir schauen uns nun einen weiteren zentralen Funktionsblock an, n\u00e4mlich Service Worker .","title":"Erstaz f\u00fcr manifest.json f\u00fcr Safari"},{"location":"promises/","text":"Promises und die Fetch-API \u00b6 Wir haben es bereits eingangs des Abschnitts \u00fcber Service Workers angesprochen: JavaScript ist sinhle threaded , d.h. JavaScript l\u00e4uft auf einem einzelnen Thread. Das bedeutet im Prinzip, dass drei Funktionen functionA() , functionB() , functionC() nacheinander auf dem einzelnen Thread ausgef\u00fchrt werden w\u00fcrden, wenn sie nacheinander aufgerufen werden: Das zieht nat\u00fcrlich nach sich, dass sich diese Funktionen in ihrer Ausf\u00fchrung blockieren . Wenn also functionB() bspw. sehr lange braucht, um ausgef\u00fchrt werden zu k\u00f6nnen, dann blockiert diese Funktion die Ausf\u00fchrung von functionC() . Um dies zu vermeiden, wurden in JavaScript sogenannte Callbacks eingef\u00fchrt. Callbacks \u00b6 Zun\u00e4chst einmal sind Callbacks Funktionen, die anderen Funktionen als Parameter \u00fcbergeben werden. Wir betrachten folgendes Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 let x = function () { console . log ( \"Ausgabe der Funktion x\" ); } let y = function () { console . log ( \"Ausgabe der Funktion y\" ); } let z = function ( callback ) { console . log ( \"Ausgabe der Funktion z - vor Aufruf von callback\" ); callback (); console . log ( \"Ausgabe der Funktion z - vor Aufruf von callback\" ); } Wir haben drei Funktionen. Diese werden als anonyme Funktionen definiert, aber die Funktionsdefinitionen werden sofort einer Variablen zugewiesen. Das bedeutet, dass z.B. der Wert der Variablen x die Funktionsdefinition function () { console . log ( \"Ausgabe der Funktion x\" ); } ist. Wenn wir nun z.B. console.log(x) aufrufen, dann erhalten wir folgende Ausgabe auf der Konsole: \u0192 () { console.log ( \"Ausgabe der Funktion x\" ) ; } Wenn wir aber x(); , also sozusagen, die Variable als Funktion aufrufen, dann wird die Funktion ausgef\u00fchrt und wir erhalten auf der Konsole die Ausgabe Ausgabe der Funktion x Wenn wir nun z(x); aufrufen, dann wird die in den Zeilen 9-12 definierte Funktion aufgerufen, wobei der Parameter callback als Wert die Funktionsdefinition von x \u00fcbergeben wird. In Zeile 11 erfolgt dann mithilfe von callback(); eigentlich der Aufruf x(); . Wir k\u00f6nnen aber auch z.B. z(y); aufrufen. Dann wird z nicht die Funktion x , sondern die Funktion y \u00fcbergeben und der Aufruf callback(); in Zeile 11 entspricht somit dem Aufruf y(); . Ein gro\u00dfer Vorteil dieser Callbacks bestehen darin, dass der Aufruf asynchron erfolgt. Schauen wir uns z.B. einmal an, wie die m\u00f6gliche Ausgabe der Aufrufe z ( x ); z ( y ); aussehen k\u00f6nnte : Ausgabe der Funktion z - vor Aufruf von callback Ausgabe der Funktion x Ausgabe der Funktion z - vor Aufruf von callback Ausgabe der Funktion z - vor Aufruf von callback Ausgabe der Funktion y Ausgabe der Funktion z - vor Aufruf von callback Wichtig ist, dass Callbacks die aufrufende Funktion nicht blockieren, sondern asynchron ausgef\u00fchrt werden. Dieses einfache Beispiel soll das demonstrieren: 1 2 3 4 5 setTimeout ( function () { console . log ( 'Ausgabe A' ); }, 3000 ); console . log ( 'Ausgabe B' ); Wir haben zwei Anweisungen: eine setTimeout() -Anweisung und eine console.log('Ausgabe B'); -Anweisung, die nacheinander aufgerufen werden ( setTimeout() vor console.log() ). Innerhalb der setTimeout() -Anweisung wird eine Funktion als Callback \u00fcbergeben. Innerhalb dieser Funktion erfolgt der Aufruf von console.log('Ausgabe A'); . Das Ausf\u00fchren des Programms ergibt folgende Ausgabe: Ausgabe B Ausgabe A Die Ausgabe von Ausgabe A erfolgt ca. 3 Sekunden nach Ausgabe B . Das liegt daran, dass die Callback -Funktion asynchron ausgef\u00fchrt wird und alle weiteren Ausf\u00fchrungen nicht blockiert. Das bedeutet, dass wir mithilfe von Callbacks eine asynchrone Ausf\u00fchrung unseres JavaScript-Codes erreichen. Der einzelne JavaScript-Thread wird also f\u00fcr den Aufruf der Callbacks verwendet und irgendwann sind diese Callback -Aufrufe beendet. Ein gegenseitiges Blockieren findet nicht statt, sondern es bleibt sogar noch Platz f\u00fcr weitere Aufrufe (hellgr\u00fcne Bereiche im folgenden Bild): Das problem mit diesen Callback ist, dass sie sehr schnell sehr un\u00fcbersichtlich werden. Man spricht von der Callback-H\u00f6lle , in der man sehr schnell ist, sobald gen\u00fcgend viele Callbacks asynchron (nebenl\u00e4ufig) ausgef\u00fchrt werden, diese sogar ineinander verschachtelt sind ( Callbacks in Callbacks ) und man gar nicht wei\u00df, wann welche Callbacks beendet sind. Sobald man aber erst die Ausf\u00fchrung eines Callbacks abwarten muss , weil man die Resultate dieses Callbacks weiterverarbeiten m\u00f6chte, entstehen wieder synchrone Aufrufe und der Vorteil der asynchronen Abarbeitung ist dahin. Um dieses Problem zu l\u00f6sen, wurden Promises entwickelt. Promises \u00b6 Ein Promise ist zun\u00e4chst einmal ein JavaScript-Objekt. Es enth\u00e4lt einerseits den Code zum Erzeugen eines Promise -Objektes ( producing code ) und anderseits auch den Code zum Verarbeiten eines solchen Promise -Objektes ( consuming code ). Dabei k\u00f6nnen zwei Sachen verarbeitet werden: entweder das Promise -Objekt wurde erfolgreich abgearbeitet ( resolve ) oder das Promise -Objekt wurde nicht erfolgreich abgearbeitet ( reject ). Die allgemeine Syntax eines solchen Promise -Objektes sieht so aus (siehe z.B. w3scool ): 1 2 3 4 5 6 7 8 9 10 11 12 let myPromise = new Promise ( function ( myResolve , myReject ) { // \"Producing Code\" (May take some time) myResolve (); // when successful myReject (); // when error }); // \"Consuming Code\" (Must wait for a fulfilled Promise) myPromise . then ( function ( value ) { /* code if successful */ }, function ( error ) { /* code if some error */ } ); Betrachten wir das obere Beispiel genauer: in Zeile 1 erstellen wir eine Variable myPromise , die wir nat\u00fcrlich nennen k\u00f6nnen, wie wir m\u00f6chten diese Variable zeigt auf ein Promise -Objekt, das ebenfalls in Zeile 1 mithilfe von new und dem Aufruf des Konstruktors erzeugt wird einem Promise -Objekt (dem Konstruktor) wird immer eine Funktion \u00fcbergeben, der wiederum zwei Callback -Funktionen als Parameter \u00fcbergeben werden die erste Callback -Funktion, die hier myResolve hei\u00dft (aber meistens nur resolve ), wird aufgerufen, wenn das Promise -Objekt erfolgreich abgearbeitet wurde (Zeile 4 ) die zweite Callback -Funktion, die hier myReject hei\u00dft (aber meistens nur reject ), wird aufgerufen, wenn das Promise -Objekt nicht erfolgreich abgearbeitet wurde (Zeile 5 ) den Aufruf des promise -Objektes sehen wir in Zeile 9 . Ein Promise -Objekt durchl\u00e4uft durch den Aufruf 2 der folgenden 3 Zust\u00e4nde: pending : das Promise -Objekt wird abgearbeitet und hat noch kein Resultat ( undefined ), fulfilled : das Promise -Objekt wurde erfolgreich abgearbeitet und liefert den entsprechenden Resultatwert zur\u00fcck oder rejected : das Promise -Objekt wurde nicht erfolgreich abgearbeitet und liefert ein Error -Objekt zur\u00fcck es gibt aber keine M\u00f6glichkeiten, auf diese Zust\u00e4nde eines Promise -Objektes zuzugreifen und auch nicht direkt auf den Resultatwert oder das Fehlerobjekt; stattdessen muss eine entsprechende Funktion des Promise -Objektes aufgerufen werden, die selbst wieder ein Promise -Objekt zur\u00fcckgibt, n\u00e4mlich then() der Aufruf von then() ist ebenfalls in Zeile 9 gezeigt; diese Funktion hat zwei Parameter: dem ersten Parameter wird der Resultatwert \u00fcbergeben (wenn das Promise -Objekt den fulfilled -Zustand erreicht hat) und dem zweiten Parameter wird das Fehlerobjekt \u00fcbergeben (wenn das Promise -Objekt den rejected -Zustand erreicht hat). Beide Parameter sind wiederum Callbacks . Wir werden sehen, dass wir den rejected -Zustand auch mit catch() abfangen k\u00f6nnen, aber dazu kommen wir sp\u00e4ter. Zun\u00e4chst noch einmal zur Vertiefung unser obiges Callback -Beispiel mit setTimeout() als Promise : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let promise = new Promise ( function ( resolve , reject ) { setTimeout ( function () { resolve ( 'resolve -- Ausgabe A' ); }, 3000 ); }); promise . then ( function ( value ) { console . log ( value ); } // (noch) keine Funktion f\u00fcr error ); console . log ( 'Ausgabe B' ); Die Ausgabe in Zeile 14 hat nichts mit dem Promise zu tun, aber wir lassen sie mal im Code, um das gleiche Beispiel wie oben zu haben. Es erfolgt zun\u00e4chst die Ausgabe Ausgabe B auf der Konsole und 3 Sekunden sp\u00e4ter die Ausgabe resolve -- Ausgabe A . Rein funktional hat sich also nichts ge\u00e4ndert. Wie Sie den Parameter f\u00fcr den resolve -Fall (und dann auch f\u00fcr den reject -Fall) nennen, bleibt ganz Ihnen \u00fcberlassen; hier value (Zeile 8 ). Dieses Mal hei\u00dft unser Promise -Objekt promise und die beiden Callback -Funktionen resolve und reject (Zeile 1 ). Der producing code enth\u00e4lt nur die Implementierung von resolve . In dem Beispiel gibt es also (noch) kein reject . In den Zeilen 7 - 12 sehen wir den consuming code der Promise , auch hier wieder nur f\u00fcr resolve . Es erfolgt die Ausgabe des Wertes, den resolve \u00fcbergeben hat. Promises in Arrow-Notation \u00b6 Weil wir es mitlerweile h\u00e4ufig sehen und weil wir uns auch angew\u00f6hnen wollen, diese selbst zu benutzen, hier das gleiche Beispiel nochmal in Arrow-Notation : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let promise = new Promise (( resolve , reject ) => { setTimeout ( () => { resolve ( 'resolve -- Ausgabe A' ); }, 3000 ); }); promise . then ( value => { console . log ( value ); } // (noch) keine Funktion f\u00fcr error ); console . log ( 'Ausgabe B' ); Es ist auch noch zu erw\u00e4hnen, dass Sie nur selten selbst Promises erstellen, sondern diese viel h\u00e4ufiger nutzen werden. Das hei\u00dft, Sie werden nicht so h\u00e4ufig producing code , sondern viel h\u00e4ufiger consuming code schreiben. Beispielsweise gibt die Registrierung eines service workers ein Promise zur\u00fcck: 1 2 3 4 5 6 7 8 9 10 // scope defaults to the path the script sits in // \"/\" in this example navigator . serviceWorker . register ( \"/serviceworker.js\" ). then ( registration => { console . log ( \"success!\" ); if ( registration . installing ) { registration . installing . postMessage ( \"Howdy from your installing page.\" ); } }, err => { console . error ( \"Installing the worker failed!\" , err ); }); Ein gro\u00dfer Vorteil von Promises ist, dass Sie die Verarbeitung verketten k\u00f6nnen. Die then() -Funktion liefert selbst wieder ein Promise zur\u00fcck, so dass Sie erneut dieses Promise mit then() behandeln k\u00f6nnen. Wir kommen darauf in den Anwendungen nochmal zur\u00fcck. Der reject -Fall \u00b6 Wir schauen uns jetzt an, wie wir den Fall am besten behandeln, wenn das Promise nicht in den fulfilled , sondern in den rejected -Zustand \u00fcbergeht, wenn also nicht resolve , sondern reject ausgef\u00fchrt wird. Wir \u00e4ndern unser Beispiel einmal entsprechend: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let promise = new Promise (( resolve , reject ) => { setTimeout ( () => { // resolve('resolve -- Ausgabe A'); reject ({ code : 500 , message : 'An error occurred' }); }, 3000 ); }); promise . then ( value => { console . log ( value ); } // (noch) keine Funktion f\u00fcr error ); console . log ( 'Ausgabe B' ); Wir haben also Zeile 3 auskommentiert ( resolve ) und stattdessen reject eingef\u00fcgt (Zeile 4 ). Im Gegensatz zu resolve geben wir jetzt mal keinen einfachen string , sondern ein JavaScript-Objekt zur\u00fcck (erkennbar an { } ). Wir sind darin v\u00f6llig frei, was zur\u00fcckgegeben wird, aber es bietet sich an, ein Error-Objekt zu erzeugen. Die then() -Behandlung des Promise -Objekt lassen wir zun\u00e4chst unver\u00e4ndert (Zeilen 8-13 ). Wenn wir diesen Code ausf\u00fchren, dann wird erneut Ausgabe B ausgegeben (Zeile 15 - hat nichts mit dem Promise zu tun), aber nach 3 Sekunden erfolgt keine Ausgabe auf der Konsole, sondern stattdessen erscheint auf der Konsole: Error-Behandlung in der then() -Funktion \u00b6 Wir behandeln den geworfenen Fehler nicht, da wir in unserer then() -Behandlung bis jetzt nur den resolve -Fall behandeln (Zeilen 9-11 ). Das \u00e4ndern wir nun: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let promise = new Promise (( resolve , reject ) => { setTimeout ( () => { // resolve('resolve -- Ausgabe A'); reject ({ code : 500 , message : 'An error occurred' }); }, 3000 ); }); promise . then ( value => { console . log ( value ); }, err => { console . log ( err . code , err . message ); } ); console . log ( 'Ausgabe B' ); In den Zeilen 12-14 wurde die Behandlung des Fehlerfalls hinzugef\u00fcgt (beachten Sie auch das zus\u00e4tzliche Komma in Zeile 11 ). Wie Sie die Variable err nennen, bleibt Ihnen \u00fcberlassen. Sie bekommt den Wert, den das Promise f\u00fcr den reject -Fall \u00fcbergibt, in unserem Beispiel also ein JavaScript-Objekt: { code : 500 , message : 'A n error occurred' } weil wir das in Zeile 4 so definiert haben. Wir greifen also auf die Werte der Schl\u00fcssel code und message zu und lassen diese auf die Konsole ausgeben (Zeile 13 ). Auf der Konsole erscheint 3 Sekunden nach der Ausgabe Ausgabe B die Ausgabe 500 An error occurred . Error-Behandlung im catch() -Block \u00b6 Es ist ungew\u00f6hnlich, den Fehlerfall in der then() -Funktion zu behandeln, obwohl es, wie wir gesehen haben, m\u00f6glich ist. Stattdessen verwendet man f\u00fcr den Fehlerfall besser catch() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 let promise = new Promise (( resolve , reject ) => { setTimeout ( () => { // resolve('resolve -- Ausgabe A'); reject ({ code : 500 , message : 'An error occurred' }); }, 3000 ); }); promise . then ( value => { console . log ( value ); } ) . catch ( err => { console . log ( err . code , err . message ); } ); console . log ( 'Ausgabe B' ); Mit diesen Wissen k\u00f6nnen wir jetzt auch unsere Registrierung eines service workers etwas zuverl\u00e4ssiger gestalten und f\u00fcgen dort ebenfalls einen catch() -Block ein, auch wenn der Fehlerfall nicht all zu h\u00e4ufig eintreffen d\u00fcrfte: 1 2 3 4 5 6 7 8 9 10 if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( '/sw.js' ) . then (() => { console . log ( 'service worker registriert' ) }) . catch ( err => { console . log ( err ); } ); } Fetch API \u00b6 Die Fetch API bietet einen bequemeren und leistungsf\u00e4higeren Ersatz f\u00fcr XMLHttpRequest . Es geht also darum, Ressourcen vom Web-Server zu holen ( to fetch ). Die Fetch API ist vollst\u00e4ndig auf Promises aufgebaut. Die zentrale Methode der Fetch API ist fetch() . Das Gute an dieser Methode ist, dass sie gloabl ist im Sinne, dass sie nicht nur von einer Webanwendung selbst, sondern auch z.B. von einem Service Worker verwendet werden kann (sie ist im WindowOrWorkerGlobalScope ). Einf\u00fchrungen zu fetch() finden Sie z.B. hier , hier oder hier . GET-Anfragen mit fetch() \u00b6 Wir starten mit einem einfachen Beispiel und nutzen daf\u00fcr https://httpbin.org , eine Webseite, die viele REST-Endpunkte zum Ausprobieren anbietet. Nach dem \u00d6ffnen dieser Seite im Browser, k\u00f6nnen Sie z.B. mal auf Request inspection klicken - dort sehen wir den Endpunkt /ip , den wir \u00fcber ein GET abfragen werden: 1 2 3 4 5 6 fetch ( 'https://httpbin.org/ip' ) . then ( response => { console . log ( response ); } ); Wir rufen also einmal fetch() auf und \u00fcbergeben dieser Funktion den Endpunkt, von dem eine Ressource geholt werden soll. Die fetch() -Funktion liefert ein Promise -Objekt zur\u00fcck. Deshalb k\u00f6nnen wir auch direkt die then() -Funktion aufrufen und die response (ist egal, wie Sie disen Parameter nennen) auf die Konsole ausgeben. Wenn wir diesen Code ausf\u00fchren, erscheint in der Konsole: Wir bekommen also ein JavaScript-Objekt zur\u00fcck. Wirklich interessiert sind wir aber haupts\u00e4chlich an dem body dieses Objektes. Um darauf geeignet zuzugreifen, konvertieren wir das Objekt zun\u00e4chst in das JSON-Format mithilfe der Anweisung response.json(); . Die json() -Funktion ist eine Standard-JavaScript-Funktion, welche ein JavaScript-Objekt in einen JSON umwandelt. Da then() selbst ein Promise -Objekt zur\u00fcckgibt. wollen wir darauf then() erneut anwenden, um das Prinzip verketteter then() -Funktionen (verketteter asynchroner Verarbeitungen) zu zeigen: 1 2 3 4 5 6 7 8 9 10 11 fetch ( 'https://httpbin.org/ip' ) . then ( response => { return response . json (); } ) . then ( data => { console . log ( data ); } ); In der ersten then() -Funktion (Zeilen 2-6 ) wird also die Response der asynchronen GET https://httpbin.org/ip -Anfrage behandelt und darin wird diese Response in eine JSON umgewandelt (Zeile 4 ). Die R\u00fcckgabe dieser then() -Funktion ist erneut ein Promise . F\u00fcr dieses Promise ist die zweite then() -Funktion (Zeilen 7-11 ). Diese Funktion behandelt das asynchrone Streamen des Response-Body und dessen Umwandlung in ein JSON. Das durch dieses Promise zur\u00fcckgegebene resolve bezeichnen wir in unserem Beispiel als data und geben es auf die Konsole aus. Auf der Konsole erscheint die IP , von der die Anfrage erfolgte, z.B. { origin: \"130.193.115.48\" } Noch zwei kleine Verbesserungen am Code: wenn in der Arrow-Notation Ihre Funktion nur aus einer einzigen return -Anweisung besteht, dann k\u00f6nnen Sie die geschweiften Klammern Ihres Funktionsk\u00f6rpers weglassen und auch das return . D.h. aus response => { return response . json (); } wird response => response . json () Auch das Semikolon entf\u00e4llt. Das gilt aber nur f\u00fcr return -Anweisungen, nicht z.B. wenn die Funktion nur aus einer einzigen Konsolenausgabe besteht. Au\u00dferdem sollten wir auch noch ein catch() -Block einf\u00fcgen, f\u00fcr den Fall, dass ein Fehler auftritt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fetch ( 'https://httpbin.org/ip' ) . then ( response => response . json () ) . then ( data => { console . log ( data ); } ) . catch ( err => { console . log ( err ); } ); Den Fehlerfall k\u00f6nnen Sie ausprobieren, indem Sie einfach einen Fehler in die URL einbauen. POST-Anfragen mit fetch() \u00b6 POST -Anfragen werden verwendet, um Daten an den Webserver zu senden. Typischerweise sind das Formulardaten, die z.B. in eine Datenbank eingef\u00fcgt werden sollen. Wenn wir also mithilfe von fetch() eine POST -Anfrage stellen wollen, dann m\u00fcssen wir zwei Dinge beachten: wir m\u00fcssen fetch() explizit mitteilen, dass die verwendete HTTP-Anfrage-Methode POST ist und wir m\u00fcssen die Daten mitschicken. F\u00fcr ein einfaches Beispiel verwenden wir erneut https://httpbin.org , dieses Mal aber den Endpunkt /post , der uns einfach die gesendeten Daten wieder als Response unserer Abfrage zur\u00fcckschickt, also einfach als \"Spiegel\" fungiert. Eine entsprechende fetch() -Anweisung k\u00f6nnte so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fetch ( 'https://httpbin.org/post' , { method : 'POST' , header : { 'Content-Type' : 'application/json' , 'Accept' : 'application/json' }, body : JSON . stringify ({ message : 'just a POST mirror' }) }) . then ( response => response . json () ) . then ( data => { console . log ( data ); } ) . catch ( err => { console . log ( err ); } ); Die Zeilen 11-23 sind dabei zun\u00e4chst unver\u00e4ndert geblieben und sehen genauso aus wie die Zeilen 2-14 aus dem obigen GET -Beispiel. Nur die Parameter in der fetch() -Funktion haben sich ge\u00e4ndert. Der erste Parmeter lautet nun 'https://httpbin.org/post' , da wir die Anfrage an diese URL (diesen Endpunkt) stellen. Hinzugekommen ist ein zweiter Parameter, ein JSON: { me t hod : 'POST' , header : { 'Co ntent - Type' : 'applica t io n /jso n ' , 'Accep t ' : 'applica t io n /jso n ' }, body : JSON.s tr i n gi f y( { message : 'jus t a POST mirror' } ) } darin legen wir zun\u00e4chst mithilfe von method die HTTP-Anfrage-Methode fest. Standard ist GET , deshalb brauchten wir das in unserem ersten Beispiel nicht zu tun. Nun geben wir POST an. Au\u00dferdem definieren wir noch Eigenschaften f\u00fcr den header . Wir legen mithilfe von Content-Type fest, welches Format unsere Daten haben, die wir \u00fcbermitteln, n\u00e4mlich application/json . Au\u00dferdem legen wir mithilfe von Accept fest, in welchem Format wir die Daten empfangen wollen, n\u00e4mlich ebenfalls im JSON-Format. Diese Accept -Angabe ist nicht immer notwendig. Die meisten REST-Endpunkte liefern so oder so ein JSON zur\u00fcck. Das h\u00e4ngt von der Definition der REST-API ab. In der body -Eigenschaft definieren wir die Daten, die wir \u00fcbertragen wollen. In diesem Fall im JSON-Format. { message: 'just a POST mirror' } ist ein JavaScript-Objekt, das eine einzige Eigenschaft enth\u00e4lt, n\u00e4mlich message . Mithilfe der JavaScript-Standardfunktion JSON.stringify() wandeln wir dieses JavaScript-Objekt in ein JSON um. Somit wird ein JSON versendet, genau wie wir es im header unter Content-Type angegeben haben. F\u00fchren wir diesen Code aus, erhalten wir auf der Konsole folgende Ausgabe: Man k\u00f6nnte jetzt meinen, dass der Zugriff auf das Response-JSON ( {message: \"just a POST mirror\"} ) einfach \u00fcber response.data oder \u00fcber response.json erfolgen kann. Dem ist aber nicht so, da es sich bei dem body der response um ein Objekt vom Typ ReadableStream handelt. Das ist einerseits gut, denn die Daten vom Server werden asynchron als Stream empfangen, andererseits ist der Zugriff auf die Daten recht aufwendig. Wir werden darauf nochmal intensiver eingehen, wenn wir Bilder vom Backend laden. Ansonsten k\u00f6nnen Sie sich auch schonmal hier informieren oder sich hier und hier . Aber, wie gesagt, wir kommen eh nochmal darauf zur\u00fcck. Wenn Sie sich das zur\u00fcckgelieferte JSON schonmal anschauen wollen, dann ginge das z.B. so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 fetch ( 'https://httpbin.org/post' , { method : 'POST' , header : { 'Content-Type' : 'application/json' , 'Accept' : 'application/json' }, body : JSON . stringify ({ message : 'just a POST mirror' }) }) . then ( response => { console . log ( response ); return response ; } ) . then ( response => { console . log ( response . body ); // show the body, ReadableStream return response . body ; } ) . then ( body => { const reader = body . getReader (); return new ReadableStream ({ start ( controller ) { return pump (); function pump () { return reader . read (). then (({ done , value }) => { // When no more data needs to be consumed, close the stream if ( done ) { controller . close (); return ; } // Enqueue the next data chunk into our target stream controller . enqueue ( value ); // Uint8Array return pump (); }); } } }) }) . then ( stream => new Response ( stream )) . then ( response => response . json ()) // also possible: text(), blob(), ... . then ( response => { console . log ( response . json ); }) . catch ( err => { console . log ( err ); } ); Fetch vs. XMLHttpRequest \u00b6 Wir haben eingangs erw\u00e4hnt, dass die Fetch API einen bequemeren und leistungsf\u00e4higeren Ersatz f\u00fcr XMLHttpRequest darstellt. Das sieht man einerseits bereits an der Code-L\u00e4nge. Das ist die Implementierung mit fetch() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fetch ( 'https://httpbin.org/ip' ) . then ( response => response . json () ) . then ( data => { console . log ( data ); } ) . catch ( err => { console . log ( err ); } ); und das hier macht genau das Gleiche mithilfe von XMLHttpRequest() : 1 2 3 4 5 6 7 8 9 10 11 12 13 let xhr = new XMLHttpRequest (); xhr . open ( 'GET' , 'https://httpbin.org/ip' ); xhr . responseType = 'json' ; xhr . onload = function () { console . log ( xhr . response ); } xhr . onerror = function () { console . log ( 'error' ); } xhr . send (); Ein ganz wesentlicher Unterschied liegt aber darin, dass bei Verwendung von XMLHttpRequest() deutlich mehr Sachen im Hintergrund synchron ablaufen, als bei der Fetch API. Das ist der Grund, dass wir bei der Implementierung von service workern die Fetch API verwenden m\u00fcssen und nicht auf das (alte) XMLHttpRequest() zugreifen k\u00f6nnen. fetch() und unser service worker \u00b6 Alle Code-Beispiele von oben (also die Promises und die fetch() -Beispiele) habe ich einfach in die app.js unseres HTW Insta -Beispiels eingetragen und ausprobiert. Das hei\u00dft, die app.js sieht jetzt gerade so aus: app.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( '/sw.js' ) . then (() => { console . log ( 'service worker registriert' ) }) . catch ( err => { console . log ( err ); } ); } let promise = new Promise (( resolve , reject ) => { setTimeout ( () => { // resolve('resolve -- Ausgabe A'); reject ({ code : 500 , message : 'An error occurred' }); }, 3000 ); }); promise . then ( value => { console . log ( value ); } ) . catch ( err => { console . log ( err . code , err . message ); } ); console . log ( 'Ausgabe B' ); fetch ( 'https://httpbin.org/ip' ) . then ( response => response . json () ) . then ( data => { console . log ( data ); } ) . catch ( err => { console . log ( err ); } ); let xhr = new XMLHttpRequest (); xhr . open ( 'GET' , 'https://httpbin.org/ip' ); xhr . responseType = 'json' ; xhr . onload = function () { console . log ( xhr . response ); } xhr . onerror = function () { console . log ( 'error' ); } xhr . send (); fetch ( 'https://httpbin.org/post' , { method : 'POST' , header : { 'Content-Type' : 'application/json' , 'Accept' : 'application/json' }, body : JSON . stringify ({ message : 'just a POST mirror' }) }) . then ( response => { console . log ( response ); return response ; } ) . then ( response => { console . log ( response . body ); return response . body ; } ) . then ( body => { const reader = body . getReader (); return new ReadableStream ({ start ( controller ) { return pump (); function pump () { return reader . read (). then (({ done , value }) => { // When no more data needs to be consumed, close the stream if ( done ) { controller . close (); return ; } // Enqueue the next data chunk into our target stream controller . enqueue ( value ); return pump (); }); } } }) }) . then ( stream => new Response ( stream )) . then ( response => response . json ()) . then ( response => { console . log ( response . json ); }) . catch ( err => { console . log ( err ); } ); Au\u00dferdem haben wir ja in unserer Anwendung bereits einen service worker registriert und auch in schon in Ans\u00e4tzen implementiert: sw.js 1 2 3 4 5 6 7 8 9 10 11 12 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) self . addEventListener ( 'fetch' , event => { console . log ( 'service worker --> fetching ...' , event ); }) Ich er\u00e4hne das nur deshalb, weil unsere Konsole bei Ausf\u00fchrung der Anwendung jetzt ungef\u00e4hr so aussieht: Es erscheint also ganz oft die Ausgabe des fetch -Events, genau wie in der sw.js in den Zeilen 10-12 implementiert. Das fetch -Event wird immer dann ausgel\u00f6st, wenn die Anwendung etwas vom Webserver l\u00e4dt. Das sind einerseits alle Ressourcen, die wir in der index.html -datei definiert haben (alle *.js und alle *.css und alle *.png -Dateien), aber auch die fetch() -Anweisungen, die wir in der app.js implementiert haben! Wir werden auf der Konsole auch die fetch -Ereignisse finden, die den Zugriff auf https://httpbin.org/ip bzw. https://httpbin.org/post ausf\u00fchren. Wir merken uns also fetch -Ereignisse werden automatisch ausgel\u00f6st durch das Laden von ressourcen, so wie in den *.html -Dateien der Anwendung definiert, aber auch durch manuell ausgel\u00f6ste (implementierte) fetch() -Anfragen. Das ist wichtig, wenn wir in unserem service worker die fetch -Ereignisse behandeln werden. Success Wir kennen nun Promises und die Fetch API und k\u00f6nnen beides anwenden. Wir werden Promises von nun an permanent verwenden. Insbesondere den consuming code f\u00fcr Promises, als .then().catch() . Mithilfe der Fetch API werden wir alle HTTP-Anfragen an den Server stellen k\u00f6nnen, also GET , POST , PUT und DELETE und dabei das asynchrone Prinzip dieser API bestm\u00f6glich ausnutzen.","title":"Promises & Fetch"},{"location":"promises/#promises-und-die-fetch-api","text":"Wir haben es bereits eingangs des Abschnitts \u00fcber Service Workers angesprochen: JavaScript ist sinhle threaded , d.h. JavaScript l\u00e4uft auf einem einzelnen Thread. Das bedeutet im Prinzip, dass drei Funktionen functionA() , functionB() , functionC() nacheinander auf dem einzelnen Thread ausgef\u00fchrt werden w\u00fcrden, wenn sie nacheinander aufgerufen werden: Das zieht nat\u00fcrlich nach sich, dass sich diese Funktionen in ihrer Ausf\u00fchrung blockieren . Wenn also functionB() bspw. sehr lange braucht, um ausgef\u00fchrt werden zu k\u00f6nnen, dann blockiert diese Funktion die Ausf\u00fchrung von functionC() . Um dies zu vermeiden, wurden in JavaScript sogenannte Callbacks eingef\u00fchrt.","title":"Promises und die Fetch-API"},{"location":"promises/#callbacks","text":"Zun\u00e4chst einmal sind Callbacks Funktionen, die anderen Funktionen als Parameter \u00fcbergeben werden. Wir betrachten folgendes Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 let x = function () { console . log ( \"Ausgabe der Funktion x\" ); } let y = function () { console . log ( \"Ausgabe der Funktion y\" ); } let z = function ( callback ) { console . log ( \"Ausgabe der Funktion z - vor Aufruf von callback\" ); callback (); console . log ( \"Ausgabe der Funktion z - vor Aufruf von callback\" ); } Wir haben drei Funktionen. Diese werden als anonyme Funktionen definiert, aber die Funktionsdefinitionen werden sofort einer Variablen zugewiesen. Das bedeutet, dass z.B. der Wert der Variablen x die Funktionsdefinition function () { console . log ( \"Ausgabe der Funktion x\" ); } ist. Wenn wir nun z.B. console.log(x) aufrufen, dann erhalten wir folgende Ausgabe auf der Konsole: \u0192 () { console.log ( \"Ausgabe der Funktion x\" ) ; } Wenn wir aber x(); , also sozusagen, die Variable als Funktion aufrufen, dann wird die Funktion ausgef\u00fchrt und wir erhalten auf der Konsole die Ausgabe Ausgabe der Funktion x Wenn wir nun z(x); aufrufen, dann wird die in den Zeilen 9-12 definierte Funktion aufgerufen, wobei der Parameter callback als Wert die Funktionsdefinition von x \u00fcbergeben wird. In Zeile 11 erfolgt dann mithilfe von callback(); eigentlich der Aufruf x(); . Wir k\u00f6nnen aber auch z.B. z(y); aufrufen. Dann wird z nicht die Funktion x , sondern die Funktion y \u00fcbergeben und der Aufruf callback(); in Zeile 11 entspricht somit dem Aufruf y(); . Ein gro\u00dfer Vorteil dieser Callbacks bestehen darin, dass der Aufruf asynchron erfolgt. Schauen wir uns z.B. einmal an, wie die m\u00f6gliche Ausgabe der Aufrufe z ( x ); z ( y ); aussehen k\u00f6nnte : Ausgabe der Funktion z - vor Aufruf von callback Ausgabe der Funktion x Ausgabe der Funktion z - vor Aufruf von callback Ausgabe der Funktion z - vor Aufruf von callback Ausgabe der Funktion y Ausgabe der Funktion z - vor Aufruf von callback Wichtig ist, dass Callbacks die aufrufende Funktion nicht blockieren, sondern asynchron ausgef\u00fchrt werden. Dieses einfache Beispiel soll das demonstrieren: 1 2 3 4 5 setTimeout ( function () { console . log ( 'Ausgabe A' ); }, 3000 ); console . log ( 'Ausgabe B' ); Wir haben zwei Anweisungen: eine setTimeout() -Anweisung und eine console.log('Ausgabe B'); -Anweisung, die nacheinander aufgerufen werden ( setTimeout() vor console.log() ). Innerhalb der setTimeout() -Anweisung wird eine Funktion als Callback \u00fcbergeben. Innerhalb dieser Funktion erfolgt der Aufruf von console.log('Ausgabe A'); . Das Ausf\u00fchren des Programms ergibt folgende Ausgabe: Ausgabe B Ausgabe A Die Ausgabe von Ausgabe A erfolgt ca. 3 Sekunden nach Ausgabe B . Das liegt daran, dass die Callback -Funktion asynchron ausgef\u00fchrt wird und alle weiteren Ausf\u00fchrungen nicht blockiert. Das bedeutet, dass wir mithilfe von Callbacks eine asynchrone Ausf\u00fchrung unseres JavaScript-Codes erreichen. Der einzelne JavaScript-Thread wird also f\u00fcr den Aufruf der Callbacks verwendet und irgendwann sind diese Callback -Aufrufe beendet. Ein gegenseitiges Blockieren findet nicht statt, sondern es bleibt sogar noch Platz f\u00fcr weitere Aufrufe (hellgr\u00fcne Bereiche im folgenden Bild): Das problem mit diesen Callback ist, dass sie sehr schnell sehr un\u00fcbersichtlich werden. Man spricht von der Callback-H\u00f6lle , in der man sehr schnell ist, sobald gen\u00fcgend viele Callbacks asynchron (nebenl\u00e4ufig) ausgef\u00fchrt werden, diese sogar ineinander verschachtelt sind ( Callbacks in Callbacks ) und man gar nicht wei\u00df, wann welche Callbacks beendet sind. Sobald man aber erst die Ausf\u00fchrung eines Callbacks abwarten muss , weil man die Resultate dieses Callbacks weiterverarbeiten m\u00f6chte, entstehen wieder synchrone Aufrufe und der Vorteil der asynchronen Abarbeitung ist dahin. Um dieses Problem zu l\u00f6sen, wurden Promises entwickelt.","title":"Callbacks"},{"location":"promises/#promises","text":"Ein Promise ist zun\u00e4chst einmal ein JavaScript-Objekt. Es enth\u00e4lt einerseits den Code zum Erzeugen eines Promise -Objektes ( producing code ) und anderseits auch den Code zum Verarbeiten eines solchen Promise -Objektes ( consuming code ). Dabei k\u00f6nnen zwei Sachen verarbeitet werden: entweder das Promise -Objekt wurde erfolgreich abgearbeitet ( resolve ) oder das Promise -Objekt wurde nicht erfolgreich abgearbeitet ( reject ). Die allgemeine Syntax eines solchen Promise -Objektes sieht so aus (siehe z.B. w3scool ): 1 2 3 4 5 6 7 8 9 10 11 12 let myPromise = new Promise ( function ( myResolve , myReject ) { // \"Producing Code\" (May take some time) myResolve (); // when successful myReject (); // when error }); // \"Consuming Code\" (Must wait for a fulfilled Promise) myPromise . then ( function ( value ) { /* code if successful */ }, function ( error ) { /* code if some error */ } ); Betrachten wir das obere Beispiel genauer: in Zeile 1 erstellen wir eine Variable myPromise , die wir nat\u00fcrlich nennen k\u00f6nnen, wie wir m\u00f6chten diese Variable zeigt auf ein Promise -Objekt, das ebenfalls in Zeile 1 mithilfe von new und dem Aufruf des Konstruktors erzeugt wird einem Promise -Objekt (dem Konstruktor) wird immer eine Funktion \u00fcbergeben, der wiederum zwei Callback -Funktionen als Parameter \u00fcbergeben werden die erste Callback -Funktion, die hier myResolve hei\u00dft (aber meistens nur resolve ), wird aufgerufen, wenn das Promise -Objekt erfolgreich abgearbeitet wurde (Zeile 4 ) die zweite Callback -Funktion, die hier myReject hei\u00dft (aber meistens nur reject ), wird aufgerufen, wenn das Promise -Objekt nicht erfolgreich abgearbeitet wurde (Zeile 5 ) den Aufruf des promise -Objektes sehen wir in Zeile 9 . Ein Promise -Objekt durchl\u00e4uft durch den Aufruf 2 der folgenden 3 Zust\u00e4nde: pending : das Promise -Objekt wird abgearbeitet und hat noch kein Resultat ( undefined ), fulfilled : das Promise -Objekt wurde erfolgreich abgearbeitet und liefert den entsprechenden Resultatwert zur\u00fcck oder rejected : das Promise -Objekt wurde nicht erfolgreich abgearbeitet und liefert ein Error -Objekt zur\u00fcck es gibt aber keine M\u00f6glichkeiten, auf diese Zust\u00e4nde eines Promise -Objektes zuzugreifen und auch nicht direkt auf den Resultatwert oder das Fehlerobjekt; stattdessen muss eine entsprechende Funktion des Promise -Objektes aufgerufen werden, die selbst wieder ein Promise -Objekt zur\u00fcckgibt, n\u00e4mlich then() der Aufruf von then() ist ebenfalls in Zeile 9 gezeigt; diese Funktion hat zwei Parameter: dem ersten Parameter wird der Resultatwert \u00fcbergeben (wenn das Promise -Objekt den fulfilled -Zustand erreicht hat) und dem zweiten Parameter wird das Fehlerobjekt \u00fcbergeben (wenn das Promise -Objekt den rejected -Zustand erreicht hat). Beide Parameter sind wiederum Callbacks . Wir werden sehen, dass wir den rejected -Zustand auch mit catch() abfangen k\u00f6nnen, aber dazu kommen wir sp\u00e4ter. Zun\u00e4chst noch einmal zur Vertiefung unser obiges Callback -Beispiel mit setTimeout() als Promise : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let promise = new Promise ( function ( resolve , reject ) { setTimeout ( function () { resolve ( 'resolve -- Ausgabe A' ); }, 3000 ); }); promise . then ( function ( value ) { console . log ( value ); } // (noch) keine Funktion f\u00fcr error ); console . log ( 'Ausgabe B' ); Die Ausgabe in Zeile 14 hat nichts mit dem Promise zu tun, aber wir lassen sie mal im Code, um das gleiche Beispiel wie oben zu haben. Es erfolgt zun\u00e4chst die Ausgabe Ausgabe B auf der Konsole und 3 Sekunden sp\u00e4ter die Ausgabe resolve -- Ausgabe A . Rein funktional hat sich also nichts ge\u00e4ndert. Wie Sie den Parameter f\u00fcr den resolve -Fall (und dann auch f\u00fcr den reject -Fall) nennen, bleibt ganz Ihnen \u00fcberlassen; hier value (Zeile 8 ). Dieses Mal hei\u00dft unser Promise -Objekt promise und die beiden Callback -Funktionen resolve und reject (Zeile 1 ). Der producing code enth\u00e4lt nur die Implementierung von resolve . In dem Beispiel gibt es also (noch) kein reject . In den Zeilen 7 - 12 sehen wir den consuming code der Promise , auch hier wieder nur f\u00fcr resolve . Es erfolgt die Ausgabe des Wertes, den resolve \u00fcbergeben hat.","title":"Promises"},{"location":"promises/#promises-in-arrow-notation","text":"Weil wir es mitlerweile h\u00e4ufig sehen und weil wir uns auch angew\u00f6hnen wollen, diese selbst zu benutzen, hier das gleiche Beispiel nochmal in Arrow-Notation : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let promise = new Promise (( resolve , reject ) => { setTimeout ( () => { resolve ( 'resolve -- Ausgabe A' ); }, 3000 ); }); promise . then ( value => { console . log ( value ); } // (noch) keine Funktion f\u00fcr error ); console . log ( 'Ausgabe B' ); Es ist auch noch zu erw\u00e4hnen, dass Sie nur selten selbst Promises erstellen, sondern diese viel h\u00e4ufiger nutzen werden. Das hei\u00dft, Sie werden nicht so h\u00e4ufig producing code , sondern viel h\u00e4ufiger consuming code schreiben. Beispielsweise gibt die Registrierung eines service workers ein Promise zur\u00fcck: 1 2 3 4 5 6 7 8 9 10 // scope defaults to the path the script sits in // \"/\" in this example navigator . serviceWorker . register ( \"/serviceworker.js\" ). then ( registration => { console . log ( \"success!\" ); if ( registration . installing ) { registration . installing . postMessage ( \"Howdy from your installing page.\" ); } }, err => { console . error ( \"Installing the worker failed!\" , err ); }); Ein gro\u00dfer Vorteil von Promises ist, dass Sie die Verarbeitung verketten k\u00f6nnen. Die then() -Funktion liefert selbst wieder ein Promise zur\u00fcck, so dass Sie erneut dieses Promise mit then() behandeln k\u00f6nnen. Wir kommen darauf in den Anwendungen nochmal zur\u00fcck.","title":"Promises in Arrow-Notation"},{"location":"promises/#der-reject-fall","text":"Wir schauen uns jetzt an, wie wir den Fall am besten behandeln, wenn das Promise nicht in den fulfilled , sondern in den rejected -Zustand \u00fcbergeht, wenn also nicht resolve , sondern reject ausgef\u00fchrt wird. Wir \u00e4ndern unser Beispiel einmal entsprechend: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let promise = new Promise (( resolve , reject ) => { setTimeout ( () => { // resolve('resolve -- Ausgabe A'); reject ({ code : 500 , message : 'An error occurred' }); }, 3000 ); }); promise . then ( value => { console . log ( value ); } // (noch) keine Funktion f\u00fcr error ); console . log ( 'Ausgabe B' ); Wir haben also Zeile 3 auskommentiert ( resolve ) und stattdessen reject eingef\u00fcgt (Zeile 4 ). Im Gegensatz zu resolve geben wir jetzt mal keinen einfachen string , sondern ein JavaScript-Objekt zur\u00fcck (erkennbar an { } ). Wir sind darin v\u00f6llig frei, was zur\u00fcckgegeben wird, aber es bietet sich an, ein Error-Objekt zu erzeugen. Die then() -Behandlung des Promise -Objekt lassen wir zun\u00e4chst unver\u00e4ndert (Zeilen 8-13 ). Wenn wir diesen Code ausf\u00fchren, dann wird erneut Ausgabe B ausgegeben (Zeile 15 - hat nichts mit dem Promise zu tun), aber nach 3 Sekunden erfolgt keine Ausgabe auf der Konsole, sondern stattdessen erscheint auf der Konsole:","title":"Der reject-Fall"},{"location":"promises/#error-behandlung-in-der-then-funktion","text":"Wir behandeln den geworfenen Fehler nicht, da wir in unserer then() -Behandlung bis jetzt nur den resolve -Fall behandeln (Zeilen 9-11 ). Das \u00e4ndern wir nun: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let promise = new Promise (( resolve , reject ) => { setTimeout ( () => { // resolve('resolve -- Ausgabe A'); reject ({ code : 500 , message : 'An error occurred' }); }, 3000 ); }); promise . then ( value => { console . log ( value ); }, err => { console . log ( err . code , err . message ); } ); console . log ( 'Ausgabe B' ); In den Zeilen 12-14 wurde die Behandlung des Fehlerfalls hinzugef\u00fcgt (beachten Sie auch das zus\u00e4tzliche Komma in Zeile 11 ). Wie Sie die Variable err nennen, bleibt Ihnen \u00fcberlassen. Sie bekommt den Wert, den das Promise f\u00fcr den reject -Fall \u00fcbergibt, in unserem Beispiel also ein JavaScript-Objekt: { code : 500 , message : 'A n error occurred' } weil wir das in Zeile 4 so definiert haben. Wir greifen also auf die Werte der Schl\u00fcssel code und message zu und lassen diese auf die Konsole ausgeben (Zeile 13 ). Auf der Konsole erscheint 3 Sekunden nach der Ausgabe Ausgabe B die Ausgabe 500 An error occurred .","title":"Error-Behandlung in der then()-Funktion"},{"location":"promises/#error-behandlung-im-catch-block","text":"Es ist ungew\u00f6hnlich, den Fehlerfall in der then() -Funktion zu behandeln, obwohl es, wie wir gesehen haben, m\u00f6glich ist. Stattdessen verwendet man f\u00fcr den Fehlerfall besser catch() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 let promise = new Promise (( resolve , reject ) => { setTimeout ( () => { // resolve('resolve -- Ausgabe A'); reject ({ code : 500 , message : 'An error occurred' }); }, 3000 ); }); promise . then ( value => { console . log ( value ); } ) . catch ( err => { console . log ( err . code , err . message ); } ); console . log ( 'Ausgabe B' ); Mit diesen Wissen k\u00f6nnen wir jetzt auch unsere Registrierung eines service workers etwas zuverl\u00e4ssiger gestalten und f\u00fcgen dort ebenfalls einen catch() -Block ein, auch wenn der Fehlerfall nicht all zu h\u00e4ufig eintreffen d\u00fcrfte: 1 2 3 4 5 6 7 8 9 10 if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( '/sw.js' ) . then (() => { console . log ( 'service worker registriert' ) }) . catch ( err => { console . log ( err ); } ); }","title":"Error-Behandlung im catch()-Block"},{"location":"promises/#fetch-api","text":"Die Fetch API bietet einen bequemeren und leistungsf\u00e4higeren Ersatz f\u00fcr XMLHttpRequest . Es geht also darum, Ressourcen vom Web-Server zu holen ( to fetch ). Die Fetch API ist vollst\u00e4ndig auf Promises aufgebaut. Die zentrale Methode der Fetch API ist fetch() . Das Gute an dieser Methode ist, dass sie gloabl ist im Sinne, dass sie nicht nur von einer Webanwendung selbst, sondern auch z.B. von einem Service Worker verwendet werden kann (sie ist im WindowOrWorkerGlobalScope ). Einf\u00fchrungen zu fetch() finden Sie z.B. hier , hier oder hier .","title":"Fetch API"},{"location":"promises/#get-anfragen-mit-fetch","text":"Wir starten mit einem einfachen Beispiel und nutzen daf\u00fcr https://httpbin.org , eine Webseite, die viele REST-Endpunkte zum Ausprobieren anbietet. Nach dem \u00d6ffnen dieser Seite im Browser, k\u00f6nnen Sie z.B. mal auf Request inspection klicken - dort sehen wir den Endpunkt /ip , den wir \u00fcber ein GET abfragen werden: 1 2 3 4 5 6 fetch ( 'https://httpbin.org/ip' ) . then ( response => { console . log ( response ); } ); Wir rufen also einmal fetch() auf und \u00fcbergeben dieser Funktion den Endpunkt, von dem eine Ressource geholt werden soll. Die fetch() -Funktion liefert ein Promise -Objekt zur\u00fcck. Deshalb k\u00f6nnen wir auch direkt die then() -Funktion aufrufen und die response (ist egal, wie Sie disen Parameter nennen) auf die Konsole ausgeben. Wenn wir diesen Code ausf\u00fchren, erscheint in der Konsole: Wir bekommen also ein JavaScript-Objekt zur\u00fcck. Wirklich interessiert sind wir aber haupts\u00e4chlich an dem body dieses Objektes. Um darauf geeignet zuzugreifen, konvertieren wir das Objekt zun\u00e4chst in das JSON-Format mithilfe der Anweisung response.json(); . Die json() -Funktion ist eine Standard-JavaScript-Funktion, welche ein JavaScript-Objekt in einen JSON umwandelt. Da then() selbst ein Promise -Objekt zur\u00fcckgibt. wollen wir darauf then() erneut anwenden, um das Prinzip verketteter then() -Funktionen (verketteter asynchroner Verarbeitungen) zu zeigen: 1 2 3 4 5 6 7 8 9 10 11 fetch ( 'https://httpbin.org/ip' ) . then ( response => { return response . json (); } ) . then ( data => { console . log ( data ); } ); In der ersten then() -Funktion (Zeilen 2-6 ) wird also die Response der asynchronen GET https://httpbin.org/ip -Anfrage behandelt und darin wird diese Response in eine JSON umgewandelt (Zeile 4 ). Die R\u00fcckgabe dieser then() -Funktion ist erneut ein Promise . F\u00fcr dieses Promise ist die zweite then() -Funktion (Zeilen 7-11 ). Diese Funktion behandelt das asynchrone Streamen des Response-Body und dessen Umwandlung in ein JSON. Das durch dieses Promise zur\u00fcckgegebene resolve bezeichnen wir in unserem Beispiel als data und geben es auf die Konsole aus. Auf der Konsole erscheint die IP , von der die Anfrage erfolgte, z.B. { origin: \"130.193.115.48\" } Noch zwei kleine Verbesserungen am Code: wenn in der Arrow-Notation Ihre Funktion nur aus einer einzigen return -Anweisung besteht, dann k\u00f6nnen Sie die geschweiften Klammern Ihres Funktionsk\u00f6rpers weglassen und auch das return . D.h. aus response => { return response . json (); } wird response => response . json () Auch das Semikolon entf\u00e4llt. Das gilt aber nur f\u00fcr return -Anweisungen, nicht z.B. wenn die Funktion nur aus einer einzigen Konsolenausgabe besteht. Au\u00dferdem sollten wir auch noch ein catch() -Block einf\u00fcgen, f\u00fcr den Fall, dass ein Fehler auftritt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fetch ( 'https://httpbin.org/ip' ) . then ( response => response . json () ) . then ( data => { console . log ( data ); } ) . catch ( err => { console . log ( err ); } ); Den Fehlerfall k\u00f6nnen Sie ausprobieren, indem Sie einfach einen Fehler in die URL einbauen.","title":"GET-Anfragen mit fetch()"},{"location":"promises/#post-anfragen-mit-fetch","text":"POST -Anfragen werden verwendet, um Daten an den Webserver zu senden. Typischerweise sind das Formulardaten, die z.B. in eine Datenbank eingef\u00fcgt werden sollen. Wenn wir also mithilfe von fetch() eine POST -Anfrage stellen wollen, dann m\u00fcssen wir zwei Dinge beachten: wir m\u00fcssen fetch() explizit mitteilen, dass die verwendete HTTP-Anfrage-Methode POST ist und wir m\u00fcssen die Daten mitschicken. F\u00fcr ein einfaches Beispiel verwenden wir erneut https://httpbin.org , dieses Mal aber den Endpunkt /post , der uns einfach die gesendeten Daten wieder als Response unserer Abfrage zur\u00fcckschickt, also einfach als \"Spiegel\" fungiert. Eine entsprechende fetch() -Anweisung k\u00f6nnte so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fetch ( 'https://httpbin.org/post' , { method : 'POST' , header : { 'Content-Type' : 'application/json' , 'Accept' : 'application/json' }, body : JSON . stringify ({ message : 'just a POST mirror' }) }) . then ( response => response . json () ) . then ( data => { console . log ( data ); } ) . catch ( err => { console . log ( err ); } ); Die Zeilen 11-23 sind dabei zun\u00e4chst unver\u00e4ndert geblieben und sehen genauso aus wie die Zeilen 2-14 aus dem obigen GET -Beispiel. Nur die Parameter in der fetch() -Funktion haben sich ge\u00e4ndert. Der erste Parmeter lautet nun 'https://httpbin.org/post' , da wir die Anfrage an diese URL (diesen Endpunkt) stellen. Hinzugekommen ist ein zweiter Parameter, ein JSON: { me t hod : 'POST' , header : { 'Co ntent - Type' : 'applica t io n /jso n ' , 'Accep t ' : 'applica t io n /jso n ' }, body : JSON.s tr i n gi f y( { message : 'jus t a POST mirror' } ) } darin legen wir zun\u00e4chst mithilfe von method die HTTP-Anfrage-Methode fest. Standard ist GET , deshalb brauchten wir das in unserem ersten Beispiel nicht zu tun. Nun geben wir POST an. Au\u00dferdem definieren wir noch Eigenschaften f\u00fcr den header . Wir legen mithilfe von Content-Type fest, welches Format unsere Daten haben, die wir \u00fcbermitteln, n\u00e4mlich application/json . Au\u00dferdem legen wir mithilfe von Accept fest, in welchem Format wir die Daten empfangen wollen, n\u00e4mlich ebenfalls im JSON-Format. Diese Accept -Angabe ist nicht immer notwendig. Die meisten REST-Endpunkte liefern so oder so ein JSON zur\u00fcck. Das h\u00e4ngt von der Definition der REST-API ab. In der body -Eigenschaft definieren wir die Daten, die wir \u00fcbertragen wollen. In diesem Fall im JSON-Format. { message: 'just a POST mirror' } ist ein JavaScript-Objekt, das eine einzige Eigenschaft enth\u00e4lt, n\u00e4mlich message . Mithilfe der JavaScript-Standardfunktion JSON.stringify() wandeln wir dieses JavaScript-Objekt in ein JSON um. Somit wird ein JSON versendet, genau wie wir es im header unter Content-Type angegeben haben. F\u00fchren wir diesen Code aus, erhalten wir auf der Konsole folgende Ausgabe: Man k\u00f6nnte jetzt meinen, dass der Zugriff auf das Response-JSON ( {message: \"just a POST mirror\"} ) einfach \u00fcber response.data oder \u00fcber response.json erfolgen kann. Dem ist aber nicht so, da es sich bei dem body der response um ein Objekt vom Typ ReadableStream handelt. Das ist einerseits gut, denn die Daten vom Server werden asynchron als Stream empfangen, andererseits ist der Zugriff auf die Daten recht aufwendig. Wir werden darauf nochmal intensiver eingehen, wenn wir Bilder vom Backend laden. Ansonsten k\u00f6nnen Sie sich auch schonmal hier informieren oder sich hier und hier . Aber, wie gesagt, wir kommen eh nochmal darauf zur\u00fcck. Wenn Sie sich das zur\u00fcckgelieferte JSON schonmal anschauen wollen, dann ginge das z.B. so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 fetch ( 'https://httpbin.org/post' , { method : 'POST' , header : { 'Content-Type' : 'application/json' , 'Accept' : 'application/json' }, body : JSON . stringify ({ message : 'just a POST mirror' }) }) . then ( response => { console . log ( response ); return response ; } ) . then ( response => { console . log ( response . body ); // show the body, ReadableStream return response . body ; } ) . then ( body => { const reader = body . getReader (); return new ReadableStream ({ start ( controller ) { return pump (); function pump () { return reader . read (). then (({ done , value }) => { // When no more data needs to be consumed, close the stream if ( done ) { controller . close (); return ; } // Enqueue the next data chunk into our target stream controller . enqueue ( value ); // Uint8Array return pump (); }); } } }) }) . then ( stream => new Response ( stream )) . then ( response => response . json ()) // also possible: text(), blob(), ... . then ( response => { console . log ( response . json ); }) . catch ( err => { console . log ( err ); } );","title":"POST-Anfragen mit fetch()"},{"location":"promises/#fetch-vs-xmlhttprequest","text":"Wir haben eingangs erw\u00e4hnt, dass die Fetch API einen bequemeren und leistungsf\u00e4higeren Ersatz f\u00fcr XMLHttpRequest darstellt. Das sieht man einerseits bereits an der Code-L\u00e4nge. Das ist die Implementierung mit fetch() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fetch ( 'https://httpbin.org/ip' ) . then ( response => response . json () ) . then ( data => { console . log ( data ); } ) . catch ( err => { console . log ( err ); } ); und das hier macht genau das Gleiche mithilfe von XMLHttpRequest() : 1 2 3 4 5 6 7 8 9 10 11 12 13 let xhr = new XMLHttpRequest (); xhr . open ( 'GET' , 'https://httpbin.org/ip' ); xhr . responseType = 'json' ; xhr . onload = function () { console . log ( xhr . response ); } xhr . onerror = function () { console . log ( 'error' ); } xhr . send (); Ein ganz wesentlicher Unterschied liegt aber darin, dass bei Verwendung von XMLHttpRequest() deutlich mehr Sachen im Hintergrund synchron ablaufen, als bei der Fetch API. Das ist der Grund, dass wir bei der Implementierung von service workern die Fetch API verwenden m\u00fcssen und nicht auf das (alte) XMLHttpRequest() zugreifen k\u00f6nnen.","title":"Fetch vs. XMLHttpRequest"},{"location":"promises/#fetch-und-unser-service-worker","text":"Alle Code-Beispiele von oben (also die Promises und die fetch() -Beispiele) habe ich einfach in die app.js unseres HTW Insta -Beispiels eingetragen und ausprobiert. Das hei\u00dft, die app.js sieht jetzt gerade so aus: app.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( '/sw.js' ) . then (() => { console . log ( 'service worker registriert' ) }) . catch ( err => { console . log ( err ); } ); } let promise = new Promise (( resolve , reject ) => { setTimeout ( () => { // resolve('resolve -- Ausgabe A'); reject ({ code : 500 , message : 'An error occurred' }); }, 3000 ); }); promise . then ( value => { console . log ( value ); } ) . catch ( err => { console . log ( err . code , err . message ); } ); console . log ( 'Ausgabe B' ); fetch ( 'https://httpbin.org/ip' ) . then ( response => response . json () ) . then ( data => { console . log ( data ); } ) . catch ( err => { console . log ( err ); } ); let xhr = new XMLHttpRequest (); xhr . open ( 'GET' , 'https://httpbin.org/ip' ); xhr . responseType = 'json' ; xhr . onload = function () { console . log ( xhr . response ); } xhr . onerror = function () { console . log ( 'error' ); } xhr . send (); fetch ( 'https://httpbin.org/post' , { method : 'POST' , header : { 'Content-Type' : 'application/json' , 'Accept' : 'application/json' }, body : JSON . stringify ({ message : 'just a POST mirror' }) }) . then ( response => { console . log ( response ); return response ; } ) . then ( response => { console . log ( response . body ); return response . body ; } ) . then ( body => { const reader = body . getReader (); return new ReadableStream ({ start ( controller ) { return pump (); function pump () { return reader . read (). then (({ done , value }) => { // When no more data needs to be consumed, close the stream if ( done ) { controller . close (); return ; } // Enqueue the next data chunk into our target stream controller . enqueue ( value ); return pump (); }); } } }) }) . then ( stream => new Response ( stream )) . then ( response => response . json ()) . then ( response => { console . log ( response . json ); }) . catch ( err => { console . log ( err ); } ); Au\u00dferdem haben wir ja in unserer Anwendung bereits einen service worker registriert und auch in schon in Ans\u00e4tzen implementiert: sw.js 1 2 3 4 5 6 7 8 9 10 11 12 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) self . addEventListener ( 'fetch' , event => { console . log ( 'service worker --> fetching ...' , event ); }) Ich er\u00e4hne das nur deshalb, weil unsere Konsole bei Ausf\u00fchrung der Anwendung jetzt ungef\u00e4hr so aussieht: Es erscheint also ganz oft die Ausgabe des fetch -Events, genau wie in der sw.js in den Zeilen 10-12 implementiert. Das fetch -Event wird immer dann ausgel\u00f6st, wenn die Anwendung etwas vom Webserver l\u00e4dt. Das sind einerseits alle Ressourcen, die wir in der index.html -datei definiert haben (alle *.js und alle *.css und alle *.png -Dateien), aber auch die fetch() -Anweisungen, die wir in der app.js implementiert haben! Wir werden auf der Konsole auch die fetch -Ereignisse finden, die den Zugriff auf https://httpbin.org/ip bzw. https://httpbin.org/post ausf\u00fchren. Wir merken uns also fetch -Ereignisse werden automatisch ausgel\u00f6st durch das Laden von ressourcen, so wie in den *.html -Dateien der Anwendung definiert, aber auch durch manuell ausgel\u00f6ste (implementierte) fetch() -Anfragen. Das ist wichtig, wenn wir in unserem service worker die fetch -Ereignisse behandeln werden. Success Wir kennen nun Promises und die Fetch API und k\u00f6nnen beides anwenden. Wir werden Promises von nun an permanent verwenden. Insbesondere den consuming code f\u00fcr Promises, als .then().catch() . Mithilfe der Fetch API werden wir alle HTTP-Anfragen an den Server stellen k\u00f6nnen, also GET , POST , PUT und DELETE und dabei das asynchrone Prinzip dieser API bestm\u00f6glich ausnutzen.","title":"fetch() und unser service worker"},{"location":"serviceworker/","text":"Service Workers \u00b6 Wir betrachten einen wichtigen Grundbaustein, der solche Funktionalit\u00e4ten, wie Push-Notifikationen, Hintergrund-Synchronisationen und die M\u00f6glichkeit, auch offline die Anwendung auszuf\u00fchren, erst erm\u00f6glicht: sogenannte Service Workers . Ein service worker ist zun\u00e4chst einmal ein Skript (in JavaScript), welches im Browser im Hintergrund l\u00e4uft, unabh\u00e4ngig von der Webseite. Ein service worker stellt Funktionalit\u00e4ten, wie Push-Notifikationen oder Hintergrund-Synchronisationen zur Verf\u00fcgung, \u00e4hnlich einer API. Entstanden sind service worker aus der Verwendung des Application Caches . Die service worker API w\u00e4chst kontinuierlich und bietet zunehmend weitere Funktionalit\u00e4ten. Service worker haben einige n\u00fctzliche Eigenschaften: Ein service worker kann zwar nicht direkt das DOM einer Seite manipulieren, kann aber auf Requests der Seite mit Responses reagieren und die Seite selbst kann darufhin ihr DOM \u00e4ndern. Ein service worker ist ein \"programmierbarer\" Proxy, der steuert, wie Requests von der Webseite behandelt werden. Service workers verwenden die IndexDB API , um client-seitig strukturierte Daten persistent zu speichern. Service workers verwenden Promises . Wir werden uns deshalb Promises detailliert anschauen. Die folgenden Abbildungen verdeutlichen die Arbeitsweise eines service workers . Zun\u00e4chst \u00fcberlegen wir uns nochmal, wie \"normales\" JavaScript in Webanwendungen ausgef\u00fchrt wird. Die JS-Skripte werden mit den HTML-Seiten geladen. Sie stellen Funktionen bereit, die entweder durch Nutzerinteraktionen (z.B. click ) oder durch Lifecycle -Events (z.B. onload ) ausgel\u00f6st und aufgerufen werden. Diese Funktionen laufen alle in einem einzigen Thread: . Service worker laufen auf einem eigenen Thread. Service worker werden an HTML-Seiten registriert, laufen aber g\u00e4nzlich unabh\u00e4ngig von ihnen. Sie laufen sogar dann, wenn die HTML-Seiten geschlossen sind. Service worker laufen im Hintergrund , es handelt sich um Hintergrundprozesse . Service worker sind zwar JavaScript, manipulieren aber nicht den DOM. Sie sind nicht an HTML-Seiten gebunden, sondern an eine Domain. Service worker reagieren ebenfalls auf Ereignisse, aber andere, als wir sie von Webanwendungen kennnen, z.B. auf Push-Notifikationen. . Service worker laufen einfach im Hintergrund und warten auf Ereignisse. Welche Ereignisse k\u00f6nnen das sein? Ereignisse, auf die Service Worker reagieren k\u00f6nnen \u00b6 Wir betrachten hier einige der Ereignisse, auf die service worker reagieren k\u00f6nnen, auf die sie also \"h\u00f6ren\". Fetch \u00b6 Wann immer der Browser etwas vom Webserver l\u00e4dt, f\u00fchrt er ein fetch -Ereignis aus. Das kann eine HTML-Seite, aber auch ein Bild ( img ), eine CSS-Datei oder eine JavScript-Datei sein. Ein service worker kann auf ein solches Ereignis reagieren. Tats\u00e4chlich agiert der service worker als ein Proxy , der zwischen dem Browser und dem Webserver steht und die fetch -Anfragen ( requests ) des Browsers empf\u00e4ngt und eventuell an den Webserver weiterleitet. Eventuell leitet er die Anfrage auch nicht weiter, sondern beantwortet sie mit einer Resource aus dem eigen Cache. F\u00fcr die fetch -Ereignisse wird die Fetch-API verwendet, auf die wir sp\u00e4ter noch ausf\u00fchrlich zu sprechen kommen. Wichtig ist an dieser Stelle zu erw\u00e4hnen, dass ein (asynchrones) XMLHttpRequest kein fetch -Ereignis darstellt. Eine Single-Page-Application, die Ressourcen vom Browser nachl\u00e4dt, ruft dabei keine (weiteren) fetch -Ereignisse auf. Push-Notifikationen \u00b6 Push-Notifikationen werden von einem (anderen) Server gesendet und k\u00f6nnen durch service worker verwaltet werden. Jeder Browser verf\u00fcgt \u00fcber eigene Push-Web-Server. Es k\u00f6nnen von jedem beliebigen Server Push-Nachrichten an diese Push-Web-Server gesendet werden. Der service worker kann auf solche Ereignisse reagieren. Wichtig ist hier zu wiederholen, dass service worker auch dann (im Hintergrund) arbeiten, wenn die Webanwendung selbst geschlossen ist. Sie k\u00f6nnen trotzdem erkennen, wenn Push-Nachrichten eingehen und darauf geeignet reagieren. Auch hier wirken service worker wieder wie ein Proxy , n\u00e4mlich f\u00fcr die Push-Web-Server. Der service worker kann z.B. eine Nachricht auf dem Startbildschirm des Smartphones erzeugen. Mit dieser Nachricht kann die Nutzerin dann etwas machen und l\u00f6st dabei das folgende Ereiegnis aus: Notification interaction \u00b6 Klickt eine Nutzerin auf die (Push-)Nachricht, die vom service worker erzeugt wurde, wird ein entsprechendes Ereignis ausgel\u00f6st, auf das wiederum der service worker reagieren kann, z.B. eine Webseite aufrufen und \u00f6ffnen oder eine Anwendung. Auch hier ist es wieder wichtig, dass das ein service worker erledigt und nicht ein JavaScript, welches zu einer Webanwendung geh\u00f6rt, da es ja sein kann, dass diese Webanwendung geschlossen ist. Hintergrund-Synchronisation \u00b6 Es kann passieren, dass in einer Webanwendung Ereignisse ausgef\u00fchrt werden, jedoch keine Verbindung zum Internet besteht. Typischerweise werden die Ausf\u00fchrungen solcher Ereignisse, die offline ausgef\u00fchrt werden, ebenfalls durch service worker erledigt. Sobald der Browser wieder mit dem Internet verbunden ist, l\u00f6st er ein Ereignis aus. Auf dieses Ereignis kann der service worker reagieren und die Ereignisse, die er offline gespeichert und beantwortet hat, nun im Hintergrund online ausf\u00fchren, so dass eine Hintergrund-Synchronisation erfolgt. Service-worker-Lifecycle-Ereignisse \u00b6 Ein service worker durchl\u00e4uft selbst einen eigenen \"Lebenszyklus\". Wir kennen Liefecycle-Events bereits aus Angular, z.B. ngOnInit() oder auch von Webseiten ( load ). Solche Lifecycle-Events existieren auch f\u00fcr service worker. Wir werden sie uns sp\u00e4ter im Detail anschauen. Zuerst betrachten wir aber zur Einf\u00fchrung ein einfaches Beispiel f\u00fcr die Verwendung eines service workers (wie wir gleich im Anschluss dikutieren werden, handelt es sich eigentlich um einen web worker ). Einfaches Beispiel service worker \u00b6 Wir betrachten ein erstes einfaches Beispiel f\u00fcr die Verwendung eines service workers. Wir erstellen folgende index.html . index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!DOCTYPE HTML> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > Erstes Beispiel service worker </ title > </ head > < body > < p > Gr\u00f6\u00dfte Primzahl bisher: < output id = \"result\" ></ output ></ p > < script > var worker = new Worker ( 'worker.js' ); worker . onmessage = function ( event ) { document . getElementById ( 'result' ). textContent = event . data ; }; </ script > </ body > </ html > In Zeile 10 wird mithilfe des Worker -Kunstruktors ein Worker -Objekt erzeugt. Dem Konstruktor wird die Implementierung des workers \u00fcbergeben, genauer gesagt, die Implementierung des Event-Handlers f\u00fcr onmessage des Worker -Objektes. Die Implementierung des onmessage -Event-Handlers sieht typischerweise so aus, dass der service worker mit einer postMessage antwortet und diese an die Seite \u00fcbergibt. In unserem Beispiel ist die Implementierung wie folgt: worker.js 1 2 3 4 5 6 7 8 9 var n = 1 ; search : while ( true ) { n += 1 ; for ( var i = 2 ; i <= Math . sqrt ( n ); i += 1 ) if ( n % i == 0 ) continue search ; // found a prime! postMessage ( n ); } Zeile 8 enth\u00e4lt die postMessage . Darin wird eine Zahl n an die Seite geschickt, sobald sie berechnet wurde. Es handelt sich bei der Berechnung um eine Primzahlberechnung. Das hei\u00dft, der service worker arbeitet im Hintergrund und \"sucht\" neue Primzahlen. Sobald der service worker eine neue Primzahl gefunden hat, schickt er diese mithilfe der postMessage() -Funktion an die Webseite. Dadurch wird das onmessage -Ereignis (genauer gesagt, handelt es sich um das message -Event) behandelt. Wann immer onmessage auftritt, aktualisiert die Seite, genauer gesagt, der textContent des <output> -Elementes mit der id= \"result\" (siehe Zeilen 11-13 in index.html ). Dieses Beispiel ist extra einfach gehalten. genauer gesagt, handelt es sich bei dem Beispiel \"nur\" um einen web worker . Das W3C unterscheidet zwischen service workers und web workers . Der Unterschied zwischen web worker und * service worker* wird z.B. hier beschrieben. Web worker vs. service worker \u00b6 Wir verwenden f\u00fcr die Unterscheidung zwischen web worker und service worker haupts\u00e4chlich dieses Dokument . Darin finden wir auch folgendes Bild zur Beschreibung eines web workers: Ein web worker hat kein spezifisches Einsatzszenario, au\u00dfer dass er unabh\u00e4ngig von Hauptthread der Anwendung l\u00e4uft und Nachrichten mittels postMessage() an die Anwendung schicken kann. Demgegen\u00fcber ist ein service worker ein spezieller web worker , der als Proxy zwischen Anwendung und dem Netzwerk bzw. dem Cache agiert. Service workers verf\u00fcgen \u00fcber mehr Funktionalit\u00e4ten als web workers . Dazu geh\u00f6ren einerseits die Ereignisse, auf die service workers reagieren k\u00f6nnen: install und activate (sogenannte Lifecycle events ), fetch und weitere Ereignisse, die durch Erweiterungen spezifiziert werden, z.B. push , notificationclick , notificationclose , sync , canmakepayment , paymentrequest usw. (sogenannte Functional events ) sowie message und messageerror vom Web worker und andererseits die Status, in denen sich ein service worker befinden kann: parsed , installing , installed , activating , activated und redundant (initial: parsed ) Die prinzipielle Idee der Registrierung eines service workers sieht so aus: Die beiden Lifecycle-Events install und activate sind bereits eingezeichnet. Dabei ist zu betonen, dass ein service worker erst dann aktiviert werden kann, wenn kein anderer service worker mehr (in der gleichen Dom\u00e4ne/im gleichen Scope) l\u00e4uft. Ein anderer service worker, der eventuell noch l\u00e4uft, muss erst geschlossen werden, bevor der neue service worker das activate -Ereignis ausl\u00f6sen kann. Damit ein solcher \"alter\" service worker geschlossen werden kann, m\u00fcssen zumindest alle Tabs im Browser, in denen die Webanwendung l\u00e4uft, geschlossen werden. Selbst dann l\u00e4uft der service worker aber immernoch weiter. Er muss explizit geschlossen werden. Das zeigen wir sp\u00e4ter. Registrierung eines service workers \u00b6 W\u00e4hrend wir f\u00fcr das einfache Beispiel mit dem web worker noch den Worker() -Konstruktor verwendet haben, erfolgt die Registrierung eines service workers mittels navigator.serviceWorker.register('./sw.js') , wobei in sw.js der service worker implementiert ist. Wir schauen uns die prinzipielle Registrierung an: index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 <! DOCTYPE HTML > < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > Erstes Beispiel service worker < /title> < /head> < body > < p > \u00d6ffne die developer tools < /p> < script > if ( 'serviceWorker' in navigator ) { // Register a service worker hosted at the root of the // site using the default scope. navigator . serviceWorker . register ( './sw.js' ). then ( function ( registration ) { console . log ( 'Service worker registration succeeded:' , registration ); console . log ( 'Scope ist ' + registration . scope ); // At this point, you can optionally do something // with registration. See https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration }). catch ( function ( error ) { console . log ( 'Service worker registration failed:' , error ); }); // Independent of the registration, let's also display // information about whether the current page is controlled // by an existing service worker, and when that // controller changes. // First, do a one-off check if there's currently a // service worker in control. if ( navigator . serviceWorker . controller ) { console . log ( 'This page is currently controlled by:' , navigator . serviceWorker . controller ); } // Then, register a handler to detect when a new or // updated service worker takes control. navigator . serviceWorker . oncontrollerchange = function () { console . log ( 'This page is now controlled by:' , navigator . serviceWorker . controller ); }; } else { console . log ( 'Service workers are not supported.' ); } < /script> < /body> < /html> Wir haben hier die registrierung des service workers innerhalb des <script> -Elementes. Besser (und das werden wir sp\u00e4ter auch immer machen) ist die Erstellung einer eigenen .js -Datei daf\u00fcr. Wenn wir die Developer Tools \u00f6ffnen, sehen wir auf der Console folgende Ausgabe: F\u00fcr diejenigen, f\u00fcr die das Registrierungs-Beispiel oben zu lang ist, hier die Version von W3C : 1 2 3 4 5 6 7 8 9 10 // scope defaults to the path the script sits in // \"/\" in this example navigator . serviceWorker . register ( \"/serviceworker.js\" ). then ( registration => { console . log ( \"success!\" ); if ( registration . installing ) { registration . installing . postMessage ( \"Howdy from your installing page.\" ); } }, err => { console . error ( \"Installing the worker failed!\" , err ); }); Registrierung eines service workers in HTW-Insta \u00b6 Nun, da wir wissen, wie die Registrierung eines service workers prinzipiell funktioniert, f\u00fcgen wir unserem HTW-Insta -Beispiel einen solchen hinzu. Den aktuellen Stand der Anwendung finden Sie unter IKT-PWA-02 . Das ist die Version, in der bereits das Web-App-Manifest enthalten ist. Zun\u00e4chst beachten wir noch einen besonderen Eintrag in der package.json : package.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"name\" : \"IKT-PWA-02\" , \"version\" : \"1.0.0\" , \"description\" : \"Grundger\u00fcst einer PWA mit Web-App-Manifest\" , \"main\" : \"index.js\" , \"scripts\" : { \"start\" : \"http-server -c-1\" }, \"keywords\" : [ \"pwa\" , \"progressive\" , \"web\" , \"app\" , \"ikt\" , \"htw\" , \"fiw\" ], \"author\" : \"J. freiheit\" , \"license\" : \"ISC\" , \"devDependencies\" : { \"http-server\" : \"^14.1.0\" } } In Zeile 7 wird definiert, dass wir bei Aufruf des npm start -Befehls den Webserver http-server starten. Das Argument -c-1 besagt, dass wir f\u00fcr diesen Server nicht den Browser-Cache verwenden wollen. Jede datei, die wir somit vom Webserver anfordern, wird somit auch tats\u00e4chlich neu geladen. Stattdessen wollen wir n\u00e4mlich nur den Cache des service workers verwenden. F\u00fcr unseren service worker erstellen wir uns im public -Ordner eine Datei sw.js . Da der service worker im public -Ordner angelegt wird, ist sein Scope unsere komplette Webanwendung. Wollten wir z.B. einen service worker, der nur f\u00fcr unsere Hilfe-Seiten zust\u00e4ndig ist, so h\u00e4tten wir die Datei im help -Ordner erzeugt. Um unseren service worker zu registrieren, m\u00fcssen wir ihn in alle unsere HTML-Seiten einbinden. Wir haben die /public/index.html -Datei und die /public/help/index.html . Dort k\u00f6nnten wir innerhalb des eines <script> -Elementes die Registrierung durchf\u00fchren. Da wir aber bereits in beiden Dateien die Datei public/src/js/app.js einbinden, erledigen wir die Registrierung einfach dort. Dann ist sie nur an einer Stelle und wir m\u00fcssen die HTML-Dateien nicht anpassen. In die /public/src/js/app.js schreiben wir nun Folgendes: /public/src/js/app.js 1 2 3 4 5 6 7 if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( '/sw.js' ) . then ( function () { console . log ( 'service worker registriert' ) }); } Starten unserer Anwendung und Aufruf im Browser ergibt die Ausgabe service worker registriert in der Konsole der DevTools. Im Zusammenhang mit service workern gibt es folgendes zu beachten: service worker funktionieren nur mit https oder auf localhost! Wundern Sie sich also nicht, wenn Ihr service worker nicht funktioniert, sobald Sie Ihre Anwendung auf einem Webserver ausf\u00fchren, der https nicht unterst\u00fctzt. Anleitungen, wie Sie einen Webserver f\u00fcr https konfigurieren, finden Sie z.B. hier . Schauen Sie ansonsten auch hier und hier . Service worker: Life-Cycle-Ereignisse behandeln \u00b6 Nun implementieren wir den service worker. Wir haben ihn bereits registriert, aber die Datei sw.js ist noch leer. Die grundlegende Idee eines service workers ist es, Ereignisse zu behandeln. Wir werden unserem service worker also eine Reihe von addEventListener() -Funktionen hinzuf\u00fcgen. Diese Funktion kennen wir bereits aus \"normalem\" JavaScript-Code. Dort haben h\u00e4ufig so etwas wie addEventListener('click', function() { /* ... */ }) geschrieben. Das click -Ereignis hat aber keine Relevanz f\u00fcr service worker, da ein service worker keine Auswirkungen auf das DOM hat. Vielmehr reagiert ein service worker auf Ereignisse, die wir bereits oben beschrieben haben. Wir f\u00fcgen unserem service worker Ereignisbehandlungen hinzu: /public/src/sw.js 1 2 3 4 5 6 7 8 self . addEventListener ( 'install' , function ( event ) { console . log ( 'service worker --> installing ...' , event ); }) self . addEventListener ( 'activate' , function ( event ) { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) Wir melden uns also an zwei Ereignisse an: an das install -Ereignis und das activate -Ereignis. Beide Ereignisse sind auch gut hier beschrieben. Beide Ereignisbehandlungen sind zun\u00e4chst einfache Ausgaben auf die Konsole. Zwei Sachen sind noch erw\u00e4hnenswert: erstens wird self verwendet, um auf den service worker zu referenzieren. F\u00fcr Erl\u00e4uterungen \u00fcber den Unterschied von this und self k\u00f6nnen Sie sich z.B. hier informieren. Grunds\u00e4tzlich ist es so, dass mit self auf den gesamten Scope referenziert wird. In Webanwendungen ist der Scope h\u00e4ufig window , hier ist es aber die Domain, die den Scope des service workers beschreibt. Wir referenzieren also nicht auf den service worker selbst, sondern auf seinen Scope. Die zweite erw\u00e4hnenswerte Sache steht in Zeile 7 . Wenn ein service worker registriert ist, dann \"kontrolliert\" er nicht automatisch alle Webseiten in seiner Domain. Erst durch das Neuladen dieser Seiten gelangen sie unter seine Kontrolle. Mithilfe der claim() -Funktion aus dem Interface Clients \u00fcbernimmt der service worker die Kontrolle aber sofort, d.h. ohne ein Neuladen der Site. Einzige Ausnahme ist die Seite, die aktuell im Browser gezeigt wird. F\u00fcr diese muss tats\u00e4chlich ein Reload durchgef\u00fchrt werden. Weitere Informationen dazu finden Sie auch hier . Wenn wir die Anwendung nun starten und dann im Browser aufrufen, erhalten wir folgende Ausgabe auf der Konsole: Wir sehen, dass das install -Ereignis ausgel\u00f6st wurde, aber offensichtlich nicht das activate -Ereignis. Warum wurde das activate -Ereignis nicht ausgel\u00f6st? Darum k\u00fcmmern wir uns im folgenden Abschnitt. Noch eine kurze Bemerkung zur Reihenfolge der Ausgaben auf der Konsole. Auf der Konsole haben wir folgende Ausgaben: service worker registriert service worker --> installing ... Das verwundert wahrscheinlich, weil das install -Event ausgel\u00f6st wird, bevor der service worker (existiert und) registriert werden kann. Also m\u00fcssten die Ausgaben eigentlich in der anderen Reihenfolge erscheinen. Wir erinnern uns (siehe zweite Abbildung ganz oben in diesem Kapitel): der service worker l\u00e4uft auf einem anderen Thread, als das \"normale\" JavaScript unserer Webanwendung. Also laufen app.js und sw.js auf verschiedenen Threads. In welchem dieser beiden Threads nun zuerst eine Ausgabe erfolgt, h\u00e4ngt von vielen verschiedenen Faktoren ab, l\u00e4sst sich aber auch nicht beeinflussen. Dieses Mal war es so, dass der app.js -Thread schneller mit der Ausgabe war, als der sw.js -Thread. Das kann beim n\u00e4chsten Mal schon anders sein. Wichtig ist, dass wir wissen, dass diese beiden Threads g\u00e4nzlich nebenl\u00e4ufig und unabh\u00e4ngig voneinander laufen. Sollten sich dabei Ausgaben \"\u00fcberholen\", dann ist das kein Bug, sondern ein Feature. Service worker aktualisieren und aktivieren \u00b6 Warum wurde das activate -Ereignis nicht ausgel\u00f6st? Dazu werfen wir einen Blick in unsere DevTools. Wir w\u00e4hlen den Reiter Application und dann im linken Men\u00fc unter Application den Men\u00fcpunkt Service Woorkers : Wir sehen, dass der service worker im Status des Aktivierens ist, aber noch darauf wartet, aktiviert zu sein ( waiting to activate ). Hierzu ist es wichtig zu wissen: solange Sie im Browser (mindestens) einen Tab mit Ihrer Webanwendung offen haben, wird ein neuer service worker zwar installiert und registriert, aber nicht aktiviert, das liegt daran, dass die offene Seite eventuell noch mit einem alten service worker kommuniziert (evtl. hat der alte service worker noch etwas im Cache, das mit der Webanwendung synchronisiert werden m\u00fcsste). Wenn wir den Tab mit unserer Anwendung schlie\u00dfen und ihn erneut \u00f6ffnen, dann sehen wir: Es wurden also sowohl das install - als auch das activate -Ereignis ausgel\u00f6st. Auf der Konsole erscheint entsprechend: Wenn Sie Ihren service worker aktualisiert haben, m\u00fcssen Sie alle Tabs Ihrer Webanwendung schlie\u00dfen und erneut \u00f6ffnen, um den neuen service worker zu aktivieren! Beherzigen Sie die obige Ausgabe. Es kann Ihnen sehr viel Implementierungskummer bereiten, wenn Sie es nicht tun. Sie ver\u00e4ndern Ihren Code im service worker, aber die \u00c4nderungen sind nicht wirksam? Dann haben Sie vielleicht nur ein Reload Ihrer Webanwendung durchgef\u00fchrt - das reicht aber f\u00fcr den aktualisierten service worker nicht ! Aber zum Gl\u00fcck bieten die DevTools Hilfe, so dass Sie w\u00e4hrend der Entwicklung doch nicht immer den Tab schlie\u00dfen und neu \u00f6ffnen m\u00fcssen. Betrachten wir nochmals die folgende Abbildung: Sie haben drei M\u00f6glichkeiten, den service zu aktivieren: Markieren Sie die Checkbox links neben Update on reload . Dann wird durch das Reload Ihrer Webanwendung der aktualisierte service worker aktiviert. Klicken Sie auf den Link Update oder Klicken Sie auf den Link skipWaiting . Mit einem der drei Hilfen oben vermeiden Sie das Schlie\u00dfen und Neu\u00f6ffnen des Tabs und der Webanwendung. Am einfachsten ist die erste Variante. Dann m\u00fcssen Sie nur noch Reloaden und ansonsten weiter gar nichts machen. Arrow-Notation verwenden \u00b6 Wenn wir uns die Implementierung des service workers anschauen, dann sehen wir, dass wir etwas \"old school\" unterwegs sind, also so ca. 2017 ;-). Wir sollten anstelle der function() -Notation lieber die Arrow -Notation verwenden, um ein bisschen mehr up-to-date zu sein ;-). Zu Arrow-Notation siehe auch Hilfen\u2192Arrow-Notation . Unsere service worker Implementierung sieht dann so aus: /public/src/sw.js 1 2 3 4 5 6 7 8 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) Die neuere Notation \u00e4ndert an der Funktionalit\u00e4t nat\u00fcrlich nichts. Service worker: andere Ereignisse behandeln \u00b6 Bis jetzt haben wir nur Life-Cycle-Events behandelt. Jetzt schauen wir uns einmal das fetch -Ereignis an. Wir wissen bereits , dass das fetch -Ereignis immer dann ausgel\u00f6st wird, wenn etwas vom Webserver geladen wird, wenn also CSS-Dateien oder ein Bild oder JavaScript-Dateien geladen werden. Wir behandeln ein solches Ereignis wiederum mit einer einfachen Konsolen-Ausgabe: /public/src/sw.js 1 2 3 4 5 6 7 8 9 10 11 12 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) self . addEventListener ( 'fetch' , event => { console . log ( 'service worker --> fetching ...' , event ); }) Falls wir in den DevTools unter Application \u2192 Application \u2192 Service Workers das H\u00e4kchen bei Update on Reload gesetzt hatten, m\u00fcssen wir tats\u00e4chlich nur ein Reload der Webanwendung durchf\u00fchren und wir sehen auf der Konsole, dass das fetch -Event selbst f\u00fcr unsere bis jetzt sehr kleine Anwendung recht h\u00e4ufig aufgerufen wird: Wenn Sie in die jeweiligen FetchEvent -Objekte hineinklicken, welche Ressourcen jeweils per GET vom Webserver geladen werden. Anwendung mit einem Android-Ger\u00e4t verbinden \u00b6 Ich kann es leider (bis jetzt noch) nicht ausprobieren, aber hier ist beschrieben, wie Sie die Anwendung auf einem Android-Ger\u00e4t aufrufen k\u00f6nnen. Nun, da wir service worker verwenden, sollte es funktionieren. Das hier mag auch hilfreich sein. Anwendung auf Ihrem iPhone aufrufen \u00b6 Um die Anwendung auf Ihrem iPhone aufzurufen, m\u00fcssen Sie sich zun\u00e4chst nur anschauen, was im Terminal ausgegeben wird, nachdem Sie npm start aufgerufen haben: Starting up http-server, serving ./public Available on: http://127.0.0.1:8080 htpp://192.168.1.24:8080 Hit CTRL-C to stop the server Rufen Sie in Ihrem iPhone einen Browser auf (z.B. Safari oder Chrome) und geben dort di ezweite der beiden URLs ein (also htpp://192.168.1.24:8080 ). Die Anwendung wird ausgef\u00fchrt. iOS unterst\u00fctzt aber leider (noch) nicht, dass Sie ein Start-Icon daf\u00fcr auf den Startbildschirm ablegen.","title":"Service worker"},{"location":"serviceworker/#service-workers","text":"Wir betrachten einen wichtigen Grundbaustein, der solche Funktionalit\u00e4ten, wie Push-Notifikationen, Hintergrund-Synchronisationen und die M\u00f6glichkeit, auch offline die Anwendung auszuf\u00fchren, erst erm\u00f6glicht: sogenannte Service Workers . Ein service worker ist zun\u00e4chst einmal ein Skript (in JavaScript), welches im Browser im Hintergrund l\u00e4uft, unabh\u00e4ngig von der Webseite. Ein service worker stellt Funktionalit\u00e4ten, wie Push-Notifikationen oder Hintergrund-Synchronisationen zur Verf\u00fcgung, \u00e4hnlich einer API. Entstanden sind service worker aus der Verwendung des Application Caches . Die service worker API w\u00e4chst kontinuierlich und bietet zunehmend weitere Funktionalit\u00e4ten. Service worker haben einige n\u00fctzliche Eigenschaften: Ein service worker kann zwar nicht direkt das DOM einer Seite manipulieren, kann aber auf Requests der Seite mit Responses reagieren und die Seite selbst kann darufhin ihr DOM \u00e4ndern. Ein service worker ist ein \"programmierbarer\" Proxy, der steuert, wie Requests von der Webseite behandelt werden. Service workers verwenden die IndexDB API , um client-seitig strukturierte Daten persistent zu speichern. Service workers verwenden Promises . Wir werden uns deshalb Promises detailliert anschauen. Die folgenden Abbildungen verdeutlichen die Arbeitsweise eines service workers . Zun\u00e4chst \u00fcberlegen wir uns nochmal, wie \"normales\" JavaScript in Webanwendungen ausgef\u00fchrt wird. Die JS-Skripte werden mit den HTML-Seiten geladen. Sie stellen Funktionen bereit, die entweder durch Nutzerinteraktionen (z.B. click ) oder durch Lifecycle -Events (z.B. onload ) ausgel\u00f6st und aufgerufen werden. Diese Funktionen laufen alle in einem einzigen Thread: . Service worker laufen auf einem eigenen Thread. Service worker werden an HTML-Seiten registriert, laufen aber g\u00e4nzlich unabh\u00e4ngig von ihnen. Sie laufen sogar dann, wenn die HTML-Seiten geschlossen sind. Service worker laufen im Hintergrund , es handelt sich um Hintergrundprozesse . Service worker sind zwar JavaScript, manipulieren aber nicht den DOM. Sie sind nicht an HTML-Seiten gebunden, sondern an eine Domain. Service worker reagieren ebenfalls auf Ereignisse, aber andere, als wir sie von Webanwendungen kennnen, z.B. auf Push-Notifikationen. . Service worker laufen einfach im Hintergrund und warten auf Ereignisse. Welche Ereignisse k\u00f6nnen das sein?","title":"Service Workers"},{"location":"serviceworker/#ereignisse-auf-die-service-worker-reagieren-konnen","text":"Wir betrachten hier einige der Ereignisse, auf die service worker reagieren k\u00f6nnen, auf die sie also \"h\u00f6ren\".","title":"Ereignisse, auf die Service Worker reagieren k\u00f6nnen"},{"location":"serviceworker/#fetch","text":"Wann immer der Browser etwas vom Webserver l\u00e4dt, f\u00fchrt er ein fetch -Ereignis aus. Das kann eine HTML-Seite, aber auch ein Bild ( img ), eine CSS-Datei oder eine JavScript-Datei sein. Ein service worker kann auf ein solches Ereignis reagieren. Tats\u00e4chlich agiert der service worker als ein Proxy , der zwischen dem Browser und dem Webserver steht und die fetch -Anfragen ( requests ) des Browsers empf\u00e4ngt und eventuell an den Webserver weiterleitet. Eventuell leitet er die Anfrage auch nicht weiter, sondern beantwortet sie mit einer Resource aus dem eigen Cache. F\u00fcr die fetch -Ereignisse wird die Fetch-API verwendet, auf die wir sp\u00e4ter noch ausf\u00fchrlich zu sprechen kommen. Wichtig ist an dieser Stelle zu erw\u00e4hnen, dass ein (asynchrones) XMLHttpRequest kein fetch -Ereignis darstellt. Eine Single-Page-Application, die Ressourcen vom Browser nachl\u00e4dt, ruft dabei keine (weiteren) fetch -Ereignisse auf.","title":"Fetch"},{"location":"serviceworker/#push-notifikationen","text":"Push-Notifikationen werden von einem (anderen) Server gesendet und k\u00f6nnen durch service worker verwaltet werden. Jeder Browser verf\u00fcgt \u00fcber eigene Push-Web-Server. Es k\u00f6nnen von jedem beliebigen Server Push-Nachrichten an diese Push-Web-Server gesendet werden. Der service worker kann auf solche Ereignisse reagieren. Wichtig ist hier zu wiederholen, dass service worker auch dann (im Hintergrund) arbeiten, wenn die Webanwendung selbst geschlossen ist. Sie k\u00f6nnen trotzdem erkennen, wenn Push-Nachrichten eingehen und darauf geeignet reagieren. Auch hier wirken service worker wieder wie ein Proxy , n\u00e4mlich f\u00fcr die Push-Web-Server. Der service worker kann z.B. eine Nachricht auf dem Startbildschirm des Smartphones erzeugen. Mit dieser Nachricht kann die Nutzerin dann etwas machen und l\u00f6st dabei das folgende Ereiegnis aus:","title":"Push-Notifikationen"},{"location":"serviceworker/#notification-interaction","text":"Klickt eine Nutzerin auf die (Push-)Nachricht, die vom service worker erzeugt wurde, wird ein entsprechendes Ereignis ausgel\u00f6st, auf das wiederum der service worker reagieren kann, z.B. eine Webseite aufrufen und \u00f6ffnen oder eine Anwendung. Auch hier ist es wieder wichtig, dass das ein service worker erledigt und nicht ein JavaScript, welches zu einer Webanwendung geh\u00f6rt, da es ja sein kann, dass diese Webanwendung geschlossen ist.","title":"Notification interaction"},{"location":"serviceworker/#hintergrund-synchronisation","text":"Es kann passieren, dass in einer Webanwendung Ereignisse ausgef\u00fchrt werden, jedoch keine Verbindung zum Internet besteht. Typischerweise werden die Ausf\u00fchrungen solcher Ereignisse, die offline ausgef\u00fchrt werden, ebenfalls durch service worker erledigt. Sobald der Browser wieder mit dem Internet verbunden ist, l\u00f6st er ein Ereignis aus. Auf dieses Ereignis kann der service worker reagieren und die Ereignisse, die er offline gespeichert und beantwortet hat, nun im Hintergrund online ausf\u00fchren, so dass eine Hintergrund-Synchronisation erfolgt.","title":"Hintergrund-Synchronisation"},{"location":"serviceworker/#service-worker-lifecycle-ereignisse","text":"Ein service worker durchl\u00e4uft selbst einen eigenen \"Lebenszyklus\". Wir kennen Liefecycle-Events bereits aus Angular, z.B. ngOnInit() oder auch von Webseiten ( load ). Solche Lifecycle-Events existieren auch f\u00fcr service worker. Wir werden sie uns sp\u00e4ter im Detail anschauen. Zuerst betrachten wir aber zur Einf\u00fchrung ein einfaches Beispiel f\u00fcr die Verwendung eines service workers (wie wir gleich im Anschluss dikutieren werden, handelt es sich eigentlich um einen web worker ).","title":"Service-worker-Lifecycle-Ereignisse"},{"location":"serviceworker/#einfaches-beispiel-service-worker","text":"Wir betrachten ein erstes einfaches Beispiel f\u00fcr die Verwendung eines service workers. Wir erstellen folgende index.html . index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!DOCTYPE HTML> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > Erstes Beispiel service worker </ title > </ head > < body > < p > Gr\u00f6\u00dfte Primzahl bisher: < output id = \"result\" ></ output ></ p > < script > var worker = new Worker ( 'worker.js' ); worker . onmessage = function ( event ) { document . getElementById ( 'result' ). textContent = event . data ; }; </ script > </ body > </ html > In Zeile 10 wird mithilfe des Worker -Kunstruktors ein Worker -Objekt erzeugt. Dem Konstruktor wird die Implementierung des workers \u00fcbergeben, genauer gesagt, die Implementierung des Event-Handlers f\u00fcr onmessage des Worker -Objektes. Die Implementierung des onmessage -Event-Handlers sieht typischerweise so aus, dass der service worker mit einer postMessage antwortet und diese an die Seite \u00fcbergibt. In unserem Beispiel ist die Implementierung wie folgt: worker.js 1 2 3 4 5 6 7 8 9 var n = 1 ; search : while ( true ) { n += 1 ; for ( var i = 2 ; i <= Math . sqrt ( n ); i += 1 ) if ( n % i == 0 ) continue search ; // found a prime! postMessage ( n ); } Zeile 8 enth\u00e4lt die postMessage . Darin wird eine Zahl n an die Seite geschickt, sobald sie berechnet wurde. Es handelt sich bei der Berechnung um eine Primzahlberechnung. Das hei\u00dft, der service worker arbeitet im Hintergrund und \"sucht\" neue Primzahlen. Sobald der service worker eine neue Primzahl gefunden hat, schickt er diese mithilfe der postMessage() -Funktion an die Webseite. Dadurch wird das onmessage -Ereignis (genauer gesagt, handelt es sich um das message -Event) behandelt. Wann immer onmessage auftritt, aktualisiert die Seite, genauer gesagt, der textContent des <output> -Elementes mit der id= \"result\" (siehe Zeilen 11-13 in index.html ). Dieses Beispiel ist extra einfach gehalten. genauer gesagt, handelt es sich bei dem Beispiel \"nur\" um einen web worker . Das W3C unterscheidet zwischen service workers und web workers . Der Unterschied zwischen web worker und * service worker* wird z.B. hier beschrieben.","title":"Einfaches Beispiel service worker"},{"location":"serviceworker/#web-worker-vs-service-worker","text":"Wir verwenden f\u00fcr die Unterscheidung zwischen web worker und service worker haupts\u00e4chlich dieses Dokument . Darin finden wir auch folgendes Bild zur Beschreibung eines web workers: Ein web worker hat kein spezifisches Einsatzszenario, au\u00dfer dass er unabh\u00e4ngig von Hauptthread der Anwendung l\u00e4uft und Nachrichten mittels postMessage() an die Anwendung schicken kann. Demgegen\u00fcber ist ein service worker ein spezieller web worker , der als Proxy zwischen Anwendung und dem Netzwerk bzw. dem Cache agiert. Service workers verf\u00fcgen \u00fcber mehr Funktionalit\u00e4ten als web workers . Dazu geh\u00f6ren einerseits die Ereignisse, auf die service workers reagieren k\u00f6nnen: install und activate (sogenannte Lifecycle events ), fetch und weitere Ereignisse, die durch Erweiterungen spezifiziert werden, z.B. push , notificationclick , notificationclose , sync , canmakepayment , paymentrequest usw. (sogenannte Functional events ) sowie message und messageerror vom Web worker und andererseits die Status, in denen sich ein service worker befinden kann: parsed , installing , installed , activating , activated und redundant (initial: parsed ) Die prinzipielle Idee der Registrierung eines service workers sieht so aus: Die beiden Lifecycle-Events install und activate sind bereits eingezeichnet. Dabei ist zu betonen, dass ein service worker erst dann aktiviert werden kann, wenn kein anderer service worker mehr (in der gleichen Dom\u00e4ne/im gleichen Scope) l\u00e4uft. Ein anderer service worker, der eventuell noch l\u00e4uft, muss erst geschlossen werden, bevor der neue service worker das activate -Ereignis ausl\u00f6sen kann. Damit ein solcher \"alter\" service worker geschlossen werden kann, m\u00fcssen zumindest alle Tabs im Browser, in denen die Webanwendung l\u00e4uft, geschlossen werden. Selbst dann l\u00e4uft der service worker aber immernoch weiter. Er muss explizit geschlossen werden. Das zeigen wir sp\u00e4ter.","title":"Web worker vs. service worker"},{"location":"serviceworker/#registrierung-eines-service-workers","text":"W\u00e4hrend wir f\u00fcr das einfache Beispiel mit dem web worker noch den Worker() -Konstruktor verwendet haben, erfolgt die Registrierung eines service workers mittels navigator.serviceWorker.register('./sw.js') , wobei in sw.js der service worker implementiert ist. Wir schauen uns die prinzipielle Registrierung an: index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 <! DOCTYPE HTML > < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > Erstes Beispiel service worker < /title> < /head> < body > < p > \u00d6ffne die developer tools < /p> < script > if ( 'serviceWorker' in navigator ) { // Register a service worker hosted at the root of the // site using the default scope. navigator . serviceWorker . register ( './sw.js' ). then ( function ( registration ) { console . log ( 'Service worker registration succeeded:' , registration ); console . log ( 'Scope ist ' + registration . scope ); // At this point, you can optionally do something // with registration. See https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration }). catch ( function ( error ) { console . log ( 'Service worker registration failed:' , error ); }); // Independent of the registration, let's also display // information about whether the current page is controlled // by an existing service worker, and when that // controller changes. // First, do a one-off check if there's currently a // service worker in control. if ( navigator . serviceWorker . controller ) { console . log ( 'This page is currently controlled by:' , navigator . serviceWorker . controller ); } // Then, register a handler to detect when a new or // updated service worker takes control. navigator . serviceWorker . oncontrollerchange = function () { console . log ( 'This page is now controlled by:' , navigator . serviceWorker . controller ); }; } else { console . log ( 'Service workers are not supported.' ); } < /script> < /body> < /html> Wir haben hier die registrierung des service workers innerhalb des <script> -Elementes. Besser (und das werden wir sp\u00e4ter auch immer machen) ist die Erstellung einer eigenen .js -Datei daf\u00fcr. Wenn wir die Developer Tools \u00f6ffnen, sehen wir auf der Console folgende Ausgabe: F\u00fcr diejenigen, f\u00fcr die das Registrierungs-Beispiel oben zu lang ist, hier die Version von W3C : 1 2 3 4 5 6 7 8 9 10 // scope defaults to the path the script sits in // \"/\" in this example navigator . serviceWorker . register ( \"/serviceworker.js\" ). then ( registration => { console . log ( \"success!\" ); if ( registration . installing ) { registration . installing . postMessage ( \"Howdy from your installing page.\" ); } }, err => { console . error ( \"Installing the worker failed!\" , err ); });","title":"Registrierung eines service workers"},{"location":"serviceworker/#registrierung-eines-service-workers-in-htw-insta","text":"Nun, da wir wissen, wie die Registrierung eines service workers prinzipiell funktioniert, f\u00fcgen wir unserem HTW-Insta -Beispiel einen solchen hinzu. Den aktuellen Stand der Anwendung finden Sie unter IKT-PWA-02 . Das ist die Version, in der bereits das Web-App-Manifest enthalten ist. Zun\u00e4chst beachten wir noch einen besonderen Eintrag in der package.json : package.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"name\" : \"IKT-PWA-02\" , \"version\" : \"1.0.0\" , \"description\" : \"Grundger\u00fcst einer PWA mit Web-App-Manifest\" , \"main\" : \"index.js\" , \"scripts\" : { \"start\" : \"http-server -c-1\" }, \"keywords\" : [ \"pwa\" , \"progressive\" , \"web\" , \"app\" , \"ikt\" , \"htw\" , \"fiw\" ], \"author\" : \"J. freiheit\" , \"license\" : \"ISC\" , \"devDependencies\" : { \"http-server\" : \"^14.1.0\" } } In Zeile 7 wird definiert, dass wir bei Aufruf des npm start -Befehls den Webserver http-server starten. Das Argument -c-1 besagt, dass wir f\u00fcr diesen Server nicht den Browser-Cache verwenden wollen. Jede datei, die wir somit vom Webserver anfordern, wird somit auch tats\u00e4chlich neu geladen. Stattdessen wollen wir n\u00e4mlich nur den Cache des service workers verwenden. F\u00fcr unseren service worker erstellen wir uns im public -Ordner eine Datei sw.js . Da der service worker im public -Ordner angelegt wird, ist sein Scope unsere komplette Webanwendung. Wollten wir z.B. einen service worker, der nur f\u00fcr unsere Hilfe-Seiten zust\u00e4ndig ist, so h\u00e4tten wir die Datei im help -Ordner erzeugt. Um unseren service worker zu registrieren, m\u00fcssen wir ihn in alle unsere HTML-Seiten einbinden. Wir haben die /public/index.html -Datei und die /public/help/index.html . Dort k\u00f6nnten wir innerhalb des eines <script> -Elementes die Registrierung durchf\u00fchren. Da wir aber bereits in beiden Dateien die Datei public/src/js/app.js einbinden, erledigen wir die Registrierung einfach dort. Dann ist sie nur an einer Stelle und wir m\u00fcssen die HTML-Dateien nicht anpassen. In die /public/src/js/app.js schreiben wir nun Folgendes: /public/src/js/app.js 1 2 3 4 5 6 7 if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( '/sw.js' ) . then ( function () { console . log ( 'service worker registriert' ) }); } Starten unserer Anwendung und Aufruf im Browser ergibt die Ausgabe service worker registriert in der Konsole der DevTools. Im Zusammenhang mit service workern gibt es folgendes zu beachten: service worker funktionieren nur mit https oder auf localhost! Wundern Sie sich also nicht, wenn Ihr service worker nicht funktioniert, sobald Sie Ihre Anwendung auf einem Webserver ausf\u00fchren, der https nicht unterst\u00fctzt. Anleitungen, wie Sie einen Webserver f\u00fcr https konfigurieren, finden Sie z.B. hier . Schauen Sie ansonsten auch hier und hier .","title":"Registrierung eines service workers in HTW-Insta"},{"location":"serviceworker/#service-worker-life-cycle-ereignisse-behandeln","text":"Nun implementieren wir den service worker. Wir haben ihn bereits registriert, aber die Datei sw.js ist noch leer. Die grundlegende Idee eines service workers ist es, Ereignisse zu behandeln. Wir werden unserem service worker also eine Reihe von addEventListener() -Funktionen hinzuf\u00fcgen. Diese Funktion kennen wir bereits aus \"normalem\" JavaScript-Code. Dort haben h\u00e4ufig so etwas wie addEventListener('click', function() { /* ... */ }) geschrieben. Das click -Ereignis hat aber keine Relevanz f\u00fcr service worker, da ein service worker keine Auswirkungen auf das DOM hat. Vielmehr reagiert ein service worker auf Ereignisse, die wir bereits oben beschrieben haben. Wir f\u00fcgen unserem service worker Ereignisbehandlungen hinzu: /public/src/sw.js 1 2 3 4 5 6 7 8 self . addEventListener ( 'install' , function ( event ) { console . log ( 'service worker --> installing ...' , event ); }) self . addEventListener ( 'activate' , function ( event ) { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) Wir melden uns also an zwei Ereignisse an: an das install -Ereignis und das activate -Ereignis. Beide Ereignisse sind auch gut hier beschrieben. Beide Ereignisbehandlungen sind zun\u00e4chst einfache Ausgaben auf die Konsole. Zwei Sachen sind noch erw\u00e4hnenswert: erstens wird self verwendet, um auf den service worker zu referenzieren. F\u00fcr Erl\u00e4uterungen \u00fcber den Unterschied von this und self k\u00f6nnen Sie sich z.B. hier informieren. Grunds\u00e4tzlich ist es so, dass mit self auf den gesamten Scope referenziert wird. In Webanwendungen ist der Scope h\u00e4ufig window , hier ist es aber die Domain, die den Scope des service workers beschreibt. Wir referenzieren also nicht auf den service worker selbst, sondern auf seinen Scope. Die zweite erw\u00e4hnenswerte Sache steht in Zeile 7 . Wenn ein service worker registriert ist, dann \"kontrolliert\" er nicht automatisch alle Webseiten in seiner Domain. Erst durch das Neuladen dieser Seiten gelangen sie unter seine Kontrolle. Mithilfe der claim() -Funktion aus dem Interface Clients \u00fcbernimmt der service worker die Kontrolle aber sofort, d.h. ohne ein Neuladen der Site. Einzige Ausnahme ist die Seite, die aktuell im Browser gezeigt wird. F\u00fcr diese muss tats\u00e4chlich ein Reload durchgef\u00fchrt werden. Weitere Informationen dazu finden Sie auch hier . Wenn wir die Anwendung nun starten und dann im Browser aufrufen, erhalten wir folgende Ausgabe auf der Konsole: Wir sehen, dass das install -Ereignis ausgel\u00f6st wurde, aber offensichtlich nicht das activate -Ereignis. Warum wurde das activate -Ereignis nicht ausgel\u00f6st? Darum k\u00fcmmern wir uns im folgenden Abschnitt. Noch eine kurze Bemerkung zur Reihenfolge der Ausgaben auf der Konsole. Auf der Konsole haben wir folgende Ausgaben: service worker registriert service worker --> installing ... Das verwundert wahrscheinlich, weil das install -Event ausgel\u00f6st wird, bevor der service worker (existiert und) registriert werden kann. Also m\u00fcssten die Ausgaben eigentlich in der anderen Reihenfolge erscheinen. Wir erinnern uns (siehe zweite Abbildung ganz oben in diesem Kapitel): der service worker l\u00e4uft auf einem anderen Thread, als das \"normale\" JavaScript unserer Webanwendung. Also laufen app.js und sw.js auf verschiedenen Threads. In welchem dieser beiden Threads nun zuerst eine Ausgabe erfolgt, h\u00e4ngt von vielen verschiedenen Faktoren ab, l\u00e4sst sich aber auch nicht beeinflussen. Dieses Mal war es so, dass der app.js -Thread schneller mit der Ausgabe war, als der sw.js -Thread. Das kann beim n\u00e4chsten Mal schon anders sein. Wichtig ist, dass wir wissen, dass diese beiden Threads g\u00e4nzlich nebenl\u00e4ufig und unabh\u00e4ngig voneinander laufen. Sollten sich dabei Ausgaben \"\u00fcberholen\", dann ist das kein Bug, sondern ein Feature.","title":"Service worker: Life-Cycle-Ereignisse behandeln"},{"location":"serviceworker/#service-worker-aktualisieren-und-aktivieren","text":"Warum wurde das activate -Ereignis nicht ausgel\u00f6st? Dazu werfen wir einen Blick in unsere DevTools. Wir w\u00e4hlen den Reiter Application und dann im linken Men\u00fc unter Application den Men\u00fcpunkt Service Woorkers : Wir sehen, dass der service worker im Status des Aktivierens ist, aber noch darauf wartet, aktiviert zu sein ( waiting to activate ). Hierzu ist es wichtig zu wissen: solange Sie im Browser (mindestens) einen Tab mit Ihrer Webanwendung offen haben, wird ein neuer service worker zwar installiert und registriert, aber nicht aktiviert, das liegt daran, dass die offene Seite eventuell noch mit einem alten service worker kommuniziert (evtl. hat der alte service worker noch etwas im Cache, das mit der Webanwendung synchronisiert werden m\u00fcsste). Wenn wir den Tab mit unserer Anwendung schlie\u00dfen und ihn erneut \u00f6ffnen, dann sehen wir: Es wurden also sowohl das install - als auch das activate -Ereignis ausgel\u00f6st. Auf der Konsole erscheint entsprechend: Wenn Sie Ihren service worker aktualisiert haben, m\u00fcssen Sie alle Tabs Ihrer Webanwendung schlie\u00dfen und erneut \u00f6ffnen, um den neuen service worker zu aktivieren! Beherzigen Sie die obige Ausgabe. Es kann Ihnen sehr viel Implementierungskummer bereiten, wenn Sie es nicht tun. Sie ver\u00e4ndern Ihren Code im service worker, aber die \u00c4nderungen sind nicht wirksam? Dann haben Sie vielleicht nur ein Reload Ihrer Webanwendung durchgef\u00fchrt - das reicht aber f\u00fcr den aktualisierten service worker nicht ! Aber zum Gl\u00fcck bieten die DevTools Hilfe, so dass Sie w\u00e4hrend der Entwicklung doch nicht immer den Tab schlie\u00dfen und neu \u00f6ffnen m\u00fcssen. Betrachten wir nochmals die folgende Abbildung: Sie haben drei M\u00f6glichkeiten, den service zu aktivieren: Markieren Sie die Checkbox links neben Update on reload . Dann wird durch das Reload Ihrer Webanwendung der aktualisierte service worker aktiviert. Klicken Sie auf den Link Update oder Klicken Sie auf den Link skipWaiting . Mit einem der drei Hilfen oben vermeiden Sie das Schlie\u00dfen und Neu\u00f6ffnen des Tabs und der Webanwendung. Am einfachsten ist die erste Variante. Dann m\u00fcssen Sie nur noch Reloaden und ansonsten weiter gar nichts machen.","title":"Service worker aktualisieren und aktivieren"},{"location":"serviceworker/#arrow-notation-verwenden","text":"Wenn wir uns die Implementierung des service workers anschauen, dann sehen wir, dass wir etwas \"old school\" unterwegs sind, also so ca. 2017 ;-). Wir sollten anstelle der function() -Notation lieber die Arrow -Notation verwenden, um ein bisschen mehr up-to-date zu sein ;-). Zu Arrow-Notation siehe auch Hilfen\u2192Arrow-Notation . Unsere service worker Implementierung sieht dann so aus: /public/src/sw.js 1 2 3 4 5 6 7 8 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) Die neuere Notation \u00e4ndert an der Funktionalit\u00e4t nat\u00fcrlich nichts.","title":"Arrow-Notation verwenden"},{"location":"serviceworker/#service-worker-andere-ereignisse-behandeln","text":"Bis jetzt haben wir nur Life-Cycle-Events behandelt. Jetzt schauen wir uns einmal das fetch -Ereignis an. Wir wissen bereits , dass das fetch -Ereignis immer dann ausgel\u00f6st wird, wenn etwas vom Webserver geladen wird, wenn also CSS-Dateien oder ein Bild oder JavaScript-Dateien geladen werden. Wir behandeln ein solches Ereignis wiederum mit einer einfachen Konsolen-Ausgabe: /public/src/sw.js 1 2 3 4 5 6 7 8 9 10 11 12 self . addEventListener ( 'install' , event => { console . log ( 'service worker --> installing ...' , event ); }) self . addEventListener ( 'activate' , event => { console . log ( 'service worker --> activating ...' , event ); return self . clients . claim (); }) self . addEventListener ( 'fetch' , event => { console . log ( 'service worker --> fetching ...' , event ); }) Falls wir in den DevTools unter Application \u2192 Application \u2192 Service Workers das H\u00e4kchen bei Update on Reload gesetzt hatten, m\u00fcssen wir tats\u00e4chlich nur ein Reload der Webanwendung durchf\u00fchren und wir sehen auf der Konsole, dass das fetch -Event selbst f\u00fcr unsere bis jetzt sehr kleine Anwendung recht h\u00e4ufig aufgerufen wird: Wenn Sie in die jeweiligen FetchEvent -Objekte hineinklicken, welche Ressourcen jeweils per GET vom Webserver geladen werden.","title":"Service worker: andere Ereignisse behandeln"},{"location":"serviceworker/#anwendung-mit-einem-android-gerat-verbinden","text":"Ich kann es leider (bis jetzt noch) nicht ausprobieren, aber hier ist beschrieben, wie Sie die Anwendung auf einem Android-Ger\u00e4t aufrufen k\u00f6nnen. Nun, da wir service worker verwenden, sollte es funktionieren. Das hier mag auch hilfreich sein.","title":"Anwendung mit einem Android-Ger\u00e4t verbinden"},{"location":"serviceworker/#anwendung-auf-ihrem-iphone-aufrufen","text":"Um die Anwendung auf Ihrem iPhone aufzurufen, m\u00fcssen Sie sich zun\u00e4chst nur anschauen, was im Terminal ausgegeben wird, nachdem Sie npm start aufgerufen haben: Starting up http-server, serving ./public Available on: http://127.0.0.1:8080 htpp://192.168.1.24:8080 Hit CTRL-C to stop the server Rufen Sie in Ihrem iPhone einen Browser auf (z.B. Safari oder Chrome) und geben dort di ezweite der beiden URLs ein (also htpp://192.168.1.24:8080 ). Die Anwendung wird ausgef\u00fchrt. iOS unterst\u00fctzt aber leider (noch) nicht, dass Sie ein Start-Icon daf\u00fcr auf den Startbildschirm ablegen.","title":"Anwendung auf Ihrem iPhone aufrufen"},{"location":"tools/","text":"Werkzeuge \u00b6 Chrome \u00b6 Es wird empfohlen, Chrome als Browser zu verwenden, da dieser Browser die besten Entwicklertools f\u00fcr Progressive Web Apps zur Verf\u00fcgung stellt. Insbesondere ist es empfehlenswert, das Plugin Lighthouse f\u00fcr die Developertools von Chrome zu installieren. Lighthouse \u00b6 Lighthouse ist ein Plugin f\u00fcr die Chrome-Developertools, mit dessen Hilfe gemessen werden kann, wie progressive eine App ist. Installieren Sie sich dieses Plugin, um auch die Performance Ihrer PWA zu messen. Integrated Development Environment (IDE) \u00b6 F\u00fcr die Webentwicklung stehen Ihnen viele gute Entwicklungswerkzeuge zur Verf\u00fcgung. F\u00fcr welches Sie sich entscheiden, bleibt Ihnen \u00fcberlassen. Hier eine Auswahl der aus meiner Sicht besten Entwicklungswerkzeuge: IntelliJ IDEA PhpStorm WebStorm Sublime Text Atom Visual Studio Code F\u00fcr die Tools von Jetbrains ben\u00f6tigen Sie einen Account. Mit Ihrer HTW-E-Mail-Adresse bekommen Sie aber eine kostenlose Hochschullizenz und k\u00f6nnen so die Enterprise-Versionen kostenlos nutzen. Sublime Text ist Shareware und fragt regelm\u00e4\u00dfig, ob Sie spenden m\u00f6chten. Node.js \u00b6 Node.js ist eine JavaScript-Laufzeitumgebung. Node.js reagiert auf Ereignisse und antwortet asynchron. Das bedeutet, dass die Ausf\u00fchrung einer Ereignisbearbeitung nicht zum Blockieren der Laufzeitumgebung f\u00fchrt, sondern nebenl\u00e4ufig weitere Ereignisse eintreffen k\u00f6nnen, die ebenfalls asynchron behandelt werden. Dies geschieht mithilfe des Callback-Patterns . Laden Sie sich hier die aktuellste Version von Node.js herunter und installieren Sie diese auf Ihrem Rechner. Android Studio \u00b6 Um unsere PWAs als mobile Webanwendungen zu emulieren, benutzen wir Android Studio . Es ist f\u00fcr Mac, Linux und Windows verf\u00fcgbar. Laden Sie es sich herunter und installieren Sie es. Sie k\u00f6nnen es herunterladen und installieren, ohne einen Google-Account anzulegen (es gibt auch keinen Grund, das zu tun ;-)). https f\u00fcr localhost \u00b6 f\u00fcr Mac siehe hier https f\u00fcr Webserver \u00b6 siehe hier siehe hier Ngrok \u00b6 Ngrok stellt einen sicheren Tunnel zu einem Webserver her. Ngrok wirkt wie ein Proxy, der einer Anwendung suggeriert, mit einem Webserver \u00fcber eine sichere Verbindung zu kommunizieren, d.h. die Verbindung wirkt wie eine https -Verbindung. Die Installation ist einfach, ben\u00f6tigt aber Registrierungsdaten (zur Erzeugung des Authentifizierungstokens). Nach dem Download wird das Paket entpackt und mit dem Authentifizierungstoken aufgerufen. Nach dem Starten der Webanwendung stellt man mit ngrok http <Port> den sicheren Tunnel her, wobei <Port> f\u00fcr den Port steht, unter dem die Anwednung auf dem Webserver l\u00e4uft. Icons erzeugen und in die manifest.json eintragen \u00b6 Es ist ziemlich m\u00fchsam, alle ben\u00f6tigten Icons f\u00fcr die unterschiedlichen Plattformen zu erzeugen und dann noch die entsprechenden Eintr\u00e4ge in der manifest.json vorzunehmen. Zum Gl\u00fcck gibt es aber ein Werkzeug, das das f\u00fcr uns \u00fcbernimmt: pwa-asset-generator . Sie ben\u00f6tigen nur das Ausgangsicon in Originalgr\u00f6\u00dfe und alles andere wird f\u00fcr Sie erledgt. Alles weitere dazu steht hier . WebApp-Manifest-Generator \u00b6 Bei der Erstellung Ihrer manifest.json k\u00f6nnen Sie sich auch unterst\u00fctzen lassen, n\u00e4mlich hier oder hier . Workbox \u00b6 Workbox ist eine JavaScript-Bibliothek, die alle wesentlichen Funktionalit\u00e4ten von Service Workern bereitstellt. Interssante Links zu PWA \u00b6 PWA Checklist PWA API 11 Examples of Progressive Web Apps How-to: Progressive Web Apps praktisch erkl\u00e4rt Chrome Developer Summit 2020 12 Best Examples of Progressive Web Apps (PWAs) in 2020 Lighthouse Performance Scoring Service worker Spezifikation","title":"Tools"},{"location":"tools/#werkzeuge","text":"","title":"Werkzeuge"},{"location":"tools/#chrome","text":"Es wird empfohlen, Chrome als Browser zu verwenden, da dieser Browser die besten Entwicklertools f\u00fcr Progressive Web Apps zur Verf\u00fcgung stellt. Insbesondere ist es empfehlenswert, das Plugin Lighthouse f\u00fcr die Developertools von Chrome zu installieren.","title":"Chrome"},{"location":"tools/#lighthouse","text":"Lighthouse ist ein Plugin f\u00fcr die Chrome-Developertools, mit dessen Hilfe gemessen werden kann, wie progressive eine App ist. Installieren Sie sich dieses Plugin, um auch die Performance Ihrer PWA zu messen.","title":"Lighthouse"},{"location":"tools/#integrated-development-environment-ide","text":"F\u00fcr die Webentwicklung stehen Ihnen viele gute Entwicklungswerkzeuge zur Verf\u00fcgung. F\u00fcr welches Sie sich entscheiden, bleibt Ihnen \u00fcberlassen. Hier eine Auswahl der aus meiner Sicht besten Entwicklungswerkzeuge: IntelliJ IDEA PhpStorm WebStorm Sublime Text Atom Visual Studio Code F\u00fcr die Tools von Jetbrains ben\u00f6tigen Sie einen Account. Mit Ihrer HTW-E-Mail-Adresse bekommen Sie aber eine kostenlose Hochschullizenz und k\u00f6nnen so die Enterprise-Versionen kostenlos nutzen. Sublime Text ist Shareware und fragt regelm\u00e4\u00dfig, ob Sie spenden m\u00f6chten.","title":"Integrated Development Environment (IDE)"},{"location":"tools/#nodejs","text":"Node.js ist eine JavaScript-Laufzeitumgebung. Node.js reagiert auf Ereignisse und antwortet asynchron. Das bedeutet, dass die Ausf\u00fchrung einer Ereignisbearbeitung nicht zum Blockieren der Laufzeitumgebung f\u00fchrt, sondern nebenl\u00e4ufig weitere Ereignisse eintreffen k\u00f6nnen, die ebenfalls asynchron behandelt werden. Dies geschieht mithilfe des Callback-Patterns . Laden Sie sich hier die aktuellste Version von Node.js herunter und installieren Sie diese auf Ihrem Rechner.","title":"Node.js"},{"location":"tools/#android-studio","text":"Um unsere PWAs als mobile Webanwendungen zu emulieren, benutzen wir Android Studio . Es ist f\u00fcr Mac, Linux und Windows verf\u00fcgbar. Laden Sie es sich herunter und installieren Sie es. Sie k\u00f6nnen es herunterladen und installieren, ohne einen Google-Account anzulegen (es gibt auch keinen Grund, das zu tun ;-)).","title":"Android Studio"},{"location":"tools/#https-fur-localhost","text":"f\u00fcr Mac siehe hier","title":"https f\u00fcr localhost"},{"location":"tools/#https-fur-webserver","text":"siehe hier siehe hier","title":"https f\u00fcr Webserver"},{"location":"tools/#ngrok","text":"Ngrok stellt einen sicheren Tunnel zu einem Webserver her. Ngrok wirkt wie ein Proxy, der einer Anwendung suggeriert, mit einem Webserver \u00fcber eine sichere Verbindung zu kommunizieren, d.h. die Verbindung wirkt wie eine https -Verbindung. Die Installation ist einfach, ben\u00f6tigt aber Registrierungsdaten (zur Erzeugung des Authentifizierungstokens). Nach dem Download wird das Paket entpackt und mit dem Authentifizierungstoken aufgerufen. Nach dem Starten der Webanwendung stellt man mit ngrok http <Port> den sicheren Tunnel her, wobei <Port> f\u00fcr den Port steht, unter dem die Anwednung auf dem Webserver l\u00e4uft.","title":"Ngrok"},{"location":"tools/#icons-erzeugen-und-in-die-manifestjson-eintragen","text":"Es ist ziemlich m\u00fchsam, alle ben\u00f6tigten Icons f\u00fcr die unterschiedlichen Plattformen zu erzeugen und dann noch die entsprechenden Eintr\u00e4ge in der manifest.json vorzunehmen. Zum Gl\u00fcck gibt es aber ein Werkzeug, das das f\u00fcr uns \u00fcbernimmt: pwa-asset-generator . Sie ben\u00f6tigen nur das Ausgangsicon in Originalgr\u00f6\u00dfe und alles andere wird f\u00fcr Sie erledgt. Alles weitere dazu steht hier .","title":"Icons erzeugen und in die manifest.json eintragen"},{"location":"tools/#webapp-manifest-generator","text":"Bei der Erstellung Ihrer manifest.json k\u00f6nnen Sie sich auch unterst\u00fctzen lassen, n\u00e4mlich hier oder hier .","title":"WebApp-Manifest-Generator"},{"location":"tools/#workbox","text":"Workbox ist eine JavaScript-Bibliothek, die alle wesentlichen Funktionalit\u00e4ten von Service Workern bereitstellt.","title":"Workbox"},{"location":"tools/#interssante-links-zu-pwa","text":"PWA Checklist PWA API 11 Examples of Progressive Web Apps How-to: Progressive Web Apps praktisch erkl\u00e4rt Chrome Developer Summit 2020 12 Best Examples of Progressive Web Apps (PWAs) in 2020 Lighthouse Performance Scoring Service worker Spezifikation","title":"Interssante Links zu PWA"}]}